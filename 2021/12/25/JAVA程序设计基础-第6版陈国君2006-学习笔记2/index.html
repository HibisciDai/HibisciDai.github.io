<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="JAVA程序设计基础-第6版陈国君2006-学习笔记2"><meta name="keywords" content="JAVA,JAVA基础,学习笔记"><meta name="author" content="HibisciDai"><meta name="copyright" content="HibisciDai"><title>JAVA程序设计基础-第6版陈国君2006-学习笔记2 | HibisciDai</title><link rel="shortcut icon" href="/img/avatar.png"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="manifest" href="/manifest.json"><link rel="manifest" href="/manifest.json"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '6.1.0'
} </script><meta name="generator" content="Hexo 6.1.0"><link rel="alternate" href="/atom.xml" title="HibisciDai" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JAVA%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80-%E7%AC%AC6%E7%89%88%E9%99%88%E5%9B%BD%E5%90%9B2006-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02"><span class="toc-number">1.</span> <span class="toc-text">JAVA程序设计基础-第6版陈国君2006-学习笔记2</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.</span> <span class="toc-text">第六章 类与对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.</span> <span class="toc-text">类的基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E7%B1%BB"><span class="toc-number">2.2.</span> <span class="toc-text">定义类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E4%B8%80%E8%88%AC%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.1.</span> <span class="toc-text">类的一般结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">2.2.2.</span> <span class="toc-text">成员变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.3.</span> <span class="toc-text">成员方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.2.4.</span> <span class="toc-text">成员变量与局部变量的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="toc-number">2.3.</span> <span class="toc-text">对象的创建与使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.3.1.</span> <span class="toc-text">创建对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">2.3.2.</span> <span class="toc-text">对象的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E7%B1%BB%E5%AE%9A%E4%B9%89%E5%86%85%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.3.</span> <span class="toc-text">在类定义内调用方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E7%9A%84%E4%BC%A0%E9%80%92"><span class="toc-number">2.4.</span> <span class="toc-text">参数的传递</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E5%8F%98%E9%87%8F%E4%B8%BA%E5%8F%82%E6%95%B0%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">2.4.1.</span> <span class="toc-text">以变量为参数调用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0%E6%88%96%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8"><span class="toc-number">2.4.2.</span> <span class="toc-text">以数组作为参数或返回值的方法调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%AD%E7%9A%84%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-number">2.4.3.</span> <span class="toc-text">方法中的可变参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.5.</span> <span class="toc-text">匿名对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E7%AB%A0%E5%B0%8F%E7%BB%93"><span class="toc-number">2.6.</span> <span class="toc-text">本章小结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98"><span class="toc-number">2.7.</span> <span class="toc-text">课后习题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-Java%E8%AF%AD%E8%A8%80%E7%B1%BB%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">3.</span> <span class="toc-text">第七章 Java语言类的特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%A7%81%E6%9C%89%E6%88%90%E5%91%98%E4%B8%8E%E5%85%AC%E5%85%B1%E6%88%90%E5%91%98"><span class="toc-number">3.1.</span> <span class="toc-text">类的私有成员与公共成员</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%81%E6%9C%89%E6%88%90%E5%91%98"><span class="toc-number">3.1.1.</span> <span class="toc-text">私有成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AC%E5%85%B1%E6%88%90%E5%91%98"><span class="toc-number">3.1.2.</span> <span class="toc-text">公共成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%9C%81%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E7%AC%A6"><span class="toc-number">3.1.3.</span> <span class="toc-text">缺省访问控制符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD-overloading"><span class="toc-number">3.2.</span> <span class="toc-text">方法的重载(overloading)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-constructor"><span class="toc-number">3.3.</span> <span class="toc-text">构造方法(constructor)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%AE%9A%E4%B9%89"><span class="toc-number">3.3.1.</span> <span class="toc-text">构造方法的作用与定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">3.3.2.</span> <span class="toc-text">默认的构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="toc-number">3.3.3.</span> <span class="toc-text">构造方法的重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E4%B8%80%E4%B8%AA%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%86%85%E8%B0%83%E7%94%A8%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">3.3.4.</span> <span class="toc-text">从一个构造方法内调用另一个构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AC%E5%85%B1%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E4%B8%8E%E7%A7%81%E6%9C%89%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">3.3.5.</span> <span class="toc-text">公共的构造方法与私有的构造方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-number">3.4.</span> <span class="toc-text">静态成员</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E6%88%90%E5%91%98"><span class="toc-number">3.4.1.</span> <span class="toc-text">实例成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="toc-number">3.4.2.</span> <span class="toc-text">静态变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">3.4.3.</span> <span class="toc-text">静态方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E5%99%A8"><span class="toc-number">3.4.4.</span> <span class="toc-text">静态初始化器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">3.5.</span> <span class="toc-text">对象的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%B5%8B%E5%80%BC%E4%B8%8E%E6%AF%94%E8%BE%83"><span class="toc-number">3.5.1.</span> <span class="toc-text">对象的赋值与比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E5%8F%98%E9%87%8F%E4%BD%9C%E4%B8%BA%E6%96%B9%E6%B3%95%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">3.5.2.</span> <span class="toc-text">引用变量作为方法的返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%95%B0%E7%BB%84"><span class="toc-number">3.5.3.</span> <span class="toc-text">类类型的数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84%E4%B8%BA%E5%8F%82%E6%95%B0%E8%BF%9B%E8%A1%8C%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8"><span class="toc-number">3.5.4.</span> <span class="toc-text">以对象数组为参数进行方法调用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E8%AF%AD%E8%A8%80%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">3.6.</span> <span class="toc-text">Java语言的垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%A5%BD%E5%A4%84"><span class="toc-number">3.6.1.</span> <span class="toc-text">垃圾回收的两个好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E4%B8%89%E4%B8%AA%E7%89%B9%E7%82%B9"><span class="toc-number">3.6.2.</span> <span class="toc-text">垃圾回收的三个特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E7%AB%A0%E5%B0%8F%E7%BB%93-1"><span class="toc-number">3.7.</span> <span class="toc-text">本章小结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98-1"><span class="toc-number">3.8.</span> <span class="toc-text">课后习题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E7%BB%A7%E6%89%BF%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB%E3%80%81%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%9E%9A%E4%B8%BE"><span class="toc-number">4.</span> <span class="toc-text">第八章 继承、抽象类、接口和枚举</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">4.1.</span> <span class="toc-text">类的继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E7%B1%BB%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">4.1.1.</span> <span class="toc-text">子类的创建</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%90%E7%B1%BB%E7%9A%84%E6%9E%84%E5%BB%BA%E6%96%B9%E6%B3%95"><span class="toc-number">4.1.1.1.</span> <span class="toc-text">子类的构建方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E4%B8%AD%E7%89%B9%E5%AE%9A%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">4.1.1.2.</span> <span class="toc-text">调用父类中特定的构造方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E5%AD%90%E7%B1%BB%E4%B8%AD%E8%AE%BF%E9%97%AE%E7%88%B6%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98"><span class="toc-number">4.1.2.</span> <span class="toc-text">在子类中访问父类的成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%86%E7%9B%96"><span class="toc-number">4.1.3.</span> <span class="toc-text">覆盖</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E7%88%B6%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">4.1.3.1.</span> <span class="toc-text">覆盖父类的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E7%88%B6%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E5%AD%90%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98"><span class="toc-number">4.1.3.2.</span> <span class="toc-text">用父类的对象访问子类的成员</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E8%A2%AB%E7%BB%A7%E6%89%BF%E7%9A%84%E6%88%90%E5%91%98%E4%B8%8E%E6%9C%80%E7%BB%88%E7%B1%BB"><span class="toc-number">4.1.4.</span> <span class="toc-text">不可被继承的成员与最终类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object%E7%B1%BB"><span class="toc-number">4.1.5.</span> <span class="toc-text">Object类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#equals-%E6%96%B9%E6%B3%95"><span class="toc-number">4.1.5.1.</span> <span class="toc-text">equals()方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#toString-%E6%96%B9%E6%B3%95"><span class="toc-number">4.1.5.2.</span> <span class="toc-text">toString()方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getClass-%E6%96%B9%E6%B3%95"><span class="toc-number">4.1.5.3.</span> <span class="toc-text">getClass()方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E8%BF%90%E7%AE%97%E7%AC%A6instanceof"><span class="toc-number">4.1.5.4.</span> <span class="toc-text">对象运算符instanceof</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">4.2.</span> <span class="toc-text">抽象类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.1.</span> <span class="toc-text">抽象类与抽象方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">4.2.2.</span> <span class="toc-text">抽象类的应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.3.</span> <span class="toc-text">接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">4.3.1.</span> <span class="toc-text">接口的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%BC%95%E7%94%A8"><span class="toc-number">4.3.2.</span> <span class="toc-text">接口的实现与引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">4.3.3.</span> <span class="toc-text">接口的继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E7%B1%BB%E7%9A%84%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="toc-number">4.3.4.</span> <span class="toc-text">利用接口实现类的多重继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E4%B8%AD%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95"><span class="toc-number">4.3.5.</span> <span class="toc-text">接口中静态方法和默认方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%8E%A5%E5%8F%A3%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E4%B8%AD%E5%90%8D%E5%AD%97%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98"><span class="toc-number">4.3.6.</span> <span class="toc-text">解决接口多重继承中名字冲突问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-number">4.4.</span> <span class="toc-text">枚举</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">4.4.1.</span> <span class="toc-text">枚举类型的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%8C%85%E5%90%AB%E6%96%B9%E6%B3%95%E7%9A%84%E6%9E%9A%E4%B8%BE"><span class="toc-number">4.4.2.</span> <span class="toc-text">不包含方法的枚举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E5%90%AB%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E6%9E%9A%E4%B8%BE"><span class="toc-number">4.4.3.</span> <span class="toc-text">包含属性和方法的枚举</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85"><span class="toc-number">4.5.</span> <span class="toc-text">包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">4.5.1.</span> <span class="toc-text">包的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8package%E8%AF%AD%E5%8F%A5%E5%88%9B%E5%BB%BA%E5%8C%85"><span class="toc-number">4.5.2.</span> <span class="toc-text">使用package语句创建包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E5%8C%85"><span class="toc-number">4.5.3.</span> <span class="toc-text">Java语言中的常用包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E8%A8%80%E5%8C%85java-lang"><span class="toc-number">4.5.3.1.</span> <span class="toc-text">语言包java.lang</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81%E7%9A%84%E6%96%87%E4%BB%B6%E5%8C%85java-io"><span class="toc-number">4.5.3.2.</span> <span class="toc-text">输入输出流的文件包java.io</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%94%A8%E5%8C%85java-util"><span class="toc-number">4.5.3.3.</span> <span class="toc-text">实用包java.util</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%8A%9F%E8%83%BD%E5%8C%85java-net"><span class="toc-number">4.5.3.4.</span> <span class="toc-text">网络功能包java.net</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E5%8C%85java-sql"><span class="toc-number">4.5.3.5.</span> <span class="toc-text">数据库连接包java.sql</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E5%8C%85java-text"><span class="toc-number">4.5.3.6.</span> <span class="toc-text">文本包java.text</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%87%A0%E4%B8%AA%E5%B8%B8%E7%94%A8%E7%9A%84%E7%B1%BB"><span class="toc-number">4.5.4.</span> <span class="toc-text">Java语言中几个常用的类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Date%E7%B1%BB-java-util"><span class="toc-number">4.5.4.1.</span> <span class="toc-text">Date类(java.util)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Calender%E7%B1%BB-java-util"><span class="toc-number">4.5.4.2.</span> <span class="toc-text">Calender类(java.util)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Random%E7%B1%BB-java-util"><span class="toc-number">4.5.4.3.</span> <span class="toc-text">Random类(java.util)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Math%E7%B1%BB-java-lang"><span class="toc-number">4.5.4.4.</span> <span class="toc-text">Math类(java.lang)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8import%E8%AF%AD%E5%8F%A5%E5%BC%95%E7%94%A8Java%E5%AE%9A%E4%B9%89%E7%9A%84%E5%8C%85"><span class="toc-number">4.5.5.</span> <span class="toc-text">利用import语句引用Java定义的包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84"><span class="toc-number">4.5.6.</span> <span class="toc-text">Java程序结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E7%AB%A0%E5%B0%8F%E7%BB%93-2"><span class="toc-number">4.6.</span> <span class="toc-text">本章小结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98-2"><span class="toc-number">4.7.</span> <span class="toc-text">课后习题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">5.</span> <span class="toc-text">第九章 异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">5.1.</span> <span class="toc-text">异常处理的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E4%B8%8E%E5%BC%82%E5%B8%B8"><span class="toc-number">5.1.1.</span> <span class="toc-text">错误与异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E8%AF%AD%E8%A8%80%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-number">5.1.2.</span> <span class="toc-text">Java语言的异常处理机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%B1%BB"><span class="toc-number">5.2.</span> <span class="toc-text">异常处理类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">5.3.</span> <span class="toc-text">异常的处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="toc-number">5.4.</span> <span class="toc-text">抛出异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">5.4.1.</span> <span class="toc-text">抛出异常的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">5.4.2.</span> <span class="toc-text">处理异常的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%B1%E6%96%B9%E6%B3%95%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E4%BA%A4%E7%B3%BB%E7%BB%9F%E5%A4%84%E7%90%86"><span class="toc-number">5.4.3.</span> <span class="toc-text">由方法抛出异常交系统处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%85%B3%E9%97%AD%E8%B5%84%E6%BA%90%E7%9A%84try%E8%AF%AD%E5%8F%A5"><span class="toc-number">5.5.</span> <span class="toc-text">自动关闭资源的try语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E7%B1%BB"><span class="toc-number">5.6.</span> <span class="toc-text">自定义异常类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E7%AB%A0%E5%B0%8F%E7%BB%93-3"><span class="toc-number">5.7.</span> <span class="toc-text">本章小结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98-3"><span class="toc-number">5.8.</span> <span class="toc-text">课后习题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0-Java%E8%AF%AD%E8%A8%80%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E4%B8%8E%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86"><span class="toc-number">6.</span> <span class="toc-text">第十章 Java语言的输入输出与文件处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E8%AF%AD%E8%A8%80%E7%9A%84%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA"><span class="toc-number">6.1.</span> <span class="toc-text">Java语言的输入和输出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">6.1.1.</span> <span class="toc-text">流的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">6.1.1.1.</span> <span class="toc-text">输入输出流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E6%B5%81"><span class="toc-number">6.1.1.2.</span> <span class="toc-text">缓冲流</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81%E7%B1%BB%E5%BA%93"><span class="toc-number">6.1.2.</span> <span class="toc-text">输入输出流类库</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8InputStream%E5%92%8COutputStream%E6%B5%81%E7%B1%BB"><span class="toc-number">6.2.</span> <span class="toc-text">使用InputStream和OutputStream流类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81%E7%B1%BB"><span class="toc-number">6.2.1.</span> <span class="toc-text">基本的输入输出流类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#InputStream%E6%B5%81%E7%B1%BB"><span class="toc-number">6.2.1.1.</span> <span class="toc-text">InputStream流类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OutputStream%E6%B5%81%E7%B1%BB"><span class="toc-number">6.2.1.2.</span> <span class="toc-text">OutputStream流类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">6.2.2.</span> <span class="toc-text">输入输出流的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">6.2.2.1.</span> <span class="toc-text">文件输入输出流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%BE%93%E5%85%A5%E6%B5%81"><span class="toc-number">6.2.2.2.</span> <span class="toc-text">顺序输入流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">6.2.2.3.</span> <span class="toc-text">管道输入输出流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">6.2.2.4.</span> <span class="toc-text">过滤输入输出流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">6.2.2.5.</span> <span class="toc-text">标准输入输出流</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Reader%E5%92%8CWriter%E6%B5%81%E7%B1%BB"><span class="toc-number">6.3.</span> <span class="toc-text">使用Reader和Writer流类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8FileReader%E7%B1%BB%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6"><span class="toc-number">6.3.1.</span> <span class="toc-text">使用FileReader类读取文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8FileWriter%E7%B1%BB%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6"><span class="toc-number">6.3.2.</span> <span class="toc-text">使用FileWriter类写入文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8BufferedReader%E7%B1%BB%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6"><span class="toc-number">6.3.3.</span> <span class="toc-text">使用BufferedReader类读取文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8BufferedWriter%E7%B1%BB%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6"><span class="toc-number">6.3.4.</span> <span class="toc-text">使用BufferedWriter类写入文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E7%AE%A1%E7%90%86%E4%B8%8E%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE"><span class="toc-number">6.4.</span> <span class="toc-text">文件的管理与随机访问</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E8%AF%AD%E8%A8%80%E5%AF%B9%E6%96%87%E4%BB%B6%E4%B8%8E%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E7%AE%A1%E7%90%86"><span class="toc-number">6.4.1.</span> <span class="toc-text">Java语言对文件与文件夹的管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAFile%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.4.1.1.</span> <span class="toc-text">创建File类的对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E6%88%96%E6%96%87%E4%BB%B6%E5%A4%B9%E5%B1%9E%E6%80%A7"><span class="toc-number">6.4.1.2.</span> <span class="toc-text">获取文件或文件夹属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%88%96%E6%96%87%E4%BB%B6%E5%A4%B9%E6%93%8D%E4%BD%9C"><span class="toc-number">6.4.1.3.</span> <span class="toc-text">文件或文件夹操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%96%87%E4%BB%B6%E7%9A%84%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE"><span class="toc-number">6.4.2.</span> <span class="toc-text">对文件的随机访问</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E7%AB%A0%E5%B0%8F%E7%BB%93-4"><span class="toc-number">6.5.</span> <span class="toc-text">本章小结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98-4"><span class="toc-number">6.6.</span> <span class="toc-text">课后习题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">7.</span> <span class="toc-text">第十一章 多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">7.1.</span> <span class="toc-text">线程的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E3%80%81%E8%BF%9B%E7%A8%8B%E3%80%81%E5%A4%9A%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">7.1.1.</span> <span class="toc-text">程序、进程、多任务与多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F-program"><span class="toc-number">7.1.1.1.</span> <span class="toc-text">程序-program</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B-porcess"><span class="toc-number">7.1.1.2.</span> <span class="toc-text">进程-porcess</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E4%BB%BB%E5%8A%A1-multi-task"><span class="toc-number">7.1.1.3.</span> <span class="toc-text">多任务-multi task</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B-thread"><span class="toc-number">7.1.1.4.</span> <span class="toc-text">多线程-thread</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">7.1.2.</span> <span class="toc-text">线程的状态与生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E5%BB%BA%E7%8A%B6%E6%80%81-newbron"><span class="toc-number">7.1.2.1.</span> <span class="toc-text">新建状态-newbron</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%B1%E7%BB%AA%E7%8A%B6%E6%80%81-runnable"><span class="toc-number">7.1.2.2.</span> <span class="toc-text">就绪状态-runnable</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E7%8A%B6%E6%80%81-running"><span class="toc-number">7.1.2.3.</span> <span class="toc-text">执行状态-running</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E7%8A%B6%E6%80%81-blocked"><span class="toc-number">7.1.2.4.</span> <span class="toc-text">阻塞状态-blocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E4%BA%A1%E7%8A%B6%E6%80%81-dead"><span class="toc-number">7.1.2.5.</span> <span class="toc-text">消亡状态-dead</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E4%B8%8E%E8%B0%83%E5%BA%A6"><span class="toc-number">7.1.3.</span> <span class="toc-text">线程的优先级与调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">7.1.3.1.</span> <span class="toc-text">优先级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6"><span class="toc-number">7.1.3.2.</span> <span class="toc-text">调度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E7%9A%84Thread%E7%BA%BF%E7%A8%8B%E7%B1%BB%E4%B8%8ERunnable%E6%8E%A5%E5%8F%A3"><span class="toc-number">7.2.</span> <span class="toc-text">Java的Thread线程类与Runnable接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8Thread%E7%B1%BB%E7%9A%84%E5%AD%90%E7%B1%BB%E6%9D%A5%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">7.2.1.</span> <span class="toc-text">利用Thread类的子类来创建线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8Runnable%E6%8E%A5%E5%8F%A3%E6%9D%A5%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">7.2.2.</span> <span class="toc-text">用Runnable接口来创建线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB"><span class="toc-number">7.2.3.</span> <span class="toc-text">线程间的数据共享</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E6%8E%A7%E5%88%B6"><span class="toc-number">7.3.</span> <span class="toc-text">多线程的同步控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-number">7.4.</span> <span class="toc-text">线程之间的通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E7%AB%A0%E5%B0%8F%E7%BB%93-5"><span class="toc-number">7.5.</span> <span class="toc-text">本章小结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98-5"><span class="toc-number">7.6.</span> <span class="toc-text">课后习题</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/Avatar.png"></div><div class="author-info__name text-center">HibisciDai</div><div class="author-info__description text-center">HibisciDai'Blog</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">204</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">73</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">29</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友情链接</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://github.com/HibisciDai/hexo-theme-melody">HexoTheme-github</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://molunerfinn.com/">molunerfinn</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/img/banner2.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">HibisciDai</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/about">关于我</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/gallery">相册</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">JAVA程序设计基础-第6版陈国君2006-学习笔记2</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-12-25</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">32.2k</span><span class="post-meta__separator">|</span><span>阅读时长: 107 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><img src="/2021/12/25/JAVA%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80-%E7%AC%AC6%E7%89%88%E9%99%88%E5%9B%BD%E5%90%9B2006-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/JAVA%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80-%E7%AC%AC6%E7%89%88%E9%99%88%E5%9B%BD%E5%90%9B2006-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02.png" class="" title="JAVA程序设计基础-第6版陈国君2006-学习笔记2">
<p>JAVA程序设计基础-第6版陈国君2006-学习笔记2</p>
<span id="more"></span>
<p>[TOC]</p>
<h1 id="JAVA程序设计基础-第6版陈国君2006-学习笔记2"><a href="#JAVA程序设计基础-第6版陈国君2006-学习笔记2" class="headerlink" title="JAVA程序设计基础-第6版陈国君2006-学习笔记2"></a>JAVA程序设计基础-第6版陈国君2006-学习笔记2</h1><h1 id="第六章-类与对象"><a href="#第六章-类与对象" class="headerlink" title="第六章 类与对象"></a>第六章 类与对象</h1><p>面向对象的编程思想是力图使在计算机语言中对事物的描述与现实世界中该事物的本来面目尽可能地一致。</p>
<h2 id="类的基本概念"><a href="#类的基本概念" class="headerlink" title="类的基本概念"></a>类的基本概念</h2><p><code>类</code>是对某一类事物的描述，是抽象的、概念上的定义。<br><code>对象</code>是实际存在的属该类事物的具体个体，因而也成为实例（instance）。</p>
<p>数据成员：data member<br>域：field<br>函数成员：function member<br>方法：method<br>函数：function<br>面向对象程序设计：Object Oriented Programming,OOP<br>封装：encapsulate</p>
<blockquote>
<p>数据成员称为域变量、属性、成员变量。<br>函数成员称为成员方法、方法。</p>
</blockquote>
<h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><p>类是将数据和方法封装在一起的一种数据结构，数据表示类的属性，方法表示类的行为，定义类实际上是定义类的属性与方法。</p>
<h3 id="类的一般结构"><a href="#类的一般结构" class="headerlink" title="类的一般结构"></a>类的一般结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[类修饰符] class 类名称 &#123;	</span><br><span class="line">	[修饰符] 数据类型 成员变量名称;	<span class="comment">//声明成员变量</span></span><br><span class="line">	</span><br><span class="line">	[修饰符] 返回值的数据类型 方法名(参数<span class="number">1</span>, 参数<span class="number">2</span>, ... , 参数n) &#123;	<span class="comment">//声明成员方法</span></span><br><span class="line">		语句序列;</span><br><span class="line">		<span class="keyword">return</span> [表达式];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类修饰符分为公共访问控制符、抽象类说明符、最终类说明符合缺省访问控制符。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类修饰符</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public</td>
<td style="text-align:center">将一个类声明为公众类，可以被任何对象访问</td>
</tr>
<tr>
<td style="text-align:center">abstract</td>
<td style="text-align:center">将一个类声明为抽象类，没有实现方法，需要子类提供方法的实现，所以不能创建该类的实例</td>
</tr>
<tr>
<td style="text-align:center">final</td>
<td style="text-align:center">将一个类声明为最终类即非继承类，表示它不能被其他类所继承</td>
</tr>
<tr>
<td style="text-align:center">缺省</td>
<td style="text-align:center">缺省修饰符时，则表示只有在相同包中的对象才能使用这样的类</td>
</tr>
</tbody>
</table>
</div>
<h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] 变量类型 变量名[ = 初值];</span><br></pre></td></tr></table></figure>
<p>成员变量的修饰符有访问控制符、静态修饰符、最新修饰符、过渡修饰符和易失修饰符</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">成员变量修饰符</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public</td>
<td style="text-align:center">公众访问控制符。指定该变量为公共的，它可以被任何对象的方法访问</td>
</tr>
<tr>
<td style="text-align:center">private</td>
<td style="text-align:center">私有访问控制符。指定该变量只允许自己类的方法访问，其他任何类(包括子类)中的方法均不能访问此变量</td>
</tr>
<tr>
<td style="text-align:center">protected</td>
<td style="text-align:center">保护访问控制符。指定该变量只可以被它自己的类及其子类或同一包中的其他类访问，在子类中可以覆盖此变量</td>
</tr>
<tr>
<td style="text-align:center">缺省</td>
<td style="text-align:center">缺省访问控制符时，则表示在同一个包中的类可以访问此成员变量，而其他包中的类不能访问该成员变量</td>
</tr>
<tr>
<td style="text-align:center">final</td>
<td style="text-align:center">最终修饰符。指定此变量的值不能改变</td>
</tr>
<tr>
<td style="text-align:center">static</td>
<td style="text-align:center">静态修饰符。指定该变量被所有对象共享，即所有的实例都可使用该变量</td>
</tr>
<tr>
<td style="text-align:center">transient</td>
<td style="text-align:center">过渡修饰符。指定该变量是一个系统保留、暂无特别作用的临时变量</td>
</tr>
<tr>
<td style="text-align:center">volatile</td>
<td style="text-align:center">易失修饰符。指定该变量可以同时被几个线程控制和修改</td>
</tr>
</tbody>
</table>
</div>
<h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] 返回值的数据类型 方法名(参数<span class="number">1</span>, 参数<span class="number">2</span>, ..., 参数n) &#123;</span><br><span class="line">	语句序列;	<span class="comment">//方法的主体</span></span><br><span class="line">	<span class="keyword">return</span> [表达式];	<span class="comment">//方法的主体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法定义修饰符是可选项。<br>方法修饰符较多，包括访问控制符、静态修饰符、抽象修饰符、最终修饰符、同步修饰符和本地修饰符。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">成员方法修饰符</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public</td>
<td style="text-align:center">公共访问控制符。指定该方法为公共的，他可以被任何对象的方法访问</td>
</tr>
<tr>
<td style="text-align:center">private</td>
<td style="text-align:center">私有访问控制符。指定该方法只允许自己类的方法访问，其他任何类(包括子类)中的方法均不能访问此方法</td>
</tr>
<tr>
<td style="text-align:center">protected</td>
<td style="text-align:center">保护访问控制符。指定该方法只可以被它的类及其子类或同一包中的其他类访问</td>
</tr>
<tr>
<td style="text-align:center">缺省</td>
<td style="text-align:center">缺省访问控制符时，则表示在同一个包中的类可以访问此成员方法，而其他包中的类不能访问该成员方法</td>
</tr>
<tr>
<td style="text-align:center">final</td>
<td style="text-align:center">最终修饰符。指定该方法不能被覆盖</td>
</tr>
<tr>
<td style="text-align:center">static</td>
<td style="text-align:center">静态修饰符。指定不需要实例化一个对象就可以调用的方法</td>
</tr>
<tr>
<td style="text-align:center">abstract</td>
<td style="text-align:center">抽象修饰符。指定该方法只声明方法头，而没有方法体，抽象方法需在子类中被实现</td>
</tr>
<tr>
<td style="text-align:center">synchronized</td>
<td style="text-align:center">同步修饰符。在多线程程序中，该修饰符用于对同步资源加锁，以防止其他线程访问，运行结束后解锁</td>
</tr>
<tr>
<td style="text-align:center">native</td>
<td style="text-align:center">本地修饰符。指定此方法的方法体是用其他语言(如C语言)在程序外部编写的</td>
</tr>
</tbody>
</table>
</div>
<h3 id="成员变量与局部变量的区别"><a href="#成员变量与局部变量的区别" class="headerlink" title="成员变量与局部变量的区别"></a>成员变量与局部变量的区别</h3><p>类中定义的变量是成员变量，二方法中定义的变量是局部变量。</p>
<ul>
<li>从语法形式上看，成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被 public、private、static 等修饰符所修饰，而局部变量则不能被访问控制修饰符及 static 所修饰；成员变量和局部变量都可以被 final 所修饰。</li>
<li>从变量在内存中的存储方式上看，成员变量是对象的一部分，而对象是存在于堆内存的，而局部变量是存在于栈内存的。</li>
<li>从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而产生，随着方法调用的结束而自动消失。</li>
<li>成员变量如果没有被赋初值，则会自动以类型的默认值赋值（有一种情况例外，被final 修饰但没有被static修饰的成员变量必须显式地赋值)；而局部变量则不会自动赋值，必须显式地赋值后才能使用。</li>
</ul>
<h2 id="对象的创建与使用"><a href="#对象的创建与使用" class="headerlink" title="对象的创建与使用"></a>对象的创建与使用</h2><p>对象的声明周期：创建 -&gt; 使用 -&gt; 销毁</p>
<h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cylinder volu;</span><br><span class="line">volu = <span class="keyword">new</span> <span class="title class_">Cylinder</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">Cylinder</span> <span class="variable">volu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cylinder</span>();</span><br></pre></td></tr></table></figure>
<p>一个方法内部的变量必须进行初始化，否则编译无法通过。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">成员变量的类型</th>
<th style="text-align:center">初始值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">byte</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">short</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">long</td>
<td style="text-align:center">0L</td>
</tr>
<tr>
<td style="text-align:center">flaot</td>
<td style="text-align:center">0.0F</td>
</tr>
<tr>
<td style="text-align:center">double</td>
<td style="text-align:center">0.0D</td>
</tr>
<tr>
<td style="text-align:center">char</td>
<td style="text-align:center">\u0000 (表示为空)</td>
</tr>
<tr>
<td style="text-align:center">boolean</td>
<td style="text-align:center">false</td>
</tr>
<tr>
<td style="text-align:center">所有引用类型</td>
<td style="text-align:center">null</td>
</tr>
</tbody>
</table>
</div>
<h3 id="对象的使用"><a href="#对象的使用" class="headerlink" title="对象的使用"></a>对象的使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象名.对象成员</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果Java程序中有多个类，经编译之后便会产生与类相等数目的.class文件。</p>
</blockquote>
<p>如果再类声明的内部使用这些成员，则可直接使用成员名称，而不需要调用对象名称。</p>
<h3 id="在类定义内调用方法"><a href="#在类定义内调用方法" class="headerlink" title="在类定义内调用方法"></a>在类定义内调用方法</h3><p>类定义的内部方法与方法之间也可以相互调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.成员名</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">volume</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">this</span>.area() * <span class="built_in">this</span>.height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参数的传递"><a href="#参数的传递" class="headerlink" title="参数的传递"></a>参数的传递</h2><h3 id="以变量为参数调用方法"><a href="#以变量为参数调用方法" class="headerlink" title="以变量为参数调用方法"></a>以变量为参数调用方法</h3><p>调用方法传参放在括号中，可以使数值型、字符串型、引用类型。</p>
<h3 id="以数组作为参数或返回值的方法调用"><a href="#以数组作为参数或返回值的方法调用" class="headerlink" title="以数组作为参数或返回值的方法调用"></a>以数组作为参数或返回值的方法调用</h3><blockquote>
<p>基本数据类型传递的是该数据的值本身；引用数据类型传递的是独享的引用变量。</p>
</blockquote>
<h3 id="方法中的可变参数"><a href="#方法中的可变参数" class="headerlink" title="方法中的可变参数"></a>方法中的可变参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 方法名 (固定参数列表, 数据类型 ... 可变参数名) &#123;</span><br><span class="line">	方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果方法中有多个参数，可变参数必须位于最后一项，及可变参数只能出现在参数列表的最后。<br>可变参数符号”…“要位于数据类型和数组名之间，其前后有无空格都可以。<br>调用可变参数的方法时，编译器为该可变参数隐含创建一个数组，在方法体中以数组的形式访问可变参数。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">APP6_7</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(<span class="type">int</span> x, String ... arg)</span> &#123;</span><br><span class="line">		System.out.print(x + <span class="string">&quot; &quot;</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;arg.length; i++) &#123;</span><br><span class="line">			System.out.print(arg[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		display(<span class="number">5</span>);</span><br><span class="line">		display(<span class="number">6</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>);</span><br><span class="line">		display(<span class="number">7</span>, <span class="string">&quot;AA&quot;</span>, <span class="string">&quot;BB&quot;</span>, <span class="string">&quot;CC&quot;</span>, <span class="string">&quot;DD&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//程序运行结果</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span> a b</span><br><span class="line"><span class="number">7</span> AA BB CC DD</span><br></pre></td></tr></table></figure>
<h2 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h2><p>当一个对象被创建之后，在调用改对象的方法时，也可以不定义对象的引用变量，而直接调用这个对象的方法，这样的对象成为匿名对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Cylinder</span> <span class="variable">volu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cylinder</span>();</span><br><span class="line">volu.setCylinder(<span class="number">2.5</span>, <span class="number">5</span>, <span class="number">3.14</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Cylinder</span>().setCylinder(<span class="number">2.5</span>, <span class="number">5</span>, <span class="number">3.14</span>);</span><br><span class="line"><span class="comment">//方法执行完成后，该对象成为垃圾被回收</span></span><br></pre></td></tr></table></figure>
<p>匿名对象使用情况：</p>
<ol>
<li>如果对一个对象只需要进行一次方法调用，那么就可以使用匿名对象。</li>
<li>将匿名对象作为实参传递给一个方法调用。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">publci <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getSomeOne</span><span class="params">(MyClass c)</span> &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getSomeOne(<span class="keyword">new</span> <span class="title class_">MyClass</span>());</span><br></pre></td></tr></table></figure>
<h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><ul>
<li>类是把事物的数据与相关的功能封装在一起，形成的一种特殊结构，用以表达现实世界的一种抽象概念。</li>
<li>同一个Java 程序内，若定义了多个类，则最多只能有一个类声明为 public，在这种情况下，文件名称必须与声明成 public 的类名称相同。</li>
<li>Java 语言把数据成员称为成员变量，把函数成员称为成员方法，成员方法简称为方法。</li>
<li>封装是指把变量和方法包装在一个类内，以限定成员的访问，从而达到保护数据的一种技术。</li>
<li>由类所创建的对象称为实例。</li>
<li>创建属于某类的对象，可以通过下面两个步骤来完成：①声明指向”由类所创建的对象”的变量；②利用 new 运算符创建新的对象，并用步骤①所创建的变量来指向它。</li>
<li>要访问对象里的某个成员变量时,可以通过”对象名.成员变量名”的形式来达到；若要调用封装在类内的方法时,则可以使用“对象名.方法名(）”的语法形式来完成。</li>
<li>如果要强调”对象本身的成员”，可以在成员名前加上”this”关键宇。即”this. 成员名”，此时的 this 即代表调用该成员的对象。</li>
<li>若方法本身没有返回值，则必须在方法定义的前面加上关键宇 void。</li>
<li>在类外部可访问到类内部的公共成员。</li>
<li>方法的参数可以是任意类型的数据，其返回值也可是任意类型。</li>
<li>具有可变参数的方法所接收参数的个数可以不是固定的，而是根据需要传递参数的个数。方法中接收不固定个数的参数称为可变参数。其”可变参数名”就是接收可变实参的数组名，数组的长度由可变实参的个数决定。</li>
<li>当一个对象被创建之后，在调用该对象的方法时，不定义对象的引用变量，而直接调用这个对象的方法，这样的对象称为匿名对象。</li>
</ul>
<h2 id="课后习题"><a href="#课后习题" class="headerlink" title="课后习题"></a>课后习题</h2><ul>
<li>类与对象的区别是什么？</li>
<li>如何定义一个类？类的结构是怎样的？</li>
<li>定义一个类时所使用的修饰符有哪几个？每个修饰符的作用是什么？是否可以混用？</li>
<li>成员变量的修饰符有哪些？各修饰符的功能是什么？是否可以混用？</li>
<li>成员方法的修饰符有哪些？各修饰符的功能是什么？是否可以混用？</li>
<li>成员变量与局部变量的区别有哪些？</li>
<li>创建一个对象使用什么运算符？对象实体与对象引用有何不同？</li>
<li>对象的成员如何表示？</li>
<li>在成员变量或成员方法前加上关键宇this 表示什么含义？</li>
<li>什么是方法的返回值？返回值在类的方法里的作用是什么？</li>
<li>在方法调用中，使用对象作为参数进行传递时，是”传值”还是”传址”？对象作参数起到什么作用？</li>
<li>什么叫匿名对象？一般在什么情况下使用匿名对象？</li>
<li>以m行n列二维数组为参数进行方法调用，分别计算二维数组各列元素之和，返回并输出所计算的结果。</li>
</ul>
<h1 id="第七章-Java语言类的特性"><a href="#第七章-Java语言类的特性" class="headerlink" title="第七章 Java语言类的特性"></a>第七章 Java语言类的特性</h1><h2 id="类的私有成员与公共成员"><a href="#类的私有成员与公共成员" class="headerlink" title="类的私有成员与公共成员"></a>类的私有成员与公共成员</h2><h3 id="私有成员"><a href="#私有成员" class="headerlink" title="私有成员"></a>私有成员</h3><p>在类的成员声明前面加上修饰符private，就无法从类的外部访问到类的内部成员，只能被该类自身访问和修改，不能被任何其他类（包括该类的子类）获取或引用，</p>
<h3 id="公共成员"><a href="#公共成员" class="headerlink" title="公共成员"></a>公共成员</h3><p>在类的成员声明前面加上修饰符public，则表示该成员你可以被所有其他的类所访问。</p>
<h3 id="缺省访问控制符"><a href="#缺省访问控制符" class="headerlink" title="缺省访问控制符"></a>缺省访问控制符</h3><p>若在类成员的前面不加任何访问控制符，则该成员具有缺省的访问控制特性，该成员只能被同一个包（类库）中的类所访问和调用，如果一个子类与父类位于不同的包中，子类也不能访问父类中的缺省访问控制成员，其他包中任何类都不能缺省访问控制成员。</p>
<p>如果一个类没有访问控制符，只能被同一个包中的类访问和引用，而不可以被其他包中的类所使用。</p>
<h2 id="方法的重载-overloading"><a href="#方法的重载-overloading" class="headerlink" title="方法的重载(overloading)"></a>方法的重载(overloading)</h2><p>同一个类内具有相同名称的多个方法，这多个同名方法如果参数个数不同，或者是参数个数相同但类型不同，或参数的顺序不同则这些同名的方法就具有不同的功能。</p>
<blockquote>
<p>Java不允许参数个数或参数类型完全相同，而只有返回值类型不同的重载。</p>
</blockquote>
<h2 id="构造方法-constructor"><a href="#构造方法-constructor" class="headerlink" title="构造方法(constructor)"></a>构造方法(constructor)</h2><h3 id="构造方法的作用与定义"><a href="#构造方法的作用与定义" class="headerlink" title="构造方法的作用与定义"></a>构造方法的作用与定义</h3><ul>
<li>构造方法是在对象被创建时初始化对象成员的方法。</li>
<li>名称必须要与它所在的类名完全相同。</li>
<li>构造方法没有返回值。不能用void来修饰。</li>
<li>创建对象时会自动调用它。</li>
<li>不能被显式直接调用，而是用new来调用。</li>
<li>创建一个类的对象的同时，会自动调用该类的构造方法为新对象初始化。</li>
</ul>
<h3 id="默认的构造方法"><a href="#默认的构造方法" class="headerlink" title="默认的构造方法"></a>默认的构造方法</h3><p>如果省略构造方法，Java编译器会自动为该类生成一个默认的构造方法（default constructor），一旦用户为该类定义了构造方法，系统就不再提供默认的构造方法。</p>
<h3 id="构造方法的重载"><a href="#构造方法的重载" class="headerlink" title="构造方法的重载"></a>构造方法的重载</h3><p>当一个类有多个构造方法时，这多个构造反方可以重载。</p>
<h3 id="从一个构造方法内调用另一个构造方法"><a href="#从一个构造方法内调用另一个构造方法" class="headerlink" title="从一个构造方法内调用另一个构造方法"></a>从一个构造方法内调用另一个构造方法</h3><ul>
<li>在一个构造方法内调用另一个构造方法时，必须使用 <code>this()</code> 语句来调用，否则编译时将出现错误。</li>
<li><code>this()</code> 语句必须写在构造方法内的第一行位置。</li>
</ul>
<h3 id="公共的构造方法与私有的构造方法"><a href="#公共的构造方法与私有的构造方法" class="headerlink" title="公共的构造方法与私有的构造方法"></a>公共的构造方法与私有的构造方法</h3><p>构造方法一般为公共的，因为在创建对象时，是在类的外部被自动调用。</p>
<p>如果构造方法被声明为private，则无法在该构造方法所在的类以外的地方调用，但在该类的内部还是可以被调用的。</p>
<h2 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h2><p>被 static 修饰的成员称为静态成员，也称为类成员，而不用 static 修饰的成员称为实例成员。</p>
<h3 id="实例成员"><a href="#实例成员" class="headerlink" title="实例成员"></a>实例成员</h3><p>没有被static修饰的成员。</p>
<h3 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h3><p>被static修饰的成员变量，也称为 类变量。</p>
<p>静态变量是属于类的变量而不是属于任何一个类的具体对象。</p>
<p>静态变量是一个公共的存储单元，不是保存在某个对象实例的内存空间，而是保存在类的内存空间的公共存储单元中。</p>
<p>类的任何一个对象访问它，取到的都是一个相同的数值。<br>类的任何一个对象去修改它，都是在对同一个内存单元做操作。</p>
<p>静态变量不需要实例化就可以使用。也可以通过对象来访问静态变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类名.静态变量名;	<span class="comment">//建议访问方式</span></span><br><span class="line">对象名.静态变量名;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>静态变量必须独立于方法之外，必须在函数外声明。<br>可以节省内存。</p>
</blockquote>
<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>用static修饰符修饰的方法。</p>
<ul>
<li>非static的方法是属于某个对象的方法，在创建这个对象时，对象的方法在内存中拥有属于自己专用的代码段。而static 的方法是属于整个类的，它在内存中的代码段将被所有的对象所共用，而不被任何一个对象所专用。</li>
<li>由于static 方法是属于整个类的，所以它不能直接操纵和处理属于某个对象的成员，而只能处理属于整个类的成员，即 static 方法只能访问 static 成员变量或调用 static 成员方法，或者说在静态方法中不能直接访问实例变量与实例方法。静态方法中虽不能直接访问非静态的成员，但可以通过创建对象的方法间接地访问非静态成员。</li>
<li>在静态方法中不能使用 this 或super。</li>
<li>调用静态方法时，可以使用类名直接调用，也可以用某一个具体的对象名来调用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类名.静态方法名();</span><br><span class="line">对象名.静态方法名();</span><br></pre></td></tr></table></figure>
<p>静态方法可以在不产生对象的情况下直接以类名来调用。</p>
<blockquote>
<p>main程序入口方法的理解：由于 Java 虚拟机需要在类外调用main()方法，所以该方法的访问权限必领是public；又因为 Java 虚拟机运行时系统在开始执行一个程序前，并没有创建main()方法所在类的一个实例对象，所以它只能通过类名来调用 main()方法作为程序的人口，即调用main()方法的是类名，而不是由类所创建的对象，因而该方法必须是static 的。</p>
</blockquote>
<h3 id="静态初始化器"><a href="#静态初始化器" class="headerlink" title="静态初始化器"></a>静态初始化器</h3><p>关键字static修饰的一对花括号”{}”括起来的语句组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;	<span class="comment">//类初始化器</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用于初始化工作。</p>
<ul>
<li>构造方法是对每个新创建的对象进行初始化，而静态初始化器是对类自身进行初始化。</li>
<li>构造方法是在用new运算符创建新对象时由系统自动执行，而静态初始化器一般不能由程序调用，它是在所属的类被加载入内存时由系统调用执行的。</li>
<li>用new运算符创建多少个新对象，构造方法就被调用多少次，但静态初始化器则在类被加载入内存时只执行一次，与创建多少个对象无关。</li>
<li>不同于构造方法，静态初始化器不是方法，因而没有方法名、返回值和参数。</li>
</ul>
<blockquote>
<p>多个静态初始化器，则在类的初始化时会依次执行。</p>
</blockquote>
<h2 id="对象的应用"><a href="#对象的应用" class="headerlink" title="对象的应用"></a>对象的应用</h2><h3 id="对象的赋值与比较"><a href="#对象的赋值与比较" class="headerlink" title="对象的赋值与比较"></a>对象的赋值与比较</h3><p>当参数是基本数据类型时，是传值方式调用，而当参数是引用变量时，则是传址方式调用。</p>
<p><code>==</code> 比较的是对象的引用地址是否相同。</p>
<h3 id="引用变量作为方法的返回值"><a href="#引用变量作为方法的返回值" class="headerlink" title="引用变量作为方法的返回值"></a>引用变量作为方法的返回值</h3><h3 id="类类型的数组"><a href="#类类型的数组" class="headerlink" title="类类型的数组"></a>类类型的数组</h3><ul>
<li>声明类类型的数组变量，并用new运算符分配内存空间给数组；</li>
<li>用new创建新的对象，分配内存空间给它，并让数组元素指向它。</li>
</ul>
<h3 id="以对象数组为参数进行方法调用"><a href="#以对象数组为参数进行方法调用" class="headerlink" title="以对象数组为参数进行方法调用"></a>以对象数组为参数进行方法调用</h3><h2 id="Java语言的垃圾回收"><a href="#Java语言的垃圾回收" class="headerlink" title="Java语言的垃圾回收"></a>Java语言的垃圾回收</h2><p>在Java 程序的生命周期中，Java 运行环境提供丁一个系统的垃圾回收器线程，负责自动回收那些没有被引用的对象所占用的内存，这种清除无用对象进行内存回收的过程就叫作垃圾回收(garbase-collection）。垃圾回收是Java 语言提供的一种自动内存回收功能，可以让程序员减轻许多内存管理的负担，也减少程序员犯错的机会。<br>一个对象被创建时。JVM 会为该对象分配一定的内存、调用该对象的构造方法并开始跟踪该对象。当该对象停止使用时，JVM 将通过垃圾回收器回收该对象所占用的内存。<br>那么Java 是如何知道一个对象是无用的呢？这是因为系统中的任何对象都有一个引用计数器，一个对象被引用1次，则该对象的引用计数器为 1,被引用2次，则引用计数器为 2相反，若对一个对象减少1 次引用，则该对象的引用计数器就诚 1，依次类推，当一个对象的引用计数器诚到0时，说明该对象可以回收。</p>
<h3 id="垃圾回收的两个好处"><a href="#垃圾回收的两个好处" class="headerlink" title="垃圾回收的两个好处"></a>垃圾回收的两个好处</h3><ul>
<li>（1）把程序员从复杂的内存追踪、监测、释放等工作中解放出来。</li>
<li>（2）防止了系统内存被非法释放，从而使系统更加稳定。</li>
</ul>
<h3 id="垃圾回收的三个特点"><a href="#垃圾回收的三个特点" class="headerlink" title="垃圾回收的三个特点"></a>垃圾回收的三个特点</h3><ul>
<li>（1）只有当一个对象不被任何引用类型的变量使用时，它占用的内存才可能被垃圾回<br>收器回收。</li>
</ul>
<p>如下面的程序段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">strl</span> <span class="operator">=</span> <span class="string">&quot;This is a string&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> strl;</span><br><span class="line">str2 = <span class="keyword">new</span> <span class="title class_">String</span> (<span class="string">&quot;This is another string&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>当程序执行到第 3行时，”This is a string”对象仍然被str2 引用，因此，此时不能被垃圾回收器回收。当程序执行完第4行，str2引用了一个新的字符串对象，此时”This is string”对象不在被任何引用类型的变量(str1 和 str2)引用，因此，此时该对象可以被当作垃圾回收。</p>
<ul>
<li>（2）不能通过程序强迫垃圾回收器立即执行。</li>
</ul>
<p>垃圾回收器负责释放没有引用与之关联的对象所占用的内存，但是回收的时间对程序员是透明的，在任何时候，程序员都不能通过程序强迫垃圾回收器立即执行，但可以通过调用<code>System.gc()</code>或者<code>Runtime.sc()</code>方法提示垃圾回器进行内存回收操作，不过这也不能保证调用该方法后，垃圾回收器立即执行。</p>
<ul>
<li>（3）当拉圾回收器将要释放无用对象占用的内存时，先调用该对象的 finalize()方法。</li>
</ul>
<p>在Java 语言中对象的回收是由系统进行的，但有一些任务需要在回收时进行，如清理一些非内存资源、关闭打开的文件等。这可通过覆盖对象中的<code>finalize()</code>方法来实现，因为系统在回收时会自动调用对象的<code>finalize()</code>方法。</p>
<p><code>finalize()</code>方法的形式如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">Finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span><br></pre></td></tr></table></figure></p>
<p>由于只有当拉圾回收器将要释放该对象的内存时，才会执行该对象的<code>finalize()</code>方法，如果在小程序或应用程序退出之前，垃圾回收器始终没有执行释放内存的操作，那么垃圾回收器将不会调用无用对象的 finalize()方法。换句话说，以下情况是完全可能的：一个小程序或应用程序只占用了少量的内存，没有造成严重的内存需求，于是垃圾回收器没有释放这些对象的内存就退出了。显然，如果程序员为某个对象定义了 finalize()方法，JVM 可能不会调用它，因为垃圾回收器不曾释放过这个对象的内存，调用 System.gc(）也不会起作用，因为它仅仅是给JVM一个建议而不是命令。当一个对象将要退出生命周期时，可以通过finalize()方法来释放对象所占的其他相关资源，但是，JVM有很大的可能不调用对象的finalize()方法，因此很难保证使用该方法来释放资源是安全有效的。</p>
<h2 id="本章小结-1"><a href="#本章小结-1" class="headerlink" title="本章小结"></a>本章小结</h2><ul>
<li>用修饰符 private 修饰的类成员称为类的私有成员(private member)。私有成员无法从该类的外部访问到，而只能被该类自身访问和修改，而不能被任何其他类(包括该类的子类)获取或引用；如果在类的成员声明的前面加上修饰符public，则该成员为公共成员，表示该成员可以被所有其他的类所访问。</li>
<li>所谓重载是指在同一个类内定义相同名称的多个方法。这些同名的方法或者参数的个数不同或者参数的个数相同但类型不同,这些同名的方法便可以具有不同的功能。</li>
<li>构造方法可视为一种特殊的方法，它的主要功能是帮助创建的对象赋初值。</li>
<li>构造方法的名称必须与其所属的类名称相同，且不能有返回值。</li>
<li>从某一构造方法内调用另一构造方法，必须通过 this()语句来调用。</li>
<li>构造方法有公共(public) 与私有 (private)之分，公共构造方法可以在程序的任何地方被调用，所以新创建的对象均可自动调用它，而私有构造方法则无法在该构造方法所在的类以外的地方被调用。</li>
<li>如果一个类没有定义构造方法，则 Java 编译系统会自动为其生成默认的构造方法。默认的构造方法是没有任何参数，方法体内也没有任何语句的构造方法。</li>
<li>实例变量与实例方法、静态变量与静态方法是不同的成员变量与成员方法。</li>
<li>基本类型的变量是指由 int.double 等关键字所声明而得到的变量，而由类声明而得到的变量称为类类型的变量，它是属于引用类型变量的一种。</li>
<li>对象也可以用数组来存放，但必须有下面两个步骤：①声明类类型的数组变量，并用new 运算符分配内存空间给数组；②用new 运算符产生新的对象，并分配内存空间给它，并让数组元素指向它。</li>
<li>Java 语言具有垃圾自动回收的功能。</li>
</ul>
<h2 id="课后习题-1"><a href="#课后习题-1" class="headerlink" title="课后习题"></a>课后习题</h2><ul>
<li>一个类的公共成员与私有成员有何区别？</li>
<li>什么是方法的重载？</li>
<li>一个类的构造方法的作用足什么？若一个类没有声明构造方法。该程序能正殖执行吗？为什么？</li>
<li>构造方法有哪些特性？</li>
<li>在在一个构造方法内可以调用另一个构造方法吗？如果可以，如何调用？</li>
<li>静态变量与实例变量有哪些不同？</li>
<li>静态方法与实例方法有哪些不同？</li>
<li>在一个静态方法内调用一个非静态成员为什么是非法的？</li>
<li>对象的相等与指向它们的引用相等有什么不同？</li>
<li>什么是静态初始化器？其作用是什么？静态初始化器由谁在何时执行？它与构造方法有何不同？</li>
<li>Java语言中怎样清除没有被引用的对象？能否控制 Java 系统中垃圾的回收时间？</li>
</ul>
<h1 id="第八章-继承、抽象类、接口和枚举"><a href="#第八章-继承、抽象类、接口和枚举" class="headerlink" title="第八章 继承、抽象类、接口和枚举"></a>第八章 继承、抽象类、接口和枚举</h1><p>类的继承是使用已有的类作为基础派生出新的类。<br>抽象类与接口都是类概念的扩展</p>
<h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><p>父类/超类(superclass)：被继承的类；<br>子类(subclass)：由继承而得到的类。</p>
<blockquote>
<p>一个类只能有一个直接父类。所有类都是直接或间接继承该类</p>
</blockquote>
<h3 id="子类的创建"><a href="#子类的创建" class="headerlink" title="子类的创建"></a>子类的创建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SubClass</span> <span class="keyword">extends</span> <span class="title class_">SpuerClass</span> &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类每个对象也是其父类的对象，任何可以使用父类实例的地方，都可以使用子类实例。</p>
<h4 id="子类的构建方法"><a href="#子类的构建方法" class="headerlink" title="子类的构建方法"></a>子类的构建方法</h4><p>执行子类的构造方法之前会先调用父类中没有参数的构造方法。</p>
<p>extends关键字可将父类中的非私有成员继承给子类。</p>
<h4 id="调用父类中特定的构造方法"><a href="#调用父类中特定的构造方法" class="headerlink" title="调用父类中特定的构造方法"></a>调用父类中特定的构造方法</h4><p>在子类的构造方法中通过<code>super()</code>语句来调用父类特定的构造方法。（该语句必须写在第一行）</p>
<h3 id="在子类中访问父类的成员"><a href="#在子类中访问父类的成员" class="headerlink" title="在子类中访问父类的成员"></a>在子类中访问父类的成员</h3><p>子类中使用super不但可以访问父类的构造方法，还可以访问父类的成员变量和成员方法，但super不能访问在子类中添加的成员。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">super</span>.变量名();</span><br><span class="line"><span class="built_in">super</span>.方法名();</span><br></pre></td></tr></table></figure>
<p>父类<code>protected</code> 成员，子类可以访问。<br>父类<code>private</code> 成员，子类不可继承</p>
<h3 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h3><p>java多态<code>polymorphism</code></p>
<p>在子类中定义名称、参数个数与类型均与父类中完全相同的方法，用以重写父类中同名方法的功能。</p>
<h4 id="覆盖父类的方法"><a href="#覆盖父类的方法" class="headerlink" title="覆盖父类的方法"></a>覆盖父类的方法</h4><p>子类不能覆盖父类中声明为final或static的方法。</p>
<p>在子类中覆盖父类的方法时，可以扩大父类中的方法权限，但不可以缩小父类方法权限。</p>
<h4 id="用父类的对象访问子类的成员"><a href="#用父类的对象访问子类的成员" class="headerlink" title="用父类的对象访问子类的成员"></a>用父类的对象访问子类的成员</h4><p>只有覆盖情况发生才可以使用。</p>
<p>向上转型：父类引用指向子类对象。<br>向下转型：子类引用指向父类对象，需要显示声明强转。</p>
<h3 id="不可被继承的成员与最终类"><a href="#不可被继承的成员与最终类" class="headerlink" title="不可被继承的成员与最终类"></a>不可被继承的成员与最终类</h3><p>final来修饰成员变量/类，不可以被修改/继承。</p>
<p>final成员变量和final局部变量都是只读量，只能被赋值一次，创建时候赋值或者构造方法赋值。<br>static+final，指定为常量，只能在定义时候赋值。</p>
<h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><p><code>java.lang.Object</code></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Object常用方法</th>
<th style="text-align:center">功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public boolean equals(Obect obj)</td>
<td style="text-align:center">判断两个对象变量所指向的是否为同一个对象</td>
</tr>
<tr>
<td style="text-align:center">public String toString()</td>
<td style="text-align:center">将调用toString()方法的对象转换成字符串</td>
</tr>
<tr>
<td style="text-align:center">public final Class getClass()</td>
<td style="text-align:center">返回运行时对象所属的类</td>
</tr>
<tr>
<td style="text-align:center">protected Object clone()</td>
<td style="text-align:center">返回调用该方法的对象的一个副本</td>
</tr>
</tbody>
</table>
</div>
<h4 id="equals-方法"><a href="#equals-方法" class="headerlink" title="equals()方法"></a>equals()方法</h4><blockquote>
<p>对于字符串的操作，Java程序在执行时会维护一个字符串池(String poll)，对于一些可共享的字符串对象，会现在字符串池中查找是否有相同的字符串内容(字符相同)，如果有就直接返回，而不是直接创建一个新的字符串对象，以减少内存的占用。</p>
</blockquote>
<h4 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString()方法"></a>toString()方法</h4><h4 id="getClass-方法"><a href="#getClass-方法" class="headerlink" title="getClass()方法"></a>getClass()方法</h4><p>返回运行时的对象所属的类。</p>
<h4 id="对象运算符instanceof"><a href="#对象运算符instanceof" class="headerlink" title="对象运算符instanceof"></a>对象运算符instanceof</h4><p>测试一个指定对象是否是指定类或它的子类的实例，返回true/false</p>
<p><code>getName()</code> 得到this类名字符串<br><code>getSuperclass()</code> 得到父类</p>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>抽象类(abstract)：专门的类作为父类</p>
<p>抽象类不能用new运算符来创建实例对象的类</p>
<h3 id="抽象类与抽象方法"><a href="#抽象类与抽象方法" class="headerlink" title="抽象类与抽象方法"></a>抽象类与抽象方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> class 类名 &#123;</span><br><span class="line">	声明成员变量;</span><br><span class="line">	返回值的数据类型 方法名(参数表) &#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">abstract</span> 返回值的数据类型 方法名(参数表);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抽象方法声明中static和abstract不能同时用。<br>abstract不能和final合用。<br>abstract不能与private、static、final或native并列修饰同一个方法。</p>
<p>抽象类不一定有抽象方法，但有抽象方法的类一定要声明为抽象类。</p>
<p>抽象类可以定义构造方法，但需要用protected修饰，只能被子类构造调用。<br>如果抽象类没有定义构造方法，则系统为其添加默认的构造方法。</p>
<h3 id="抽象类的应用"><a href="#抽象类的应用" class="headerlink" title="抽象类的应用"></a>抽象类的应用</h3><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>interface</p>
<p>接口本身也具有数据成员、抽象放、默认方法和静态方法。</p>
<p>接口的数据成员都是静态的且必须初始化，数据成员都是静态常量。<br>接口中除了声明抽象方法外，还可以定义静态方法和默认方法，但是不能定义一般方法。</p>
<h3 id="接口的定义"><a href="#接口的定义" class="headerlink" title="接口的定义"></a>接口的定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">public</span>] interface 接口名称 [extends 父接口名列表] &#123;</span><br><span class="line">	[<span class="keyword">public</span>] [<span class="keyword">static</span>] [<span class="keyword">final</span>] 数据类型 常量名 = 常量;	<span class="comment">//常量</span></span><br><span class="line">	</span><br><span class="line">	[<span class="keyword">public</span>] [<span class="keyword">abstract</span>] 返回值的数据类型 方法名(参数表);	<span class="comment">//抽象方法</span></span><br><span class="line">	</span><br><span class="line">	[<span class="keyword">public</span>] <span class="keyword">static</span> 返回值的数据类型 方法名(参数表) &#123;	<span class="comment">//静态方法</span></span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	[<span class="keyword">public</span>] <span class="keyword">default</span> 返回值的数据类型 方法名(参数表) &#123;	<span class="comment">//静态方法</span></span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口与一般的类一样，本身也具有数据成员与成员方法，但数据成员必须是静态的且一定要赋初值，且此值不能再被修改，若省略数据成员的修饰符，系统默认为public static final；对抽象方法,若方法名前即使省略修饰符，系统仍然默认为public abstract；接口中的静态方法是用public static修饰的；而默认方法是用public default修饰的。</p>
<ul>
<li>接口中的“抽象方法”只需做声明，不用定义其处理数据的方法体；</li>
<li>数据成员都是静态的且必须赋初值，即数据成员必须是静态常量；</li>
<li>接口中的成员都是公共的，所以在定义接口时若省略了public修饰符,在实现抽象方法时,则不能省略该修饰符；</li>
<li>接口实际上就是一种特殊的抽象类。 </li>
</ul>
<h3 id="接口的实现与引用"><a href="#接口的实现与引用" class="headerlink" title="接口的实现与引用"></a>接口的实现与引用</h3><p><code>implement</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class 类名称 implements 接口名表 &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果实现某接口的类不是abstract的抽象类，则在类的定义部分必须实现指定接口的所有抽象方法，即非抽象类中不能存在抽象方法。</li>
<li>一个类在实现某接口的抽象方法时,必须使用完全相同的方法头，否则只是在定义一个新方法,而不是实现已有的抽象方法。</li>
<li>接口中抽象方法的访问控制修饰符都已指定为public，所以类在实现方法时，必须显式地使用public修饰符，否则将被系统警告为缩小了接口中定义的方法的访问控制范围。</li>
<li>与类一样，每个接口都被编译成独立的扩展名为.class的字节码文件。</li>
</ul>
<h3 id="接口的继承"><a href="#接口的继承" class="headerlink" title="接口的继承"></a>接口的继承</h3><p>一个接口可以有一个以上的父接口，它们之间用逗号分隔，形成父接口列表。<br>新接口将继承所有父接口中的常量、抽象方法和默认方法，但不能继承父接口中的静态方法，也不能被实现类所继承。</p>
<h3 id="利用接口实现类的多重继承"><a href="#利用接口实现类的多重继承" class="headerlink" title="利用接口实现类的多重继承"></a>利用接口实现类的多重继承</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">B</span>, C &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="接口中静态方法和默认方法"><a href="#接口中静态方法和默认方法" class="headerlink" title="接口中静态方法和默认方法"></a>接口中静态方法和默认方法</h3><p>接口中的静态方法不能被子接口继承，也不能被实现类继承。默认方法可以。<br>默认方法虽然有方法体，但是必须通过对象来调用，不能通过接口调用。</p>
<h3 id="解决接口多重继承中名字冲突问题"><a href="#解决接口多重继承中名字冲突问题" class="headerlink" title="解决接口多重继承中名字冲突问题"></a>解决接口多重继承中名字冲突问题</h3><p>如果子接口中定义了与父接口同名的常量或者相同名称的方法，则父接口中的常量被隐藏，方法被覆盖。</p>
<p>发生冲突：</p>
<ul>
<li>同名方法新实现。</li>
<li>委托声明 <code>接口名.super.默认方法名()</code></li>
</ul>
<blockquote>
<p>在多个父接口的实现类中解决同名默认方法的名字冲突问题，有两种办法：一种是提供同名方法的一个新实现；另一种是委托一个父接口的默认方法。<br>如果两个父接口中有一个提供的不是默认方法，而是抽象方法，则只需要在接口的实现类中提供同名方法的一个新实现即可。<br>如果两个父接口中的同名方法都是抽象方法，则不会发生名字冲突，实现接口的类可以实现该同名方法即可，或者不实现该方法而将自己也声明为抽象类。<br>如果一个类继承一个父类并实现了一个接口，而从父类和接口中继承了同名的方法，此时采用“类比接口优先”的原则，即只继承父类的方法，而忽略来自接口的默认方法。</p>
</blockquote>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>有些数据的取值被限定在几个确定的值之间，可以被一一列举出来。</p>
<p>对于类似这种当一个变量有几种固定取值时，将其声明为枚举类型。</p>
<h3 id="枚举类型的定义"><a href="#枚举类型的定义" class="headerlink" title="枚举类型的定义"></a>枚举类型的定义</h3><p>枚举是一种特殊的类，也称为枚举类，是一种引用类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] <span class="keyword">enum</span> 枚举类型名 &#123;	<span class="comment">//修饰符可以使public/private/internal</span></span><br><span class="line">	枚举成员</span><br><span class="line">	方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>枚举类型名：作为枚举名使用；表示枚举成员的数据类型。</p>
<p>枚举成员：一一列出的枚举常量，任何两个枚举成员之间不能重名，用逗号分割。</p>
<blockquote>
<p>enum、class、interface地位相同。</p>
</blockquote>
<ul>
<li>枚举可以实现一个或多个接口，使用enum关键字声明的枚举默认继承了java.lang.Enum类，而不是继承java.lang.Object类，因此枚举不能显式地继承其他父类。</li>
<li>使用enum定义非抽象的枚举类时默认使用final修饰，因此枚举类不能派生子类。</li>
<li>创建枚举类型的对象时不能使用new运算符，而是直接将枚举成员赋值给枚举对象。</li>
<li>因为枚举是类，所以它可以有自己的构造方法和其他方法。但构造方法只能用private访问修饰符, 如果省略，则默认使用private修饰符，如果强制使用访问修饰符，则只能使用private。</li>
<li>枚举的所有枚举成员必须在枚举体的第一行显式列出，否则该枚举不能产生枚举成员。枚举成员默认使用public static final进行修饰。</li>
<li>可以通过<code>==</code>和<code>!=</code>比较两个枚举是否相等。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">	EAST, SOUTH, WEST, NORTH;	<span class="comment">//默认使用public static final 修饰</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有枚举类型都包含values()和valueOf()两个预定义方法。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public static enumtype[] values()</td>
<td style="text-align:center">返回枚举类型的数组,该数组包含枚举的所有枚举成员，并按它们的声明顺序存储</td>
</tr>
<tr>
<td style="text-align:center">public static enumtype valueOf(String str)</td>
<td style="text-align:center">返回名称为str的枚举成员</td>
</tr>
</tbody>
</table>
</div>
<p>所有枚举对象都继承自抽象类<code>java.lang.Enum&lt;E&gt;</code>，该类定义了枚举公用的方法以方便用户使用。<code>java.lang.Enum&lt;E&gt;</code>实现了<code>java.lang.Comparable&lt;E&gt;</code>和<code>java.lang.Serializable</code> 两个接口，所以枚举类型时可以使用比较器和遍历操作的。<br>| Eunm &lt; E &gt;常用方法 | 功能说明 |<br>| :-: | :-: |<br>| public final int compareTo(E o) | 返回当前枚举成员与参数枚举成员o在定义时顺序的比较结果 |<br>| public final String name() | 返回枚举常量的名称 |<br>| public final int ordinal() | 返回枚举成员在枚举中的序号(枚举成员的序号从0开始) |<br>| publie final boolean equals(Object other) | 比较两个枚举引用的对象是否相等 |<br>| public String toString() | 返回枚举成员的名称 |<br>| public static &lt; TextendsEnum &lt; T &gt; &gt; T valueOf(Class&lt; T &gt; enumType, String name) | 返回指定枚举类型和指定名称的枚举成员 |</p>
<h3 id="不包含方法的枚举"><a href="#不包含方法的枚举" class="headerlink" title="不包含方法的枚举"></a>不包含方法的枚举</h3><p>当访问枚举类型的成员时，直接使用枚举名嗲用枚举成员即可，<code>枚举名.枚举成员</code></p>
<p><code>枚举名.valueOf()</code> 形式调用获取枚举类的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">	EAST, SOUTH, WEST, NORTH;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">D8_1</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mian</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Direction</span> <span class="variable">dir</span> <span class="operator">=</span> Direction.EAST;</span><br><span class="line">		<span class="type">Direction</span> <span class="variable">dir1</span> <span class="operator">=</span> Direction.valueOf(<span class="string">&quot;NORTH&quot;</span>);</span><br><span class="line">		System.out.pritln(dir);</span><br><span class="line">		System.out.pritln(dir1);</span><br><span class="line">		<span class="keyword">for</span> (Direction d : Direction.values()) &#123;</span><br><span class="line">			System.out.pritln(d.ordoal() + <span class="string">&quot; &quot;</span> + d.name());			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EAST</span><br><span class="line">NORTH</span><br><span class="line">0 EAST</span><br><span class="line">1 SOUTH</span><br><span class="line">2 WEST</span><br><span class="line">3 NORTH</span><br></pre></td></tr></table></figure>
<h3 id="包含属性和方法的枚举"><a href="#包含属性和方法的枚举" class="headerlink" title="包含属性和方法的枚举"></a>包含属性和方法的枚举</h3><p>枚举的构造方法只是在构造枚举成员时候被调用。每一个枚举成员都是枚举的一个对象，因此创建每个枚举成员时都需要调用该构造方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direciton</span> &#123;</span><br><span class="line">	EAST(<span class="string">&quot;东&quot;</span>), SOUTH(<span class="string">&quot;南&quot;</span>), WEST(<span class="string">&quot;西&quot;</span>), NORTH(<span class="string">&quot;北&quot;</span>);</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Direction</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">D8_2</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mian</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Direction</span> <span class="variable">dir</span> <span class="operator">=</span> Enum.valueOf(Direction.class, <span class="string">&quot;NORTH&quot;</span>);</span><br><span class="line">		System.out.pritln(dir);</span><br><span class="line">		<span class="keyword">for</span> (Direction d : Direction.values()) &#123;</span><br><span class="line">			System.out.pritln(d.name() + <span class="string">&quot; &quot;</span> +d.toString());			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">北</span><br><span class="line">EAST 东</span><br><span class="line">SOUTH 南</span><br><span class="line">WEST 西</span><br><span class="line">NORTH 北</span><br></pre></td></tr></table></figure>
<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><h3 id="包的概念"><a href="#包的概念" class="headerlink" title="包的概念"></a>包的概念</h3><p>Java语言提供的一种区别类名空间的机制，是类的组织方式。</p>
<h3 id="使用package语句创建包"><a href="#使用package语句创建包" class="headerlink" title="使用package语句创建包"></a>使用package语句创建包</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 包名<span class="number">1</span>[.包名<span class="number">2</span>[.包名<span class="number">3</span>]...];</span><br></pre></td></tr></table></figure>
<p>包层次的根文件夹是由环境变量ClassPath来确定的。<br>默认包的路径是当前文件夹，即无名包(unnamed package)</p>
<h3 id="Java语言中的常用包"><a href="#Java语言中的常用包" class="headerlink" title="Java语言中的常用包"></a>Java语言中的常用包</h3><p><code>API</code> ：应用程序接口（Application Programming Interface）</p>
<ul>
<li>java.lang：语言包；</li>
<li>java.io：输入输出流的文件包；</li>
<li>java.util：实用包；</li>
<li>java.net：网络功能包；</li>
<li>java.sql：数据库连接包；</li>
<li>java.text：文本包。</li>
</ul>
<h4 id="语言包java-lang"><a href="#语言包java-lang" class="headerlink" title="语言包java.lang"></a>语言包java.lang</h4><ul>
<li>Object类;</li>
<li>数据类型包装类( The Data Type Wrapper ) ;</li>
<li>字符串类( String) ;</li>
<li>数学类( Math) ;</li>
<li>系统和运行时类( System、Runtime ) ;</li>
<li>类操作类( Class ) ;</li>
<li>错误和异常处理类( Throwable, Exception和Error ) ;</li>
<li>线程类( Thread ) ;</li>
<li>过程类( Process )。</li>
</ul>
<h4 id="输入输出流的文件包java-io"><a href="#输入输出流的文件包java-io" class="headerlink" title="输入输出流的文件包java.io"></a>输入输出流的文件包java.io</h4><ul>
<li>基本输入输出流类；</li>
<li>文件输入输出流类；</li>
<li>过滤输入输出流类；</li>
<li>管道输入输出流类；</li>
<li>随机输入输出流类。</li>
</ul>
<h4 id="实用包java-util"><a href="#实用包java-util" class="headerlink" title="实用包java.util"></a>实用包java.util</h4><ul>
<li>数据输入类(Scanner) ;</li>
<li>日期类(Date、Calendar等) ;</li>
<li>链表类(LinkedList) ;</li>
<li>向量类(Vector) ;</li>
<li>哈希表类(Hashtable) ;</li>
<li>栈类(Stack) ;</li>
<li>树类(TreeSet)。</li>
</ul>
<h4 id="网络功能包java-net"><a href="#网络功能包java-net" class="headerlink" title="网络功能包java.net"></a>网络功能包java.net</h4><ul>
<li>访问网络资源类(URL) ;</li>
<li>套接字类(Socket) ;</li>
<li>服务器端套接字类(ServerSocket) ;</li>
<li>数据报打包类(DatagramPacket) ;</li>
<li>数据报通信类(DatagramSocket)。</li>
</ul>
<h4 id="数据库连接包java-sql"><a href="#数据库连接包java-sql" class="headerlink" title="数据库连接包java.sql"></a>数据库连接包java.sql</h4><p>实现JDBC(Java DataBase Conection)java数据库链接的类库。</p>
<h4 id="文本包java-text"><a href="#文本包java-text" class="headerlink" title="文本包java.text"></a>文本包java.text</h4><p>Java文本包java.text中的Format、DataFormat、SimpleDateFormat等类提供各种文本或日期格式。</p>
<h3 id="Java语言中几个常用的类"><a href="#Java语言中几个常用的类" class="headerlink" title="Java语言中几个常用的类"></a>Java语言中几个常用的类</h3><h4 id="Date类-java-util"><a href="#Date类-java-util" class="headerlink" title="Date类(java.util)"></a>Date类(java.util)</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Date构造方法</th>
<th style="text-align:center">功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public Date()</td>
<td style="text-align:center">用系统日期时间数据创建Date对象</td>
</tr>
<tr>
<td style="text-align:center">public Date(long date)</td>
<td style="text-align:center">用长整型数date创建Date对象,date表示从1970年1月1日00:00:00时开始到该日期时刻的微秒数</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Date常用方法</th>
<th style="text-align:center">功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public long getTime()</td>
<td style="text-align:center">返回从1970年1月1日00:00:00时开始到目前的微秒数</td>
</tr>
<tr>
<td style="text-align:center">public boolean after(Date when)</td>
<td style="text-align:center">日期比较,日期在when之后返回true,否则返回false</td>
</tr>
<tr>
<td style="text-align:center">public boolean before(Date when)</td>
<td style="text-align:center">日期比较,日期在when之前返回true,否则返回false</td>
</tr>
</tbody>
</table>
</div>
<p>Date对象表示时间的默认顺序是：星期、月、日、小时、分、秒、年。如果希望按年、月、日、时、分、秒、星期的顺序显示其时间，这时可以使用java.text.DateFormat类的子类java.text.SimpleDateFormat来实现日期的格式化。</p>
<p>SimpleDateFormat类有一个常用的构造方法：<code>public SimpleDateFormat(String pattern)</code>。该构造方法可以用参数pattern指定格式创建一个对象，该对象调用<code>format(Date date)</code>方法来格式化时间对象date。需要注意的是，pattern中应当含有如下一些有效的字符序列:</p>
<ul>
<li>y或yy表示用2位数字输出的年份，yyyy表示用4位数字输出年份；</li>
<li>M或MM表示用2位数字或文本输出月份，若要用汉字输出月份，pattern中应连续包含至少3个M；</li>
<li>d或dd表示用2位数字输出日；</li>
<li>H或HH表示用2位数字输出小时；</li>
<li>m或mm表示用2位数字输出分；</li>
<li>s或ss表示用2位数字输出秒；</li>
<li>E表示用字符串输出星期；</li>
<li>a表示输出上、下午。</li>
</ul>
<h4 id="Calender类-java-util"><a href="#Calender类-java-util" class="headerlink" title="Calender类(java.util)"></a>Calender类(java.util)</h4><p>描述日期时间的抽象类。</p>
<p>Calendar类通常用于需要将日期值分解的情况，Calendar类中声明了YEAR等多个常量，分别表示年、月、日等日期中的单个部分值。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Calender类中常用的常量</th>
<th style="text-align:center">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public static final int YEAR</td>
<td style="text-align:center">表示对象日期的年</td>
</tr>
<tr>
<td style="text-align:center">public static final int MONTH</td>
<td style="text-align:center">表示对象日期的月,0 ~ 11分别表示1 ~ 12月</td>
</tr>
<tr>
<td style="text-align:center">public static final int DAY_OF_MONTH</td>
<td style="text-align:center">表示对象日期的日</td>
</tr>
<tr>
<td style="text-align:center">public static final int DATE</td>
<td style="text-align:center">与public static final int DAY_OF_MONTH意义相同</td>
</tr>
<tr>
<td style="text-align:center">public static final int DAY_OF_YEAR</td>
<td style="text-align:center">表示对象日期是该年的第几天</td>
</tr>
<tr>
<td style="text-align:center">public static final int WEEK_OF_YEAR</td>
<td style="text-align:center">表示对象日期是该年的第几周</td>
</tr>
<tr>
<td style="text-align:center">public static final int HOUR</td>
<td style="text-align:center">表示对象日期的时</td>
</tr>
<tr>
<td style="text-align:center">public static final int MINUTE</td>
<td style="text-align:center">表示对象日期的分</td>
</tr>
<tr>
<td style="text-align:center">public static final int SECOND</td>
<td style="text-align:center">表示对象日期的秒</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Calender类常用方法</th>
<th style="text-align:center">功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public int get(int field)</td>
<td style="text-align:center">返回对象属性field 的值,属性是上表描述的静态常量</td>
</tr>
<tr>
<td style="text-align:center">public void set(int field,int value)</td>
<td style="text-align:center">设置对象属性field的值为value</td>
</tr>
<tr>
<td style="text-align:center">public boolean after(Object when)</td>
<td style="text-align:center">日期比较,日期在when之后返回true,否则返回false</td>
</tr>
<tr>
<td style="text-align:center">public boolean before(Object when)</td>
<td style="text-align:center">日期比较,日期在when之前返回true,否则返回false</td>
</tr>
<tr>
<td style="text-align:center">public static Calendar getInstance()</td>
<td style="text-align:center">获取Calendar对象</td>
</tr>
<tr>
<td style="text-align:center">public final Date getTime()</td>
<td style="text-align:center">由Calendar对象创建Date对象</td>
</tr>
<tr>
<td style="text-align:center">public long getTimeInMillis()</td>
<td style="text-align:center">返回从1970年1月1日00:00:00时开始到目前的微秒数</td>
</tr>
<tr>
<td style="text-align:center">public void setTimeInMillis(long millis)</td>
<td style="text-align:center">以长整型数millis设置对象日期,millis表示从1970年1月1日00:00:00时开始到该日期时刻的微秒数</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">now</span> <span class="operator">=</span> Calendar.getInstance();	<span class="comment">//创建日历对象</span></span><br><span class="line"><span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> now.get(Calendar.MONTH);	<span class="comment">//获得日历对象的月份值</span></span><br></pre></td></tr></table></figure>
<p>也可利用now对象调用相应的set（）方法将日历翻到任何一个时间。</p>
<h4 id="Random类-java-util"><a href="#Random类-java-util" class="headerlink" title="Random类(java.util)"></a>Random类(java.util)</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Random类构造方法</th>
<th style="text-align:center">功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public Random()</td>
<td style="text-align:center">用系统时间作为种子创建Random对象</td>
</tr>
<tr>
<td style="text-align:center">public Random(long seed)</td>
<td style="text-align:center">用seed作为种子创建Random对象</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Random类常用方法</th>
<th style="text-align:center">功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public int nextInt()</td>
<td style="text-align:center">返回一个整型随机数</td>
</tr>
<tr>
<td style="text-align:center">public int nextInt(int n)</td>
<td style="text-align:center">返回一个大小为0~n的整型随机数</td>
</tr>
<tr>
<td style="text-align:center">public long nextLong()</td>
<td style="text-align:center">返回一个长整型随机数</td>
</tr>
<tr>
<td style="text-align:center">public float nextFloat()</td>
<td style="text-align:center">返回一个0.0~1.0的单精度随机数</td>
</tr>
<tr>
<td style="text-align:center">public double nextDouble()</td>
<td style="text-align:center">返回一个0.0~1.0的双精度随机数</td>
</tr>
</tbody>
</table>
</div>
<h4 id="Math类-java-lang"><a href="#Math类-java-lang" class="headerlink" title="Math类(java.lang)"></a>Math类(java.lang)</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Calender类中常用的常量</th>
<th style="text-align:center">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public static final double PI</td>
<td style="text-align:center">圆周率π=3.141592653589793</td>
</tr>
<tr>
<td style="text-align:center">public static final double E</td>
<td style="text-align:center">自然对数率e=2.718281828459045</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Calender类中常用方法</th>
<th style="text-align:center">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public static double abs(double a)</td>
<td style="text-align:center">返回数a的绝对值</td>
</tr>
<tr>
<td style="text-align:center">public static double sin(double a)</td>
<td style="text-align:center">返回a的正弦值,a的单位为弧度</td>
</tr>
<tr>
<td style="text-align:center">public statice double cos(double a)</td>
<td style="text-align:center">返回a的余弦值,a的单位为弧度</td>
</tr>
<tr>
<td style="text-align:center">public static double tan(double a)</td>
<td style="text-align:center">返回a的正切值,a的单位为弧度</td>
</tr>
<tr>
<td style="text-align:center">public static double asin(double a)</td>
<td style="text-align:center">返回a的反正弦值</td>
</tr>
<tr>
<td style="text-align:center">public static double acos(double a)</td>
<td style="text-align:center">返回a的反余弦值</td>
</tr>
<tr>
<td style="text-align:center">public static double atan(double a)</td>
<td style="text-align:center">返回a的反正切值</td>
</tr>
<tr>
<td style="text-align:center">public static double sqrt(double a)</td>
<td style="text-align:center">返回数a的平方根,a必须是正数</td>
</tr>
<tr>
<td style="text-align:center">public static double ceil(double a)</td>
<td style="text-align:center">返回大于或等于a的最小实型整数值</td>
</tr>
<tr>
<td style="text-align:center">public static double floor(double a)</td>
<td style="text-align:center">返回小于或等于a的最大实型整数值</td>
</tr>
<tr>
<td style="text-align:center">public static double random()</td>
<td style="text-align:center">返回取值在[0.0,1.0)区间的随机数</td>
</tr>
<tr>
<td style="text-align:center">public static double pow(double a, double b)</td>
<td style="text-align:center">返回以a为底,以b为指数的幂值</td>
</tr>
</tbody>
</table>
</div>
<h3 id="利用import语句引用Java定义的包"><a href="#利用import语句引用Java定义的包" class="headerlink" title="利用import语句引用Java定义的包"></a>利用import语句引用Java定义的包</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>包名<span class="number">1</span>[.包名<span class="number">2</span>[.包名<span class="number">3</span>…]].类名|∗</span><br></pre></td></tr></table></figure>
<p>Java编译器为所有程序自动隐含地导入java.lang包</p>
<blockquote>
<p>使用*只能表示本层次的所有类，不包括子层次下的类。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myDate</span> <span class="keyword">extends</span> <span class="title class_">Date</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myDate</span> <span class="keyword">extends</span> <span class="title class_">java</span>.util.Date &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Java程序结构"><a href="#Java程序结构" class="headerlink" title="Java程序结构"></a>Java程序结构</h3><ul>
<li>package，声明包，0或1个；</li>
<li>import，导入包，0或多个；</li>
<li>public class，声明公有类，0个或1个，文件名与该类名相同；</li>
<li>class，声明类，0或多个；</li>
<li>interface，声明接口，0或多个。</li>
</ul>
<h2 id="本章小结-2"><a href="#本章小结-2" class="headerlink" title="本章小结"></a>本章小结</h2><ul>
<li>通过extends关键字，可将父类的非私有成员（成员变量和成员方法）继承给子类。</li>
<li>父类有多个构造方法时，如果要调用特定的构造方法，则可在子类的构造方法中，通过super（）语句来调用。</li>
<li>Java程序在执行子类的构造方法之前，如果没有用super()语句来调用父类中特定的构造方法，则会先调用父类中没有参数的构造方法。其目的是为了帮助继承自父类的成员做初始化操作。</li>
<li>在构造方法内调用同一类内的其他构造方法使用this()语句，而从子类的构造方法调用其父类的构造方法则使用super()语句。</li>
<li>this())除了可以用来调用同一类的构造方法之外，如果同一类内的成员变量与局部变量的名称相同时，也可以利用“this.成员变量名”来调用同一类内的成员变量。</li>
<li>this()与super()的相似之处：（1）当构造方法有重载时，两者均会根据所给予的参数的类型与个数，正确地选择执行相对应的构造方法；（2）两者均必须编写在构造方法内的第一行，也就是因为这个原因，this()与super()无法同时存在于同一个构造方法内。</li>
<li>除了利用super()来调用父类的构造方法外，还利用“super.成员名”的形式来调用父类中的成员变量或成员方法。</li>
<li>把成员声明成protected最大的好处是可同时兼顾到成员的安全与便利性，因为它只能供父类、子类及同一包中的类来访问，而其他类则无法更改或读取它。</li>
<li>重载是指在同一个类内，定义名称相同但参数个数或类型不同的多个方法。Java系统可根据参数的个数或类型，调用相对应的方法。</li>
<li>覆盖是在子类当中，定义名称、参数个数与类型均与父类相同的方法，用以覆盖父类中方法的功能。</li>
<li>如果父类的方法不希望子类的方法来覆盖它，可以在父类的方法之前加上final关键字，这样该方法就不会被覆盖。</li>
<li>final关键字的另一作用是把它放在成员变量前面，这样该变量就变成一个常量，因而便无法在程序中的任何地方再做修改。</li>
<li>无论是自定义的类，还是Java内置的类，所有的类均继承自Object类。</li>
<li>Java语言的抽象类是专门用来当作父类的，所以抽象类不能直接用来创建对象。抽象类的目的是要用户根据它的格式来修改并创建新的类。</li>
<li>抽象类中的方法可分为两种：一种是一般的方法；另一种是以关键字abstract开头的抽象方法。抽象方法是没有定义方法体的方法，是要保留给由抽象类派生出的子类来定义。</li>
<li>接口的结构和抽象类非常相似，它也具有数据成员、抽象方法、默认方法和静态方法，但它与抽象类有两点不同：（1）接口的数据成员都是静态的且必须初始化；（2）接口中的抽象方法必须全部声明为public abstract。</li>
<li>Java语言并不允许类的多重继承，但利用接口可实现多重继承。</li>
<li>接口与一般类一样，均可通过扩展技术来派生出新的接口。原来的接口称为基本接口或父接口；派生出的接口称为派生接口或子接口。通过这种机制，子接口不仅可以拥有父接口的成员，同时也可以添加新的成员以满足实际问题的需要。</li>
<li>枚举是一种特殊的类，所以它是一种引用类型。</li>
<li>枚举类型名有两层含义：一是作为枚举名使用；二是表示枚举成员的数据类型。正因为如此，枚举成员也称为枚举实例或枚举对象。</li>
<li>Java语言的package是存放类与接口的地方，因此我们把package译为“类库”。它是在使用多个类或接口时，避免名称重复而采用的一种措施。</li>
<li>在源文件内若没有指明package，则Java把它视为“没有名称的package”。</li>
<li>如果多个类分别属于不同的package，若某个类要访问到其他类的成员时，必须做下列修改：①若某个类需要被访问时，则必须把这个类声明为public的；②若要访问不同package内某个public类的成员时，在程序代码内必须明确地指明“被访问package的名称.类名称”。</li>
<li>在类之前加上public修饰符是为了让其他包里的类也可以访问该类里的成员。如果省略了类的修饰符，则只能让同一个包里的类来访问。</li>
<li>导入包里的某个类，其格式为“import包名.类名”。</li>
<li>String类放置在java.lang类库内。在java.lang类库里所有的类均会自动加载，因此当使用到String类时，无须利用import命令来加载它。</li>
</ul>
<h2 id="课后习题-2"><a href="#课后习题-2" class="headerlink" title="课后习题"></a>课后习题</h2><ul>
<li>子类将继承父类的所有成员吗？为什么？</li>
<li>在子类中可以调用父类的构造方法吗？若可以，如何调用？</li>
<li>在调用子类的构造方法之前，若没有指定调用父类的特定构 造方法，则会先自动调用父类中没有参数的构造方法，其目的是什么？</li>
<li>在子类中可以访问父类的成员吗？若可以，用什么方式访 问？</li>
<li>用父类对象变量可以访问子类的成员方法吗？若可以，则只限于什么情况？</li>
<li>什么是多态机制？Java语言中是如何实现多态的？</li>
<li>方法的覆盖与方法的重载有何不同？</li>
<li>this和super分别有什么特殊的含义？</li>
<li>什么是最终类与最终方法？它们的作用是什么？</li>
<li>什么是抽象类与抽象方法？使用时应注意哪些问题？</li>
<li>什么是接口？为什么要定义接口？</li>
<li>如何定义接口？接口与抽象类有哪些异同？</li>
<li>在多个父接口的实现类中，多个接口中的方法名冲突问题有几种形式？如何解决？</li>
<li>编程题。定义一个表示一周七天的枚举，并在主方法 main()中遍历枚举所有成员。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeekDaysList</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="keyword">for</span>(DaysOfTheWeek day:DaysOfTheWeek.values())</span><br><span class="line">			System.out.println(day);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">DaysOfTheWeek</span></span><br><span class="line">&#123;</span><br><span class="line">	MONDAY,TUESDAY,WEDNESDAY,THURSDAY,FRIDAY,STAURDAY,SUNDAY;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="built_in">super</span>.toString();</span><br><span class="line">		<span class="keyword">return</span> s.substring(<span class="number">0</span>,<span class="number">1</span>) + s.substring(<span class="number">1</span>).toLowerCase();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>什么是包？它的作用是什么？如何创建包？如何引用包中的类？</li>
</ul>
<h1 id="第九章-异常处理"><a href="#第九章-异常处理" class="headerlink" title="第九章 异常处理"></a>第九章 异常处理</h1><h2 id="异常处理的基本概念"><a href="#异常处理的基本概念" class="headerlink" title="异常处理的基本概念"></a>异常处理的基本概念</h2><p>异常(exception)是指在程序运行中由代码产生的一种错误。</p>
<h3 id="错误与异常"><a href="#错误与异常" class="headerlink" title="错误与异常"></a>错误与异常</h3><p>错误分为<code>语法错误</code>、<code>语义错误</code>、<code>逻辑错误</code>。</p>
<p><code>语法错误</code>：语法错是由于违反程序设计语言的语法规则而产生的错误，如标识符未声明、表达式中运算符与操作数类型不兼容、括号不匹配、语句末尾缺少分号等。语法错误是由语言的编译系统负责检测和报告。</p>
<p><code>语义错误</code>：如果程序在语法上正确，但在语义上存在错误，如输入数据格式错、除数为0错、给变量赋值超出其允许范围等，这类错误称为语义错。还有一些语义错误不能被程序事先处理，如待打开的文件不存在、网络连接中断等，这类错误的发生不由程序本身所控制，因此必须进行异常处理。</p>
<p><code>逻辑错误</code>：如果程序编译通过，也可运行，但运行结果与预期结果不符，如由于循环条件不正确而没有结果、循环次数不对等因素导致的计算结果不正确等，这类错误称为逻辑错。</p>
<p>虽然程序有三种性质的错误，但Java系统中根据错误严重程度的不同，而将程序运行时出的错分为两类：<code>错误</code>和<code>异常</code>。</p>
<p><code>错误</code>是指程序在执行过程中所遇到的硬件或操作系统的错误，如内存溢出、虚拟机错等。</p>
<p><code>异常</code>是指在硬件和操作系统正常时，程序遇到的运行错。</p>
<h3 id="Java语言的异常处理机制"><a href="#Java语言的异常处理机制" class="headerlink" title="Java语言的异常处理机制"></a>Java语言的异常处理机制</h3><p>Java语言提供的异常处理机制是通过面向对象的方法来处理异常的。</p>
<p>异常抛出后，运行系统从生成异常对象的代码开始，沿方法的调用栈逐层回溯查找，直到找到包含相应异常处理的方法，并把异常对象提交给该方法为止，这个过程称为<code>捕获异常</code>。</p>
<blockquote>
<p>每当Java程序运行过程中发生一个可识别的运行错误时，即该错误有一个异常类与之对应时，系统都会产生一个相应的该异常类的对象。</p>
</blockquote>
<h2 id="异常处理类"><a href="#异常处理类" class="headerlink" title="异常处理类"></a>异常处理类</h2><p>由于Java语言中定义了很多异常类，而每个异常类都代表一种运行错误，所以说，Java语言的异常类是处理运行时错误的特殊类，类中包含了该运行错误的信息和处理错误的方法等内容。</p>
<p>Throwable继承类有java.lang.Error和java.lang.Exception</p>
<p>即Error类及子类的对象是由Java虚拟机生成并抛出给系统，这种错误有<code>内存溢出错</code>、<code>栈溢出错</code>、<code>动态链接错</code>等。</p>
<ul>
<li>异常类的构造方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Exception</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Exception</span><span class="params">(String s)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>异常类的常用方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>;	<span class="comment">//返回描述当前Excrption类信息的字符串</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printStackTrace</span><span class="params">()</span>;	<span class="comment">//该方法没有返回值，它的功能是完成一个输出操作，在当前的标准输出设备（一般是屏幕显示器）上输出当前异常对象的堆栈使用轨迹，即程序先后调用并执行了哪些对象或类的哪些方法，使得运行过程中产生了这个异常对象。</span></span><br></pre></td></tr></table></figure>
<img src="/2021/12/25/JAVA%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80-%E7%AC%AC6%E7%89%88%E9%99%88%E5%9B%BD%E5%90%9B2006-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/%E5%BC%82%E5%B8%B8%E7%B1%BB%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" class="" title="异常类的层次结构">
<blockquote>
<p>RuntimeException可以不编写异常处理的程序代码，依然可以成功编译，因为它是在程序运行时才有可能产生，如除数为0异常、数组下标越界异常、空指针异常等。这类异常应通过程序调试尽量避免而不是使用try-catch-finally语句去捕获它。<br>除RuntimeException之外，其他则是非运行时异常，这种异常经常是在程序运行过程中由环境原因造成的异常，如输入输出异常、网络地址不能打开、文件未找到等。这类异常必须在程序中使用try-catch-finally语句去捕获它并进行相应的处理，否则编译不能通过。</p>
</blockquote>
<p>程序对错误与异常的处理方式有三种：一是程序不能处理的错误；二是程序应避免而可以不去捕获的运行时异常；三是必须捕获的非运行时异常。</p>
<h2 id="异常的处理"><a href="#异常的处理" class="headerlink" title="异常的处理"></a>异常的处理</h2><p>在Java语言中，异常处理是通过<code>try</code>、<code>catch</code>、<code>finally</code>、<code>throw</code>、<code>throws</code>五个关键字来实现的。</p>
<p>try-catch-finally语句来捕获和处理一个或多个异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	要检查的语句序列</span><br><span class="line">&#125; <span class="keyword">catch</span>(异常类名 形参对象名) &#123;</span><br><span class="line">	异常发生时的处理语句序列</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	一定会运行的语句序列</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多异常处理是通过在一个try块后面定义若干个catch块来实现的，每个catch块用来接收和处理一种特定的异常对象。</p>
<blockquote>
<p>一般地，将处理较具体、较常见异常的catch块应放在前面。<br>当catch块中含有System.exit(0)语句时，则不执行finally块中的语句，程序直接终止；当catch块中含有return语句时则执行完finally块中的语句后再终止程序。</p>
</blockquote>
<h2 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h2><p>系统自动抛出的异常<br>指定方法抛出异常</p>
<h3 id="抛出异常的方法"><a href="#抛出异常的方法" class="headerlink" title="抛出异常的方法"></a>抛出异常的方法</h3><p>方式一：在方法体内使用throw语句抛出异常对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> 由异常类所产生的对象;</span><br></pre></td></tr></table></figure>
<p>方式二：在方法头部添加throws子句表示方法将抛出异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[修饰符]返回值类型方法名([参数列表])<span class="keyword">throws</span>异常类列表</span><br></pre></td></tr></table></figure>
<h3 id="处理异常的方法"><a href="#处理异常的方法" class="headerlink" title="处理异常的方法"></a>处理异常的方法</h3><p>由一个方法抛出异常后，该方法内又没有处理异常的语句，则系统就会将异常向上传递，由调用它的方法来处理这些异常，若上层调用方法中仍没有处理异常的语句，则可以再往上追溯到更上层，这样可以一层一层地向上追溯，一直可追溯到main()方法，这时JVM肯定要处理的，这样编译就可以通过了。也就是说，如果某个方法声明抛出异常，则调用它的方法必须捕获并处理异常，否则会出现错误。</p>
<h3 id="由方法抛出异常交系统处理"><a href="#由方法抛出异常交系统处理" class="headerlink" title="由方法抛出异常交系统处理"></a>由方法抛出异常交系统处理</h3><p>对于程序需要处理的异常，一般编写try-catch-finally语句捕获并处理，而对于程序中无法处理必须交由系统处理的异常，由于系统直接调用的是主方法main()，所以可以在主方法头使用throws子句声明抛出异常交由系统处理。如下面的程序，编译能通过，运行也没问题。</p>
<p>针对IOException类的异常处理，编写的方式也有三种：</p>
<ul>
<li>直接由主方法main()抛出异常，让Java默认的异常处理机制来处理，即若在主方法main()内没有使用try-catch语句捕获异常 ， 则 必 须 在 声 明 主 方 法 main()头 部 的 后 面 加 上 throws IOException子句；</li>
<li>在程序代码内编写try-catch语句来捕获由系统抛出的异常，如此则不用指定main()throws IOException抛出异常了；</li>
<li>既在main()方法头的后面使用throws IOException抛出异常，也可以在程序中使用try-catch语句来捕获由系统抛出的异常。</li>
</ul>
<h2 id="自动关闭资源的try语句"><a href="#自动关闭资源的try语句" class="headerlink" title="自动关闭资源的try语句"></a>自动关闭资源的try语句</h2><p><code>try-with-resources</code>语句，也称为自动资源管理语句。</p>
<p>自动关闭资源的try语句相当于包含了隐式的finally语句块，该finally语句块会自动调用res.close()方法关闭前面所访问的资源。<br>如果在try-with-resources语句中含有catch和finally子句，则catch和finally子句将会在try-with-resources语句中打开的资源被关闭之后得到调用。</p>
<blockquote>
<p>java.io.Closeable接口继承AutoCloseable接口，这两个接口被所有的I/O流类实现。因此，在使用I/O流时，可以使用try-with-resources语句。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">APP9_7</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="keyword">try</span>(<span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(Path.get(<span class="string">&quot;chapter9\\t.txt&quot;</span>))) &#123;</span><br><span class="line">			<span class="keyword">while</span>(in.hasNext()) &#123;</span><br><span class="line">				System.out.println(in.nextLine());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自定义异常类"><a href="#自定义异常类" class="headerlink" title="自定义异常类"></a>自定义异常类</h2><p>（1）用户自定义的异常类必须是Throwable类的直接或间接子类。<br>（2）为用户自定义的异常类定义属性和方法，或覆盖父类的属性和方法，使这些属性和方法能够体现该类所对应的错误信息。习惯上是在自定义异常类中加入两个构造方法，分别是没有参数的构造方法和含有字符串型参数的构造方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CircelException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">	<span class="type">double</span> radius;</span><br><span class="line">	CircleException(<span class="type">double</span> r) &#123;</span><br><span class="line">		radius = r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;半径 r = &quot;</span> + radius + <span class="string">&quot;不是一个正数&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">double</span> radius;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRadius</span><span class="params">(<span class="type">double</span> r)</span> <span class="keyword">throws</span> CircelException &#123;</span><br><span class="line">		<span class="keyword">if</span>(r &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CircelException</span>(r);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			radius = r;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;圆面积 = &quot;</span> + <span class="number">3.14</span> * radius * radius);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App9_8</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Circle</span> <span class="variable">cir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			cir.setRadius(-<span class="number">2.0</span>);			</span><br><span class="line">		&#125; <span class="keyword">catch</span> (CircleException e) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;自定义异常:&quot;</span> + e.toString() + <span class="string">&quot;&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		cir.show();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对异常处理的两种方式：</p>
<ul>
<li>在方法内使用try-catch语句来处理方法本身所产生的异常。</li>
<li>如果不想再当前方法中使用try-catch语句来处理异常，可以在方法声明的头部使用throws语句或者在方法内部使用throw语句将它送往上一层调用机构去处理。</li>
</ul>
<h2 id="本章小结-3"><a href="#本章小结-3" class="headerlink" title="本章小结"></a>本章小结</h2><ul>
<li>异常类可分为两大类，分别为java.lang.Exception与java.lang.Error类。</li>
<li>程序代码没有编写处理异常时，Java语言的默认异常处理机制是：(1)抛出异常；(2)停止程序的执行。</li>
<li>当异常发生时，有两种处理方式：(1)交由Java语言默认的异常处理机制做处理；(2)自行编写try-catch-finally语句块来捕获异常。</li>
<li>try语句块若有异常发生时，程序的运行便会中断，抛出”由异常类所产生的对象”，并按下列步骤来运行：<br>（1）抛出的对象如果属catch()括号内所欲捕获的异常类，catch会捕获此异常，然后进到catch语句块内继续运行；<br>（2）无论try语句块是否捕获到异常，或者捕获到的异常是否与catch()括号里的异常类相匹配，最后一定会运行finally语句块里的程序代码；<br>（3）finally块运行结束后，程序转到try-catch-finally语句之后的语句继续运行。</li>
<li>RuntimeException不编写异常处理的程序代码，仍然可以编译成功，它是在程序运行时才有可能发生；而IOException一定要进行捕获处理才可以，它通常用来处理与输入输出有关的操作。</li>
<li>catch()括号内只接收由Throwable类的子类所产生的对象，其他的类均不接收。</li>
<li>抛出异常有下列两种方式：（1）系统自动抛出异常；（2）指定方法抛出异常。</li>
<li>方法中没有使用try-catch语句来处理异常，可在方法声明的头部使用throws语句或在方法内部使用throw语句将它送往上一层调用机构去处理。即如果一个方法可能会抛出异常，则可将处理此异常的try-catch-finally语句写在调用此方法的程序块内。</li>
<li>自动关闭资源语句try-with-resources，只能关闭实现了java.lang.AutoCloseable接口的资源。</li>
</ul>
<h2 id="课后习题-3"><a href="#课后习题-3" class="headerlink" title="课后习题"></a>课后习题</h2><ul>
<li>什么是异常？简述Java语言的异常处理机制。</li>
<li>Throwable类的两个直接子类Error和Exception的功能各是什么？用户可以捕获到的异常是哪个类的异常？</li>
<li>Exception类有何作用？Exception类的每个子类对象代表了什么？</li>
<li>什么是运行时异常？什么是非运行时异常？</li>
<li>抛出异常有哪两种方式？</li>
<li>在捕获异常时，为什么要在catch()括号内有一个变量e？</li>
<li>在异常处理机制中，用catch()括号内的变量e接收异常类对象的步骤有哪些？</li>
<li>在什么情况下，方法的头部必须列出可能抛出的异常？</li>
<li>若try语句结构中有多个catch()子句，这些子句的排列顺序与程序执行效果是否有关？为什么？</li>
<li>什么是抛出异常？系统定义的异常如何抛出？用户自定义的异常又如何抛出？</li>
<li>自动关闭资源语句，为什么只能关闭实现java.lang.AutoCloseable接口的资源？</li>
<li>系统定义的异常与用户自定义的异常有何不同？如何使用这两类异常？</li>
</ul>
<h1 id="第十章-Java语言的输入输出与文件处理"><a href="#第十章-Java语言的输入输出与文件处理" class="headerlink" title="第十章 Java语言的输入输出与文件处理"></a>第十章 Java语言的输入输出与文件处理</h1><h2 id="Java语言的输入和输出"><a href="#Java语言的输入和输出" class="headerlink" title="Java语言的输入和输出"></a>Java语言的输入和输出</h2><h3 id="流的概念"><a href="#流的概念" class="headerlink" title="流的概念"></a>流的概念</h3><p>流(stream)是指计算机各部件之间的数据流动。<br>按照传输方向：输入流、输出流。<br>按照流的内容：字节流（8byte）、字符流（16Unicode）。</p>
<h4 id="输入输出流"><a href="#输入输出流" class="headerlink" title="输入输出流"></a>输入输出流</h4><p><code>数据流(datastream)</code>：把不同类型的输入输出源（键盘、屏幕、文件、网络等）抽象为流，而其中输入或输出的数据。</p>
<p><code>输入流(input stream)</code>：将数据从外设或外存（如键盘、鼠标、文件等）传递到应用程序的流称为输入流。</p>
<p><code>输出流(output stream)</code>：将数据从应用程序传递到外设或外存（如屏幕、打印机、文件等）的流称为输出流。</p>
<img src="/2021/12/25/JAVA%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80-%E7%AC%AC6%E7%89%88%E9%99%88%E5%9B%BD%E5%90%9B2006-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/%E8%BE%93%E5%85%A5%E6%B5%81%E4%B8%8E%E8%BE%93%E5%87%BA%E6%B5%81%E7%A4%BA%E6%84%8F%E5%9B%BE.png" class="" title="输入流与输出流示意图">
<blockquote>
<p>流式输入输出的最大特点是数据的获取和发送是沿着数据序列顺序进行，每一个数据都必须等待排在它前面的数据读入或送出之后才能被读写，每次读写操作处理的都是序列中剩余的未读写数据中的第一个，而不能随意选择输入输出的位置。</p>
</blockquote>
<h4 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h4><p>为了提高数据的传输效率，通常使用<code>缓冲流（bufferedstream）</code>，即为一个流配有一个<code>缓冲区（buffer）</code>，这个缓冲区就是专门用于传送数据的一块内存。</p>
<p>当向一个缓冲流写入数据时，系统将数据发送到缓冲区，而不是直接发送到外部设备。</p>
<p>缓冲流提高了内存与外部设备之间的数据传输效率。</p>
<h3 id="输入输出流类库"><a href="#输入输出流类库" class="headerlink" title="输入输出流类库"></a>输入输出流类库</h3><p>根据输入输出数据类型的不同，输入输出流按处理数据的类型分为两种：一种是<code>字节流（byte stream）</code>；另一种是<code>字符流（character stream）</code>。</p>
<p>字节流：字节流每次读写8位二进制数，由于它只能将数据以二进制的原始方式读写，而不能分解、重组和理解这些数据，所以可以使之变换、恢复到原来的有意义的状态，因此字节流又被称为二进制字节流（binary byte stream）或位流（bits stream）。</p>
<p>字符流：而字符流一次读写16位二进制数，并将其作为一个字符而不是二进制位来处理。</p>
<p>在java.io包中有四个基本类：InputStream、OutputStream及Reader、Writer类，它们分别处理字节流和字符流。</p>
<img src="/2021/12/25/JAVA%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80-%E7%AC%AC6%E7%89%88%E9%99%88%E5%9B%BD%E5%90%9B2006-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81%E5%85%B3%E7%B3%BB.png" class="" title="输入输出流关系">
<img src="/2021/12/25/JAVA%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80-%E7%AC%AC6%E7%89%88%E9%99%88%E5%9B%BD%E5%90%9B2006-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81%E7%9A%84%E7%B1%BB%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%9B%BE.png" class="" title="输入输出流的类层次结构图">
<p>其中InputStream、OutputStream、Reader与Writer是抽象类，用于数据流的输入输出；File是文件类，用于对磁盘文件与文件夹的管理；RandomAccessFile是随机访问文件类，用于实现对磁盘文件的随机读写操作。</p>
<p>在流的输入输出操作中InputStream和OutputStream流类通常用来处理”位流”（<code>bit stream</code>）即字节流，这种流通常被用来读写诸如图片、音频、视频之类的二进制数据，也就是二进制文件，但也可以处理文本文件；而Reader与Writer类则是用来处理”字符流”（<code>character stream</code>），也就是文本文件。</p>
<h2 id="使用InputStream和OutputStream流类"><a href="#使用InputStream和OutputStream流类" class="headerlink" title="使用InputStream和OutputStream流类"></a>使用InputStream和OutputStream流类</h2><p>InputStream和OutputStream流类是Java语言中用来处理以位（bit）为单位的流，它除了可用来处理二进制文件（binary file）的数据之外，也可用来处理文本文件。</p>
<h3 id="基本的输入输出流类"><a href="#基本的输入输出流类" class="headerlink" title="基本的输入输出流类"></a>基本的输入输出流类</h3><h4 id="InputStream流类"><a href="#InputStream流类" class="headerlink" title="InputStream流类"></a>InputStream流类</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">常用方法</th>
<th style="text-align:center">功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public in read()</td>
<td style="text-align:center">从输入流中的当前位置读入一个字节(8b)的二进制数据，然后以此数据为低位字节，配上8个全0的高位字节合成一个16位的整型量(0~255)返回给调用此方法的语句，若输人流中的当前位置没有数据，则返回-1</td>
</tr>
<tr>
<td style="text-align:center">public int read(byte[] b)</td>
<td style="text-align:center">从输人流中的当前位置连续读入多个字节保存在数组b中，同时返回所读到的字节数</td>
</tr>
<tr>
<td style="text-align:center">public int read(byte[] b, int off, int len)</td>
<td style="text-align:center">从输入流中的当前位置连续读入len个字节，从数组b的第off+1个元素位置处开始存放，同时返回所读到的字节数</td>
</tr>
<tr>
<td style="text-align:center">public int available()</td>
<td style="text-align:center">返回输入流中可以读取的字节数</td>
</tr>
<tr>
<td style="text-align:center">public long skip(long n)</td>
<td style="text-align:center">使位置指针从当前位置向后跳过n个字节</td>
</tr>
<tr>
<td style="text-align:center">public void mark(int readlimit)</td>
<td style="text-align:center">在当前位置处做一个标记，并且在输人流中读取readlimit个字节数后该标记失效</td>
</tr>
<tr>
<td style="text-align:center">public void reset()</td>
<td style="text-align:center">将位置指针返回到标记的位置</td>
</tr>
<tr>
<td style="text-align:center">public void close()</td>
<td style="text-align:center">关闭输人流与外设的连接并释放所占用的系统资源</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>当Java程序需要从外设如键盘、磁盘文件等读入数据时，应该创建一个适当类型的输入流对象来完成与该外设的连接 。由于InputStream是抽象类 ，所以程序中创建的输入流对象一 般是InputStream某个子类的对象，通过调用该对象继承的read()方法就可实现对相应外设的输入操作。</p>
</blockquote>
<h4 id="OutputStream流类"><a href="#OutputStream流类" class="headerlink" title="OutputStream流类"></a>OutputStream流类</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">常用方法</th>
<th style="text-align:center">功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public void write(int b)</td>
<td style="text-align:center">将参数b的低位字节写人到输出流</td>
</tr>
<tr>
<td style="text-align:center">public void write(byte[] b)</td>
<td style="text-align:center">将字节数组b中的全部字节按顺序写人到输出流</td>
</tr>
<tr>
<td style="text-align:center">public void write(byte[] b, int off, int len)</td>
<td style="text-align:center">将字节数组b中第off+1个元素开始的len个数据，顺序地写人到输出流</td>
</tr>
<tr>
<td style="text-align:center">public void flush()</td>
<td style="text-align:center">强制清空缓冲区并执行向外设写操作</td>
</tr>
<tr>
<td style="text-align:center">public void close()</td>
<td style="text-align:center">关闭输出流与外设的连接并释放所占用的系统资源</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>当Java程序需要向外设如屏幕、磁盘文件等输出数据时，应该创建一个适当类型的输出流的对象来完成与该外设的连接。</p>
</blockquote>
<h3 id="输入输出流的应用"><a href="#输入输出流的应用" class="headerlink" title="输入输出流的应用"></a>输入输出流的应用</h3><h4 id="文件输入输出流"><a href="#文件输入输出流" class="headerlink" title="文件输入输出流"></a>文件输入输出流</h4><p><code>FileInputStream</code>和<code>FileOutputStream</code>分别是<code>InputStream</code>和<code>OutputStream</code>的直接子类，这两个子类主要是负责完成对本地磁盘文件的顺序输入与输出操作的流。</p>
<ul>
<li>FileInputStream类的构造方法</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">常用方法</th>
<th style="text-align:center">功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public FileInputStream(String name)</td>
<td style="text-align:center">以名为name的文件为数据源建立文件输入流</td>
</tr>
<tr>
<td style="text-align:center">public FileInputStream(File file)</td>
<td style="text-align:center">以文件对象file为数据源建立文件输入流</td>
</tr>
<tr>
<td style="text-align:center">public FileInputStream(FileDescriptor fdObj)</td>
<td style="text-align:center">以文件描述符对象fdObj为输人端建立一个文件输人流</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>FileOutputStream类的构造方法</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">常用方法</th>
<th style="text-align:center">功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public FileOutputStream(String name)</td>
<td style="text-align:center">以指定名字的文件为接收端建立文件输出流</td>
</tr>
<tr>
<td style="text-align:center">public FileOutputStream(String name, boolean append)</td>
<td style="text-align:center">以指定名字的文件为接收端建立文件输出流，并指定写人方式，append为true 时输出字节被写到文件的末尾</td>
</tr>
<tr>
<td style="text-align:center">public FileOutputStream(File file)</td>
<td style="text-align:center">以文件对象file为接收端建立文件输出流</td>
</tr>
<tr>
<td style="text-align:center">public FileOutputStream(FileDescriptor fdObj)</td>
<td style="text-align:center">以文件描述符对象fdObj建立一个文件输出流</td>
</tr>
</tbody>
</table>
</div>
<p><code>FileDescriptor</code>是java.io包中定义的另一个类，该类不能实例化，该类中有三个静态成员：in、out和err，分别对应于标准输入流、标准输出流和标准错误流，利用它们可以在标准输入流和标准输出流上建立文件输入输出流，实现键盘输入或屏幕输出操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建文本文文件myfile.txt，从键盘输入一串字符，然后再读取该文件并将文本文件内容显示在屏幕上。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">App10_1</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">char</span> ch;</span><br><span class="line">		<span class="type">int</span> data;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span>(</span><br><span class="line">			<span class="type">FileInputStream</span> <span class="variable">fin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(FileDescriptor.in);</span><br><span class="line">			<span class="type">FileOutputStream</span> <span class="variable">fout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D:/myfil.txt&quot;</span>);</span><br><span class="line">            )&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;请输入一串字符，并以 # 结束&quot;</span>);</span><br><span class="line">			<span class="keyword">while</span> ((ch = (<span class="type">char</span>)fin.read()) != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">				fout.write(ch);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;文件没有找到!&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span> (</span><br><span class="line">			<span class="type">FileInputStream</span> <span class="variable">fin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:/myfile.txt&quot;</span>);</span><br><span class="line">			<span class="type">FileOutputStream</span> <span class="variable">fout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(FileDescriptor.out);</span><br><span class="line">		)&#123;</span><br><span class="line">			<span class="keyword">while</span> (fin.avilable() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				data = fin.rad();</span><br><span class="line">				fout.writ(data);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//FileInputStream和FileOutputStream实现二进制图像复制</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">APP10_2</span> &#123;</span><br><span class="line">	<span class="keyword">try</span>(</span><br><span class="line">		<span class="type">FileInputStream</span> <span class="variable">fi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test.jpg&quot;</span>);</span><br><span class="line">		<span class="type">FileOutputStream</span> <span class="variable">fo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;test_copy.jpg&quot;</span>);</span><br><span class="line">	) &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;文件大小 = &quot;</span> + fi.available());</span><br><span class="line">		<span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[fi.available()];</span><br><span class="line">		fi.read(b);</span><br><span class="line">		fo.write(b);</span><br><span class="line">		System.out.println(<span class="string">&quot;文件已经被复制&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="顺序输入流"><a href="#顺序输入流" class="headerlink" title="顺序输入流"></a>顺序输入流</h4><p>顺序输入流类SequenceInputStream是InputStream的直接子类，其功能是将多个输入流顺序连接在一起，形成单一的输入数据流，没有对应的输出数据流存在。<br>在进行输入时，顺序输入流依次打开每个输入流并读取数据，在读取完毕后将该流关闭，然后自动切换到下一个输入流。也就是说，由多个输入流构成的顺序输入流，当从一个流中读取数据遇到EOF时，SequenceInputStream将自动转向下一个输入流，直到构成SequenceInputStream类的最后一个输入流读取到EOF时为止。</p>
<ul>
<li>SequenceInputStream类的构造方法</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">构造方法</th>
<th style="text-align:center">功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public SequenceInputStream(Enumeration e)</td>
<td style="text-align:center">创建一个串行输入流，链接枚举对象e中的所有输入流</td>
</tr>
<tr>
<td style="text-align:center">public SequenceInputStream(InputStream s1, InputStream s2)</td>
<td style="text-align:center">创建一个串行输入流，链接输入流s1和s2</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>SequenceInputStream类的常用方法</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">常用方法</th>
<th style="text-align:center">功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public int available()</td>
<td style="text-align:center">返回流中的可读取的字节数</td>
</tr>
<tr>
<td style="text-align:center">public void close()</td>
<td style="text-align:center">关闭输入流</td>
</tr>
<tr>
<td style="text-align:center">public int read()</td>
<td style="text-align:center">从输入流中读取字节，遇到EOF就转向下一输入流</td>
</tr>
<tr>
<td style="text-align:center">public int read(byte[] b, int off, int len)</td>
<td style="text-align:center">将len个数据读到一个字节数组从off开始的位置</td>
</tr>
</tbody>
</table>
</div>
<h4 id="管道输入输出流"><a href="#管道输入输出流" class="headerlink" title="管道输入输出流"></a>管道输入输出流</h4><p>管道字节输入流PipedInputStream和管道字节输出流PipedOutputStream类提供了利用管道方式进行数据输入输出管理的类。</p>
<p>管道流用来将一个程序或线程的输出连接到另外一个程序或线程作为输入，使得相连线程能够通过PipedInputStream和PipedOutputStream流进行数据交换，从而可以实现程序内部线程间的通信或不同程序间的通信。</p>
<p>PipedInputStream是一个通信管道的接收端，它必须与一个作为发送端的PipedOutputStream对象相连；PipedOutputStream是一个通信管道的发送端，它必须与一个作为接收端的PipedInputStream对象相连。</p>
<ul>
<li>构造方法</li>
</ul>
<p>PipedInputStream(PipedOutputStream src)，创建一个管道字节输入流，并将其连接到src指定的管道字节输出流。<br>PipedOutputStream(PipedInputStream src)，创建一个管道字节输出流，并将其连接到src的管道字节输入流。</p>
<ul>
<li>PipedInputStream常用方法</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">常用方法</th>
<th style="text-align:center">功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public int available()</td>
<td style="text-align:center">返回可以读取的字节数</td>
</tr>
<tr>
<td style="text-align:center">public void close()</td>
<td style="text-align:center">关闭管道输入流并释放系统资源</td>
</tr>
<tr>
<td style="text-align:center">public int read()</td>
<td style="text-align:center">从管道输入流中读取下一字节数据</td>
</tr>
<tr>
<td style="text-align:center">public int read(byte[] b, int off, int len)</td>
<td style="text-align:center">从管道输入流读取len字节数据到数组</td>
</tr>
<tr>
<td style="text-align:center">protected coid receive(int b)</td>
<td style="text-align:center">从管道中接受1字节数据</td>
</tr>
<tr>
<td style="text-align:center">public void connect(PipedOutputStream src)</td>
<td style="text-align:center">连接到指定输出流，管道输入流将从该输出流接受数据</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>PipedOutputStream常用方法</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">常用方法</th>
<th style="text-align:center">功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public void close()</td>
<td style="text-align:center">关闭管道输出流并释放系统资源</td>
</tr>
<tr>
<td style="text-align:center">public void connect(PipedInputStream snk)</td>
<td style="text-align:center">连接到指定输入流，管道输出流将从该输入流读取数据</td>
</tr>
<tr>
<td style="text-align:center">public void write(int b)</td>
<td style="text-align:center">写指定字节数据到管道输出流</td>
</tr>
<tr>
<td style="text-align:center">public void wirte(byte[] b, int off, int len)</td>
<td style="text-align:center">从数组off偏移处写len字节数据到管道输出流</td>
</tr>
<tr>
<td style="text-align:center">public void flush()</td>
<td style="text-align:center">刷新输出流并使缓冲区数据全部写出</td>
</tr>
</tbody>
</table>
</div>
<h4 id="过滤输入输出流"><a href="#过滤输入输出流" class="headerlink" title="过滤输入输出流"></a>过滤输入输出流</h4><p>过滤字节输入流类FilterInputStream和过滤字节输出流类FilterOutputStream，分别实现了在数据的读、写操作的同时进行数据处理，它们是InputStream和OutputStream类的直接子类 。</p>
<p>FilterInputStream和FilterOutputStream也是两个抽象类，它们又分别派生出数据输入流类DataInputStream和数据输出流类DataOutputStream等子类。可以按照基本数据理性进行数据读写。</p>
<p>过滤字节输入输出流的主要特点是，过滤字节输入输出流是建立在基本输入输出流之上，并在输入输出数据的同时能对所传输的数据做指定类型或格式的转换，即可实现对二进制字节数据的理解和编码转换。</p>
<img src="/2021/12/25/JAVA%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80-%E7%AC%AC6%E7%89%88%E9%99%88%E5%9B%BD%E5%90%9B2006-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/%E6%B5%81%E7%9A%84%E4%B8%B2%E6%8E%A5%E7%A4%BA%E6%84%8F%E5%9B%BE.png" class="" title="流的串接示意图">
<p>FileInputStream类的对象是1字节输入流，每次输入1字节。与DataInputStream类的对象串接后每次可直接读取一个int(4字节)型数据。</p>
<ul>
<li>构造方法</li>
</ul>
<p>DataInputStream(InputStream in)，建立一个新的数据输入流，从指定的输入流in读数据。<br>DataOutputStream(OutputStream out)，建立一个新的数据输出流，向指定的输出流out写数据。</p>
<ul>
<li>DataInputStream常用方法</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">常用方法</th>
<th style="text-align:center">功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public boolean readBoolean()</td>
<td style="text-align:center">从流中读1字节,若字节值非0返回true,否则返回false</td>
</tr>
<tr>
<td style="text-align:center">public byte readByte()</td>
<td style="text-align:center">从流中读1字节,返回该字节值</td>
</tr>
<tr>
<td style="text-align:center">public char readChar()</td>
<td style="text-align:center">从流中读取a、b2字节,形成Unicode字符(char)((a&lt;&lt;8)  &#124; (b &amp;.0xff))</td>
</tr>
<tr>
<td style="text-align:center">public short readShort()</td>
<td style="text-align:center">从流中读人2字节的short值并返回</td>
</tr>
<tr>
<td style="text-align:center">public int readInt()</td>
<td style="text-align:center">从流中读人4字节的int值并返回</td>
</tr>
<tr>
<td style="text-align:center">public float readFloat()</td>
<td style="text-align:center">从流中读人4字节的float值并返回</td>
</tr>
<tr>
<td style="text-align:center">public long readLong()</td>
<td style="text-align:center">从流中读入8字节的long值并返回</td>
</tr>
<tr>
<td style="text-align:center">public double readDouble()</td>
<td style="text-align:center">从流中读人8字节的double值并返回</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>DataOutputStream常用方法</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">常用方法</th>
<th style="text-align:center">功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public boolean writeBoolean(boollean v)</td>
<td style="text-align:center">若v的值为true,则向流中写人(字节)1,否则写入(字节)0</td>
</tr>
<tr>
<td style="text-align:center">public byte writeByte(int v)</td>
<td style="text-align:center">向流中写人1字节。写人v的最低1字节,其他字节丢弃</td>
</tr>
<tr>
<td style="text-align:center">public char writeChar(int v)</td>
<td style="text-align:center">向流中写人v的最低2字节,其他字节丢弃</td>
</tr>
<tr>
<td style="text-align:center">public short writeShort(int v)</td>
<td style="text-align:center">向流中写人v的最低2字节,其他字节丢弃</td>
</tr>
<tr>
<td style="text-align:center">public int writeInt(int v)</td>
<td style="text-align:center">向流中写人参数v的4字节</td>
</tr>
<tr>
<td style="text-align:center">public float writeFloat(float v)</td>
<td style="text-align:center">向流中写入参数v的4字节</td>
</tr>
<tr>
<td style="text-align:center">public long writeLong(long v)</td>
<td style="text-align:center">向流中写人参数v的8字节</td>
</tr>
<tr>
<td style="text-align:center">public double writeDouble(double v)</td>
<td style="text-align:center">向流中写人参数v的8字节</td>
</tr>
</tbody>
</table>
</div>
<h4 id="标准输入输出流"><a href="#标准输入输出流" class="headerlink" title="标准输入输出流"></a>标准输入输出流</h4><p>当Java程序与外设进行数据交换时，需要先创建一个输入或输出流类的对象，完成与外设的连接。<br>当程序对标准输入输出设备进行操作时，则不需要如此。</p>
<p>为了方便程序对键盘输入和屏幕输出进行操作，Java系统事先在System类中定义了静态流对象System.in和System.out和System.err 。<br>System.in对应于输入流，通常指键盘输入设备 ；<br>System.out对应于输出流，指显示器等信息输出设备；<br>System.err对应于标准错误输出设备，使得程序的运行错误可以有固定的输出位置，通常该对象对应于显示器。</p>
<ul>
<li>标准输入</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;按任一键继续&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="type">char</span> <span class="variable">test</span> <span class="operator">=</span> (<span class="type">char</span>)System.in.read();</span><br><span class="line">&#125; <span class="keyword">catch</span>(IOException e) &#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>标准输出</li>
</ul>
<p>PrintStream类是过滤字节输出流类FilterOutputStream的一个子类，其中定义了向屏幕输送不同类型数据的方法print()和println()。这两个方法的区别是前者输出数据后不换行，后者换行。System.out对应的输出流通常指显示器、打印机或磁盘文件等信息输出设备。</p>
<ul>
<li>标准错误输出</li>
</ul>
<p>由PrintStream类派生的错误流。err使用与out同样的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据流的应用</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App10_4</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] artg)</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">128</span>];</span><br><span class="line">			</span><br><span class="line">			System.out.print(<span class="string">&quot;请输入字符：&quot;</span>);</span><br><span class="line">			<span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> System.in.read(b);</span><br><span class="line">			</span><br><span class="line">			System.out.println(<span class="string">&quot;输入的是：&quot;</span>);</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;count; i++) &#123;</span><br><span class="line">				System.out.print(b[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;count-<span class="number">2</span>; i++) &#123;</span><br><span class="line">				System.out.print((<span class="type">char</span>)b[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">			</span><br><span class="line">			System.out.println(<span class="string">&quot;输入的字符个数为&quot;</span> + count);</span><br><span class="line">			</span><br><span class="line">			<span class="type">Class</span> <span class="variable">InClass</span> <span class="operator">=</span> System.in.getClass();</span><br><span class="line">			<span class="type">Class</span> <span class="variable">OutClass</span> <span class="operator">=</span> System.out.getClass();</span><br><span class="line">			</span><br><span class="line">			System.out.println(<span class="string">&quot;in所在的类是：&quot;</span> + InClass.toString());</span><br><span class="line">			System.out.println(<span class="string">&quot;out所在的类是：&quot;</span> + OutClass.toString());</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123; &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">请输入字符：abc↙</span><br><span class="line">输入的是：</span><br><span class="line">97 98 99 13 10</span><br><span class="line">a b c</span><br><span class="line">输入的字符个数为5</span><br><span class="line">in所在的类是：class java.io.BufferedInputStream</span><br><span class="line">out所在的类是：class java.io.PrintStream</span><br></pre></td></tr></table></figure>
<h2 id="使用Reader和Writer流类"><a href="#使用Reader和Writer流类" class="headerlink" title="使用Reader和Writer流类"></a>使用Reader和Writer流类</h2><p>而Reader和Write类则是用来处理“字符流”的，也就是文本文件。为抽象类。</p>
<ul>
<li>Reader类常用方法</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">常用方法</th>
<th style="text-align:center">功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public int read()</td>
<td style="text-align:center">从输人流中读一个字符</td>
</tr>
<tr>
<td style="text-align:center">public int read(char[] cbuf)</td>
<td style="text-align:center">从输入流中读最多cbuf.length个字符,存人字符数组cbuf中</td>
</tr>
<tr>
<td style="text-align:center">public int read(char[] cbuf, int off, int len)</td>
<td style="text-align:center">从输入流中读最多len个字符,存入字符数组cbuffer中,从off开始的位置</td>
</tr>
<tr>
<td style="text-align:center">public long skip(long n)</td>
<td style="text-align:center">从输人流中最多向后跳n个字符</td>
</tr>
<tr>
<td style="text-align:center">public boolean ready()</td>
<td style="text-align:center">判断流是否做好读的准备</td>
</tr>
<tr>
<td style="text-align:center">public void mark(int readAheadLimit)</td>
<td style="text-align:center">标记输人流的当前位置</td>
</tr>
<tr>
<td style="text-align:center">public boolean markSupported()</td>
<td style="text-align:center">测试输人流是否支持mark</td>
</tr>
<tr>
<td style="text-align:center">public void reset()</td>
<td style="text-align:center">重定位输人流</td>
</tr>
<tr>
<td style="text-align:center">public void close()</td>
<td style="text-align:center">关闭输人流</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>Writer类常用方法</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">常用方法</th>
<th style="text-align:center">功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public void write(int c)</td>
<td style="text-align:center">将单一字符c输出到流中</td>
</tr>
<tr>
<td style="text-align:center">public void wirte(String str)</td>
<td style="text-align:center">将字符串str输出到流中</td>
</tr>
<tr>
<td style="text-align:center">public void write(char[] cbuf)</td>
<td style="text-align:center">将字符数组cbuf输出到流</td>
</tr>
<tr>
<td style="text-align:center">public void write(char[] cbuf, int off, int len)</td>
<td style="text-align:center">将字符数组按指定的格式输出(off表示索引,len表示写入的字符数)到流中</td>
</tr>
<tr>
<td style="text-align:center">public void flush()</td>
<td style="text-align:center">将缓冲区中的数据写到文件中</td>
</tr>
<tr>
<td style="text-align:center">public void close()</td>
<td style="text-align:center">关闭输出流</td>
</tr>
</tbody>
</table>
</div>
<h3 id="使用FileReader类读取文件"><a href="#使用FileReader类读取文件" class="headerlink" title="使用FileReader类读取文件"></a>使用FileReader类读取文件</h3><p>Reader -&gt; InputStreamReader -&gt; FileReader</p>
<ul>
<li>构造方法</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">构造方法</th>
<th style="text-align:center">功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public FileReadeer(String name)</td>
<td style="text-align:center">根据文件名称创建一个可读取的输入流对象</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>使用案例</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App10_5</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="type">char</span>[] c = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">500</span>];</span><br><span class="line">		<span class="keyword">try</span> (</span><br><span class="line">			<span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;D:/test.txt&quot;</span>);</span><br><span class="line">		)&#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> fr.read();</span><br><span class="line">			<span class="type">String</span> <span class="variable">srt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(c, <span class="number">0</span>, num);</span><br><span class="line">			System.out.println(<span class="string">&quot;读取的字符个数为：&quot;</span> + num + <span class="string">&quot;,其内容如下：&quot;</span>);</span><br><span class="line">			System.out.println(str);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用FileWriter类写入文件"><a href="#使用FileWriter类写入文件" class="headerlink" title="使用FileWriter类写入文件"></a>使用FileWriter类写入文件</h3><p>Writer -&gt; OutputStreamWriter -&gt; FileWriter</p>
<ul>
<li>构造方法</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">构造方法</th>
<th style="text-align:center">功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public FileWriter(String filename)</td>
<td style="text-align:center">根据所给文件名创建一个可供写入字符数据的输出流对象，原先的文件会被覆盖</td>
</tr>
<tr>
<td style="text-align:center">public FileWriter(String filename, boolean a)</td>
<td style="text-align:center">同上，但如果a设置为true，则会将数据追加在原先文件的后边</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>使用案例</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App10_6</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="type">FileWirter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;d:\\test.txt&quot;</span>);</span><br><span class="line">		<span class="type">char</span>[] c = &#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;\r&#x27;</span>, <span class="string">&#x27;\n&#x27;</span>&#125;;</span><br><span class="line">		<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;欢迎使用Java!&quot;</span>;</span><br><span class="line">		fw.write(c);</span><br><span class="line">		fw.wirte(str);</span><br><span class="line">		fw.close();	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用BufferedReader类读取文件"><a href="#使用BufferedReader类读取文件" class="headerlink" title="使用BufferedReader类读取文件"></a>使用BufferedReader类读取文件</h3><p>使用BufferedReader类来读取缓冲区中的数据之前，必须先创建FileReader类对象，再以该对象为参数来创建BufferedReader类的对象，然后才可以利用此对象来读取缓冲区中的数据。</p>
<ul>
<li>构造方法</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">构造方法</th>
<th style="text-align:center">功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public BufferReader(Reader in)</td>
<td style="text-align:center">创建缓冲区字符输入流</td>
</tr>
<tr>
<td style="text-align:center">public BufferReader(Reader in, int size)</td>
<td style="text-align:center">创建缓冲区字符输入流，并设置缓冲区大小</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>常用方法</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">常用方法</th>
<th style="text-align:center">功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public int read()</td>
<td style="text-align:center">读取单一字符</td>
</tr>
<tr>
<td style="text-align:center">public int read(char[] cbuf)</td>
<td style="text-align:center">从流中读取字符并写入到字符数组cbuf中</td>
</tr>
<tr>
<td style="text-align:center">public int read(char[] cbuf, int off, int len)</td>
<td style="text-align:center">从流中读取字符存放到字符数组cbuf中(off表示数组下标，len表示读取的字符数)</td>
</tr>
<tr>
<td style="text-align:center">public long skip(long n)</td>
<td style="text-align:center">跳过n个字符不读取</td>
</tr>
<tr>
<td style="text-align:center">public String readLine()</td>
<td style="text-align:center">读取一行字符串</td>
</tr>
<tr>
<td style="text-align:center">public void close()</td>
<td style="text-align:center">关闭流</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>使用案例</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App10_7</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		String thisLine;</span><br><span class="line">		<span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">try</span>(</span><br><span class="line">			<span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;D:/test.txt&quot;</span>);</span><br><span class="line">			<span class="type">BufferReader</span> <span class="variable">bfr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferReader</span>(fr);</span><br><span class="line">		) &#123;</span><br><span class="line">			<span class="keyword">while</span> ((thisLine = bfr.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">				count++;</span><br><span class="line">				Sytem.out.println(thisLine);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">&quot;共读取了&quot;</span> + count + <span class="string">&quot;行&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;错误!&quot;</span> + ioe);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用BufferedWriter类写入文件"><a href="#使用BufferedWriter类写入文件" class="headerlink" title="使用BufferedWriter类写入文件"></a>使用BufferedWriter类写入文件</h3><p>缓冲字符输出流类BufferedWriter继承自Writer类，BufferedWriter类是用来将数据写入到缓冲区中。</p>
<p>缓冲区内的数据最后必须要用flush()方法将缓冲区清空，也就是将缓冲区中的数据全部写到文件内。</p>
<ul>
<li>构造方法</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">构造方法</th>
<th style="text-align:center">功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public BufferWriter(Writer out)</td>
<td style="text-align:center">创建缓冲区字符输出流</td>
</tr>
<tr>
<td style="text-align:center">public BufferWriter(Writer out, int size)</td>
<td style="text-align:center">创建缓冲区字符输出流，并设置缓冲区大小</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>常用方法</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">常用方法</th>
<th style="text-align:center">功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public void write(int c)</td>
<td style="text-align:center">将单一字符写入缓冲区中</td>
</tr>
<tr>
<td style="text-align:center">public void write(char[] cbuf, int off, int len)</td>
<td style="text-align:center">将字符数组cbuf按指定的格式写入到输出缓冲区中(off表示数组下标，len表示写入的字符数)</td>
</tr>
<tr>
<td style="text-align:center">public void write(String str, int off, int len)</td>
<td style="text-align:center">写入字符串(off表示下标，len表示写入的字符数)</td>
</tr>
<tr>
<td style="text-align:center">public void newLine()</td>
<td style="text-align:center">写入回车换行字符</td>
</tr>
<tr>
<td style="text-align:center">public void flush()</td>
<td style="text-align:center">将缓冲区中的数据写到文件中</td>
</tr>
<tr>
<td style="text-align:center">public void close()</td>
<td style="text-align:center">关闭流</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>使用案例</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件复制</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App10_8</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();</span><br><span class="line">		<span class="keyword">try</span> (</span><br><span class="line">			<span class="type">BufferReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;d:/tset.txt&quot;</span>));</span><br><span class="line">			<span class="type">BufferWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;d:/test_copy.txt&quot;</span>));</span><br><span class="line">		) &#123;</span><br><span class="line">			<span class="keyword">while</span> ((str=in.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">				System.out.println(str);</span><br><span class="line">				out.writer(str);</span><br><span class="line">				out.newLine();</span><br><span class="line">			&#125;</span><br><span class="line">			out.flush();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;错误!&quot;</span> + ioe);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="文件的管理与随机访问"><a href="#文件的管理与随机访问" class="headerlink" title="文件的管理与随机访问"></a>文件的管理与随机访问</h2><h3 id="Java语言对文件与文件夹的管理"><a href="#Java语言对文件与文件夹的管理" class="headerlink" title="Java语言对文件与文件夹的管理"></a>Java语言对文件与文件夹的管理</h3><p>在java.io包中定义了一个File类专门用来管理磁盘文件和文件夹，而不负责数据的输入输出。</p>
<h4 id="创建File类的对象"><a href="#创建File类的对象" class="headerlink" title="创建File类的对象"></a>创建File类的对象</h4><ul>
<li>构造方法</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">构造方法</th>
<th style="text-align:center">功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public File(String path)</td>
<td style="text-align:center">用Path参数创建File对象对应的磁盘文件夹或文件夹名及其路径</td>
</tr>
<tr>
<td style="text-align:center">public File(String path, String name)</td>
<td style="text-align:center">以path为路径，以name为文件或文件夹名创建File对象</td>
</tr>
<tr>
<td style="text-align:center">public File(File dir, String name)</td>
<td style="text-align:center">用一个已经存在代表某磁盘文件夹的File对象dir作为文件夹，以name作为文件或文件夹名来创建File对象</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>path参数可以是绝对路径，如“d:\java\myfile\sample.java”，也可相对路径，如“myfile\sample.java”, path参数还可以是磁盘上的某个文件夹。<br>由于不同的操作系统使用的文件夹分隔符不同，如Windows操作系统使用反斜线“\”，UNIX操作系统使用正斜线“/”。<br>File类的一个静态变量File.separator代表不同操作系统下通用路径。＂d:＂+File.separator+＂java＂+File.separator+＂myfile＂</p>
</blockquote>
<h4 id="获取文件或文件夹属性"><a href="#获取文件或文件夹属性" class="headerlink" title="获取文件或文件夹属性"></a>获取文件或文件夹属性</h4><ul>
<li>获取文件或文件夹属性常用方法</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">常用方法</th>
<th style="text-align:center">功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public boolean exists()</td>
<td style="text-align:center">判断文件或文件夹是否存在</td>
</tr>
<tr>
<td style="text-align:center">public boolean isFile()</td>
<td style="text-align:center">判断对象是否代表有效文件</td>
</tr>
<tr>
<td style="text-align:center">public boolean isDirectory()</td>
<td style="text-align:center">判断对象是否代表有效文件夹</td>
</tr>
<tr>
<td style="text-align:center">public String getName()</td>
<td style="text-align:center">返回文件名或文件夹名</td>
</tr>
<tr>
<td style="text-align:center">public String getPath()</td>
<td style="text-align:center">返回文件或文件夹的路径</td>
</tr>
<tr>
<td style="text-align:center">public long length()</td>
<td style="text-align:center">返回文件的字节数</td>
</tr>
<tr>
<td style="text-align:center">public boolean canRead()</td>
<td style="text-align:center">判断文件是否可读</td>
</tr>
<tr>
<td style="text-align:center">public boolean canWrite()</td>
<td style="text-align:center">判断文件是否可写</td>
</tr>
<tr>
<td style="text-align:center">public String[] list()</td>
<td style="text-align:center">将文件夹中所有文件名保存在字符串数组中返回</td>
</tr>
<tr>
<td style="text-align:center">public boolean equals(File f)</td>
<td style="text-align:center">比较两个文件或文件夹是否相同</td>
</tr>
</tbody>
</table>
</div>
<h4 id="文件或文件夹操作"><a href="#文件或文件夹操作" class="headerlink" title="文件或文件夹操作"></a>文件或文件夹操作</h4><ul>
<li>文件或文件夹操作的常用方法</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">常用方法</th>
<th style="text-align:center">功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public boolean renameTo(File newFile)</td>
<td style="text-align:center">将文件重命名成newFile对应的文件名</td>
</tr>
<tr>
<td style="text-align:center">public boolean delete()</td>
<td style="text-align:center">将当前文件删除，若删除成功返回true，否则返回false</td>
</tr>
<tr>
<td style="text-align:center">public boolean mkdir()</td>
<td style="text-align:center">创建当前文件夹的子文件夹，若成功返回ture，否则返回false</td>
</tr>
</tbody>
</table>
</div>
<h3 id="对文件的随机访问"><a href="#对文件的随机访问" class="headerlink" title="对文件的随机访问"></a>对文件的随机访问</h3><p>随机访问文件类RandomAccessFile，它可以实现对文件的随机读写。</p>
<p>RandomAccessFile是有关文件处理中功能齐全、文件访问方法众多的类。RandomAccessFile类用于进行随意位置、任意类型的文件访问，并且在文件的读取方式中支持文件的任意读取而不只是顺序读取。</p>
<ul>
<li>RandomAccessFile构造方法</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">构造方法</th>
<th style="text-align:center">功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public RandomAccessFile(String name, String mode)</td>
<td style="text-align:center">以name来指定随机文件流对象所对应的文件名,以mode表示对文件的访问模式</td>
</tr>
<tr>
<td style="text-align:center">public RandomAccessFile(File file, String mode)</td>
<td style="text-align:center">以file来指定随机文件流对象所对应的文件名，以mode表示对文件的访问模式</td>
</tr>
</tbody>
</table>
</div>
<p>r：只读方式打开文件。<br>rw：读写方式打开文件。</p>
<ul>
<li>RandomAccessFile中用于读取操作的常用方法</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">常用方法</th>
<th style="text-align:center">功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public void close()</td>
<td style="text-align:center">关闭随机访问文件流并释放系统资源</td>
</tr>
<tr>
<td style="text-align:center">public final FileDescriptorgetFD()</td>
<td style="text-align:center">获取文件描述符</td>
</tr>
<tr>
<td style="text-align:center">public long getFilePointer()</td>
<td style="text-align:center">返回文件指针的当前位置</td>
</tr>
<tr>
<td style="text-align:center">public long length()</td>
<td style="text-align:center">返回文件长度</td>
</tr>
<tr>
<td style="text-align:center">public int skipBytes(int n)</td>
<td style="text-align:center">跳过输人流中n个字符,并返回跳过实际的字节数</td>
</tr>
<tr>
<td style="text-align:center">public int read()</td>
<td style="text-align:center">从文件输入流中读取一个字节的数据</td>
</tr>
<tr>
<td style="text-align:center">public int read(byte[] b, int off. int len)</td>
<td style="text-align:center">从文件输人流的当前指针位置开始读取长度为len字节的数据存放到字节数组b中,存放的偏移位置为off。若遇文件结束符，则返回值为-1</td>
</tr>
<tr>
<td style="text-align:center">public final void readFully(byte[] b)</td>
<td style="text-align:center">从文件输入流的当前指针位置开始读取b.length字节的数据存放到字节数组b中。若遇文件结束符，则抛出EOFException类异常</td>
</tr>
<tr>
<td style="text-align:center">public final void readFully(byte[] b, int off, int len)</td>
<td style="text-align:center">从文件输入流的当前指针位置开始读取长度为len字节的数据存放到字节数组b中,存放的偏移位置为off。若遇文件结束符,则抛出EOFException类异常</td>
</tr>
<tr>
<td style="text-align:center">public final boolean readBoolean()</td>
<td style="text-align:center">读取文件中的逻辑值</td>
</tr>
<tr>
<td style="text-align:center">public final byte readByte()</td>
<td style="text-align:center">从文件中读取带符号的字节值</td>
</tr>
<tr>
<td style="text-align:center">public final char readChar()</td>
<td style="text-align:center">从文件中读取一个Unicode字符</td>
</tr>
<tr>
<td style="text-align:center">public final String readLine()</td>
<td style="text-align:center">从文本文件中读取一行</td>
</tr>
<tr>
<td style="text-align:center">public void seek(long pos)</td>
<td style="text-align:center">设置文件指针位置</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>RandomAccessFile类用于写入操作的常用方法</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">常用方法</th>
<th style="text-align:center">功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public void write(int b)</td>
<td style="text-align:center">在文件指针的当前位置写人一个int型数据b</td>
</tr>
<tr>
<td style="text-align:center">public void writeBoolean(boolean v)</td>
<td style="text-align:center">在文件指针的当前位置写人一个boolean型数据v</td>
</tr>
<tr>
<td style="text-align:center">public void writeByte(int v)</td>
<td style="text-align:center">在文件指针的当前位置写人一个字节值，只写v的最低1字节，其他字节丢弃</td>
</tr>
<tr>
<td style="text-align:center">public void writeBytes(String s)</td>
<td style="text-align:center">以字节形式写一个字符串到文件</td>
</tr>
<tr>
<td style="text-align:center">public void writeChar(int v)</td>
<td style="text-align:center">在文件指针的当前位置写入v的最低2字节，其他丢弃</td>
</tr>
<tr>
<td style="text-align:center">public void writeChars(String s)</td>
<td style="text-align:center">以字符形式写一个字符串到文件</td>
</tr>
<tr>
<td style="text-align:center">public void writeDouble(double v)</td>
<td style="text-align:center">在文件当前指针位置写人8字节数据v</td>
</tr>
<tr>
<td style="text-align:center">public void writeFloat(float v)</td>
<td style="text-align:center">在文件当前指针位置写人4字节数据v</td>
</tr>
<tr>
<td style="text-align:center">public void writeInt(int v)</td>
<td style="text-align:center">把整型数作为4字节写人文件</td>
</tr>
<tr>
<td style="text-align:center">public void writeLong(long v)</td>
<td style="text-align:center">把长整型数作为8字节写人文件</td>
</tr>
<tr>
<td style="text-align:center">public void writeShort(int v)</td>
<td style="text-align:center">在文件指针的当前位置写人2字节，只写v的最低2字节，其他字节丢弃</td>
</tr>
<tr>
<td style="text-align:center">public void writeUTF(String str)</td>
<td style="text-align:center">作为UTF格式向文件写入一个字符串</td>
</tr>
</tbody>
</table>
</div>
<h2 id="本章小结-4"><a href="#本章小结-4" class="headerlink" title="本章小结"></a>本章小结</h2><ul>
<li>Java语言是以流的方式来处理输入输出的，其好处是：无论是什么形式的输入输出，只要针对流做处理就可以了。</li>
<li>Java语言中的流是由字符或位组合而成的，可以通过它来读写数据，甚至可以通过它连接数据源，并可以将数据以字符或位组合的形式保存。</li>
<li>以数据的读取或写入而言，流可分为输入流与输出流两种。</li>
<li>可以通过InputStream、OutputStream、Reader与Writer类来处理流的输入输出。</li>
<li>InputStream与OutputStream类及其子类既可用于处理二进制文件也可用于处理文本文件，但主要以处理二进制位流的字节文件为主。</li>
<li>Reader与Writer类是用来处理文本文件的读取和写入操作，通常是以它们的派生类来创建实体对象，再利用它们来处理文本文件读写操作。</li>
<li>BufferedWriter类中的newLine()方法可写入回车换行字符，而且与操作系统无关，使用它可确保程序可跨平台运行。</li>
<li>文件流类File的对象对应系统的磁盘文件或文件夹。</li>
<li>随机访问文件类RandomAccessFile，可以实现对文件的随机读写。</li>
<li>在关闭流对象时，若流对象是在try语句块之前定义的，则流对象的关闭最好是放在finally语句块中；但若流对象是在try语句块中定义，那么关闭流对象的语句可放在try语句块的最后面。</li>
</ul>
<h2 id="课后习题-4"><a href="#课后习题-4" class="headerlink" title="课后习题"></a>课后习题</h2><ul>
<li>什么是数据的输入与输出？</li>
<li>什么是流？Java语言中分为哪两种流？这两种流有何差异？</li>
<li>InputStream、OutputStream、Reader和Writer四个类在功能上有何异同？</li>
<li>利用基本输入输出流实现从键盘上读入一个字符，然后显示在屏幕上。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">D10_4</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> (</span><br><span class="line">			<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">		) &#123;</span><br><span class="line">			<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">			System.out.println(str);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;	</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>顺序流与管道流的区别是什么？</li>
<li>Java语言中定义的三个标准输入输出流是什么？它们对应什么设备？</li>
<li>利用文件输出流创建一个文件file1.txt，写入字符”文件已被成功创建!”，然后用记事本打开该文件，看一下是否正确写入。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">D10_7</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> (</span><br><span class="line">			<span class="type">BufferedWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;c:&quot;</span> + File.separator + <span class="string">&quot;file1.txt&quot;</span>));</span><br><span class="line">		) &#123;</span><br><span class="line">			writer.write(<span class="string">&quot;文件已被成功创建!&quot;</span>);</span><br><span class="line">			writer.flush();		</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;		</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>利用文件输入流打开10.7题中创建的文件file1.txt，读出其内容并显示在屏幕上。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">D10_8</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> (</span><br><span class="line">			<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;c:&quot;</span> + File.separator + <span class="string">&quot;file1.txt&quot;</span>));</span><br><span class="line">		) &#123;</span><br><span class="line">			<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">			System.out.println(str);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>利用文件输入输出流打开10.7题创建的文件file1.txt，然后在文件的末尾追加一行字符串”又添加了一行文字!”。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">D10_9</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> (</span><br><span class="line">			<span class="type">BufferedWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;c:&quot;</span> + File.separator + <span class="string">&quot;file1.txt&quot;</span>, <span class="literal">true</span>));</span><br><span class="line">		) &#123;</span><br><span class="line">			writer.newLine();</span><br><span class="line">			writer.write(<span class="string">&quot;又添加了一行文字!&quot;</span>);</span><br><span class="line">			writer.flush();		</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;		</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>产生15个20~9999的随机整数，然后利用BufferedWriter类将其写入文件file2.txt中之后再读取该文件中的数据并将它们按升序排序。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">D10_10</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">int</span>[] input = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">15</span>];</span><br><span class="line">		<span class="type">Random</span> <span class="variable">rad</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">		System.out.println(<span class="string">&quot;随机生成数组：&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">15</span>; i++) &#123;</span><br><span class="line">			input[i] = rad.nextInt(<span class="number">9979</span>) + <span class="number">20</span>;</span><br><span class="line">			System.out.print(input[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">		&#125;		</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;---------&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span>(</span><br><span class="line">			<span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;c:&quot;</span> + File.separator + <span class="string">&quot;file2.txt&quot;</span>));</span><br><span class="line">		) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">15</span>; i++) &#123;</span><br><span class="line">				bw.write(String.valueOf(input[i]));               </span><br><span class="line">				bw.newLine();</span><br><span class="line">			&#125;</span><br><span class="line">            bw.flush();</span><br><span class="line">            bw.close();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;		</span><br><span class="line">		System.out.println(<span class="string">&quot;随机数组写入文件。&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;---------&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="type">int</span>[] output = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">15</span>];</span><br><span class="line">		<span class="keyword">try</span>(</span><br><span class="line">			<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;c:&quot;</span> + File.separator + <span class="string">&quot;file2.txt&quot;</span>));			</span><br><span class="line">		) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;从文件中读出数组：&quot;</span>);</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">15</span>; i++) &#123;</span><br><span class="line">				output[i] = Integer.parseInt(br.readLine());</span><br><span class="line">                System.out.print(output[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			br.close();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;---------&quot;</span>);</span><br><span class="line">				</span><br><span class="line">		Arrays.sort(output);</span><br><span class="line">		</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后的数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">15</span>; i++) &#123;				</span><br><span class="line">        	System.out.print(output[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Java语言中使用什么类来对文件与文件夹进行管理？</li>
</ul>
<h1 id="第十一章-多线程"><a href="#第十一章-多线程" class="headerlink" title="第十一章 多线程"></a>第十一章 多线程</h1><p>多任务（multitasking）<br>分时（timesharing）</p>
<h2 id="线程的概念"><a href="#线程的概念" class="headerlink" title="线程的概念"></a>线程的概念</h2><p>多线程(multithread)是指在同一个进程中同时存在几个执行体，按几条不同的执行路径同时工作的情况。<br>多线程编程的含义就是可将一个程序任务分成几个可以同时并发执行的子任务。</p>
<h3 id="程序、进程、多任务与多线程"><a href="#程序、进程、多任务与多线程" class="headerlink" title="程序、进程、多任务与多线程"></a>程序、进程、多任务与多线程</h3><h4 id="程序-program"><a href="#程序-program" class="headerlink" title="程序-program"></a>程序-program</h4><p>程序是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。</p>
<h4 id="进程-porcess"><a href="#进程-porcess" class="headerlink" title="进程-porcess"></a>进程-porcess</h4><p>进程是程序的一次执行过程，是系统运行程序的基本单位。</p>
<p>系统运行一个程序即是一个进程从创建、运行到消亡的过程。</p>
<p>每个进程还占有某些系统资源，如CPU时间、内存空间、文件、输入输出设备的使用权等。</p>
<p>每个进程之间是独立的，除非利用某些通信管道来进行通信，或是通过操作系统产生交互作用，否则基本上各进程不知道（不需要，也不应该知道）彼此的存在。</p>
<h4 id="多任务-multi-task"><a href="#多任务-multi-task" class="headerlink" title="多任务-multi task"></a>多任务-multi task</h4><p>多任务是指在一个系统中可以同时运行多个进程，即有多个独立运行的任务，每一个任务对应一个进程。</p>
<p>所谓同时运行的进程，其实是指由操作系统将系统资源分配给各个进程，每个进程在CPU上交替运行。</p>
<h4 id="多线程-thread"><a href="#多线程-thread" class="headerlink" title="多线程-thread"></a>多线程-thread</h4><p>对于完全不相关的程序而言，在同时执行时，彼此的进程也不会做数据交换的工作，而可以完全独立地运行。</p>
<p>进程只是资源分配的单位，线程是处理器调度的基本单位。</p>
<p>一个进程包含一个以上线程，一个进程中的线程只能使用该进程的资源和环境。</p>
<p>线程不能独立存在，必须存在于进程中。</p>
<p>线程也被称为负担轻的进程（light-weight process）</p>
<p><strong>CPU在同一时间段内执行一个程序中的多个程序段来完成工作。</strong></p>
<p><strong>多线程就是同时执行一个以上的线程，执行一个线程不必等待另一个线程执行完后才进行，所有线程都可以发生在同一时刻。但操作系统并没有将多个线程看作多个独立的应用去实现线程的调度和管理以及资源分配。</strong></p>
<blockquote>
<p>多任务是针对操作系统而言的，表示操作系统可以同时运行多个应用程序。<br>多线程是针对一个进程而言的，表示在一个进程内部可以同时执行多个线程。</p>
</blockquote>
<h3 id="线程的状态与生命周期"><a href="#线程的状态与生命周期" class="headerlink" title="线程的状态与生命周期"></a>线程的状态与生命周期</h3>
<h4 id="新建状态-newbron"><a href="#新建状态-newbron" class="headerlink" title="新建状态-newbron"></a>新建状态-newbron</h4><p>线程对象已经被分配了内存空间和其他资源，并已被初始化，但是该线程尚未被调度。此时的线程可以被调度，变成就绪状态。</p>
<h4 id="就绪状态-runnable"><a href="#就绪状态-runnable" class="headerlink" title="就绪状态-runnable"></a>就绪状态-runnable</h4><p>就绪状态也称为可运行状态。</p>
<p>处于新建状态的线程被启动后，将进入线程队列排队等待CPU资源，此时它已具备了运行的条件，也就是处于就绪状态。</p>
<p>原来处于阻塞状态的线程被解除阻塞后也将进入就绪状态。</p>
<h4 id="执行状态-running"><a href="#执行状态-running" class="headerlink" title="执行状态-running"></a>执行状态-running</h4><p>每一个Thread类及其子类的对象都有一个重要的run()方法，该方法定义了这一类线程的操作和功能。当线程对象被调度执行时，它将自动调用本对象的run()方法，从该方法的第一条语句开始执行，一直到执行完毕。</p>
<p>处于执行状态的线程在下列情况下将让出CPU的控制权：</p>
<ul>
<li>线程执行完毕</li>
<li>有比当前线程优先级更高的线程处于就绪状态</li>
<li>线程主动睡眠一段时间</li>
<li>线程在等待某一资源</li>
</ul>
<h4 id="阻塞状态-blocked"><a href="#阻塞状态-blocked" class="headerlink" title="阻塞状态-blocked"></a>阻塞状态-blocked</h4><p>一个正在执行的线程如果在某些特殊情况下，将让出CPU并暂时中止自己的执行，线程处于这种不可执行的状态被称为阻塞状态。</p>
<p>下边两种情况可以使得一个线程进入阻塞状态：</p>
<ul>
<li>调用sleep()或yield()方法</li>
<li>二是为等待一个条件变量，线程调用wait()方法；</li>
<li>三是该线程与另一线程join()在一起。</li>
</ul>
<p>一个线程被阻塞时它不能进入排队队列，只有当引起阻塞的原因被消除时，线程才可以转入就绪状态，重新进到线程队列中排队等待CPU资源，以便从原来的暂停处继续执行。<br>处于阻塞状态的线程通常需要由某些事件才能唤醒，至于由什么事件唤醒该线程，则取决于其阻塞的原因。<br>处于睡眠状态的线程必须被阻塞一段固定的时间，当睡眠时间结束时就变成就绪状态；因等待资源或信息而被阻塞的线程则需要由一个外来事件唤醒。</p>
<h4 id="消亡状态-dead"><a href="#消亡状态-dead" class="headerlink" title="消亡状态-dead"></a>消亡状态-dead</h4><p>处于消亡状态的线程不具有继续执行的能力。</p>
<p>线程消亡的原因：</p>
<ul>
<li>正常运行的线程完成了它的全部工作，即执行完了run()方法的最后一条语句并退出；</li>
<li>当进程因故停止运行时，该进程中的所有线程将被强行终止。</li>
</ul>
<p>当线程处于消亡状态、并且没有该线程对象的引用时，垃圾回收器会从内存中删除该线程对象。</p>
<h3 id="线程的优先级与调度"><a href="#线程的优先级与调度" class="headerlink" title="线程的优先级与调度"></a>线程的优先级与调度</h3><h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><p>在多线程系统中，每个线程都被赋予一个执行优先级。优先级决定了线程被CPU执行的优先顺序。</p>
<p>Java语言中线程的优先级从低到高以整数1~10表示，共分为10级。<br><code>MIN_PRIORITY</code>：最小优先级，1。<br><code>MAX_PRIORITY</code>：最高优先级，10。<br><code>NORM_PRIORITY</code>：普通优先级，5。</p>
<p>对应一个新建的线程，系统会遵循如下的原则为其指定优先级。<br>（1）新建线程将继承创建它的父线程的优先级。父线程是指执行创建新线程对象语句所在的线程，它可能是程序的主线程，也可能是某一个用户自定义的线程。<br>（2）一般情况下，主线程具有普通优先级。</p>
<p><code>setPriority()</code>方法可以设置改变线程的优先级。</p>
<h4 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h4><p>调度就是指在各个线程之间分配CPU资源。<br>线程调度有两种模型：分时模型和抢占模型。</p>
<p><code>分时模型</code>：</p>
<p>CPU资源是按照时间片来分配的，获得CPU资源的线程只能在指定的时间片内执行，一旦时间片使用完毕，就必须把CPU让给另一个处于就绪状态的线程，线程本身不会让出CPU。</p>
<p><code>强占模型</code>：</p>
<p>当前活动的线程一旦获得执行权，将一直执行下去，直到执行完或由于某种原因主动放弃执行权。<br>高优先级的线程应该不时地主动进入”睡眠”状态。</p>
<h2 id="Java的Thread线程类与Runnable接口"><a href="#Java的Thread线程类与Runnable接口" class="headerlink" title="Java的Thread线程类与Runnable接口"></a>Java的Thread线程类与Runnable接口</h2><p>实现多线程的方法有两种：继承java.lang包中的Thread类；用户在定义自己的类中实现Runnable接口。</p>
<h3 id="利用Thread类的子类来创建线程"><a href="#利用Thread类的子类来创建线程" class="headerlink" title="利用Thread类的子类来创建线程"></a>利用Thread类的子类来创建线程</h3><ul>
<li>Thread类的构造方法</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">构造方法</th>
<th style="text-align:center">功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public Thread()</td>
<td style="text-align:center">创建一个线程对象,此线程对象的名称是”Thread-n”的形式，其中n是一个整数。使用这个构造方法,必须创建Thread类的一个子类并覆盖其run()方法</td>
</tr>
<tr>
<td style="text-align:center">public Thread(String name)</td>
<td style="text-align:center">创建一个线程对象,参数name指定了线程的名称</td>
</tr>
<tr>
<td style="text-align:center">public Thread(Runnable target)</td>
<td style="text-align:center">创建一个线程对象,此线程对象的名称是”Thread-n”的形式,其中n是一个整数。参数target的run()方法将被线程对象调用,作为其执行代码</td>
</tr>
<tr>
<td style="text-align:center">public Thread(Runnable target, String name)</td>
<td style="text-align:center">功能同上,参数target的run()方法将被线程对象调用,作为其执行代码。参数name指定了新创建线程的名称</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>Thread类的常用方法</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">构造方法</th>
<th style="text-align:center">功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public static Thread currentThread()</td>
<td style="text-align:center">返回当前正在执行的线程对象</td>
</tr>
<tr>
<td style="text-align:center">public final String getName()</td>
<td style="text-align:center">返回线程的名称</td>
</tr>
<tr>
<td style="text-align:center">public void start()</td>
<td style="text-align:center">使该线程由新建状态变为就绪状态。如果该线程已经是就绪状态,则产生IllegalStateException异常</td>
</tr>
<tr>
<td style="text-align:center">public void run()</td>
<td style="text-align:center">线程应执行的任务</td>
</tr>
<tr>
<td style="text-align:center">public final boolean isAlive()</td>
<td style="text-align:center">如果线程处于就绪、阻塞或运行状态,则返回true；如果线程处于新建且没有启动的状态，或已经结束，则返回false</td>
</tr>
<tr>
<td style="text-align:center">public void interrupt()</td>
<td style="text-align:center">当线程处于就绪状态或执行状态时,给该线程设置中断标志；一个正在执行的线程让睡眠线程调用该方法,则可导致睡眠线程发生InterruptedException异常而唤醒自己,从而进入就绪状态</td>
</tr>
<tr>
<td style="text-align:center">public static boolean isInterrupted()</td>
<td style="text-align:center">判断该线程是否被中断,若是返回true，否则返回false</td>
</tr>
<tr>
<td style="text-align:center">public final void join()</td>
<td style="text-align:center">暂停当前线程的执行,等待调用该方法的线程结束后再继续执行本线程</td>
</tr>
<tr>
<td style="text-align:center">public final int getPriority()</td>
<td style="text-align:center">返回线程的优先级</td>
</tr>
<tr>
<td style="text-align:center">public final void setPriority(int newPriority)</td>
<td style="text-align:center">设置线程优先级。如果当前线程不能修改这个线程,则产生SecurityException异常。如果参数不在所要求的优先级范围内,则产生llegalArgumentException异常</td>
</tr>
<tr>
<td style="text-align:center">public static void sleep(long millis)</td>
<td style="text-align:center">为当前执行的线程指定睡眠时间。参数millis是线程睡眠的毫秒数。如果这个线程已经被别的线程中断,则产生InterruptedException异常</td>
</tr>
<tr>
<td style="text-align:center">public static void yield()</td>
<td style="text-align:center">暂停当前线程的执行,但该线程仍处于就绪状态,不转为阻塞状态。该方法只给同优先级线程以执行的机会</td>
</tr>
</tbody>
</table>
</div>
<p>要在Thread的子类里激活线程，必须做好以下两件事情：</p>
<ul>
<li>此类必须是继承自Thread类；</li>
<li>线程所要执行的代码必须写在run()方法内。</li>
</ul>
<p>run()方法是线程执行的起点，必须通过定义run()方法来为线程提供代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class 类名 <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">	类里的成员变量;</span><br><span class="line">	类里的成员方法;</span><br><span class="line">	修饰符 run() &#123;</span><br><span class="line">		线程的代码</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>run()方法规定了线程要执行的任务，但一般不是直接调用run()方法，而是通过线程的start()方法来启动线程。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用Thread类的子类来创建线程</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String who;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(String str)</span> &#123;</span><br><span class="line">		who = str;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				sleep((<span class="type">int</span>)(<span class="number">1000</span>*Math.random()));</span><br><span class="line">			&#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">				System.out.println(who + <span class="string">&quot;正在运行!&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App11_1</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">MyThread</span> <span class="variable">you</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;你&quot;</span>);</span><br><span class="line">		<span class="type">MyThread</span> <span class="variable">she</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;她&quot;</span>);</span><br><span class="line">		you.start();</span><br><span class="line">		she.start();</span><br><span class="line">		System.out.println(<span class="string">&quot;主方法main()运行结束!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">主方法main()运行结束!</span><br><span class="line">你正在运行!</span><br><span class="line">她正在运行!</span><br><span class="line">你正在运行!</span><br><span class="line">你正在运行!</span><br><span class="line">她正在运行!</span><br><span class="line">她正在运行!</span><br><span class="line">你正在运行!</span><br><span class="line">她正在运行!</span><br><span class="line">她正在运行!</span><br><span class="line">你正在运行!</span><br></pre></td></tr></table></figure>
<blockquote>
<p>main()方法本身也是一个线程，</p>
</blockquote>
<h3 id="用Runnable接口来创建线程"><a href="#用Runnable接口来创建线程" class="headerlink" title="用Runnable接口来创建线程"></a>用Runnable接口来创建线程</h3><p>Runnable接口是Java语言中实现线程的接口，定义在java.lang包中，其中只提供了一个抽象方法run()的声明。</p>
<p>但是Runnable接口并没有任何对线程的支持，还必须创建Thread类的实例，这一点通过Thread(Runnable target)类的构造方法来实现。</p>
<p>除了利用Thread类的子类创建线程外，另一种就是直接利用Runnable接口和线程的构造方法Thread(Runnable target)来创建线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用Runnable接口来创建线程</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String who;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(String str)</span> &#123;</span><br><span class="line">		who = str;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">try</span>&#123;</span><br><span class="line">				Thread.sleep((<span class="type">int</span>)(<span class="number">1000</span>*Math.random()));	<span class="comment">//sleep要声明Thread</span></span><br><span class="line">			&#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">				System.out.println(who + <span class="string">&quot;正在运行!&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(who + <span class="string">&quot;正在运行!&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App11_2</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">MyThread</span> <span class="variable">you</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;你&quot;</span>);</span><br><span class="line">		<span class="type">MyThread</span> <span class="variable">she</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;她&quot;</span>);</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(you);</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(she);</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App11_3</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">MyThread</span> <span class="variable">you</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;你&quot;</span>);</span><br><span class="line">		<span class="type">MyThread</span> <span class="variable">she</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;她&quot;</span>);</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(you);</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(she);</span><br><span class="line">		</span><br><span class="line">		t1.start();</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			you.join();</span><br><span class="line">		&#125; <span class="keyword">catch</span>(InterruptedException e) &#123;		</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		t2.start();</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			she.join();</span><br><span class="line">		&#125; <span class="keyword">catch</span>(InterruptedException e) &#123;		</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;主方法main()运行结束!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当某一线程调用<code>join()</code>方法时，则其他线程会等到该线程结束后才开始执行。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">你正在运行!</span><br><span class="line">你正在运行!</span><br><span class="line">你正在运行!</span><br><span class="line">你正在运行!</span><br><span class="line">你正在运行!</span><br><span class="line">她正在运行!</span><br><span class="line">她正在运行!</span><br><span class="line">她正在运行!</span><br><span class="line">她正在运行!</span><br><span class="line">她正在运行!</span><br><span class="line">主方法main()运行结束!</span><br></pre></td></tr></table></figure>
<blockquote>
<p>直接继承Thread类的优点是编写简单，可以直接操纵线程；缺点是若继承Thread类，就不能再继承其他类。<br>使用Runnable接口的特点是：可以将Thread类与所要处理的任务的类分开，形成清晰的模型；还可以从其他类继承，从而实现多重继承的功能。</p>
</blockquote>
<ul>
<li>获取线程中的名字</li>
</ul>
<p>若直接使用继承Thread类的子类：在类中this即指当前线程；<br>若是使用实现Runnable接口的类：要在此类中获得当前线程的引用，必须使用Thread.currentThread()方法。</p>
<p>当可运行对象包含线程对象时，即线程对象是可运行对象的成员时，则在run()方法中可以通过调用Thread.currentThread()方法来获得正在运行的线程的引用。<br>当可运行对象不包含线程对象时，在可运行对象run()方法中需要使用语句Thread.currentThread().getName()来返回当前正在运行线程的名字。</p>
<h3 id="线程间的数据共享"><a href="#线程间的数据共享" class="headerlink" title="线程间的数据共享"></a>线程间的数据共享</h3><p>同一进程的多个线程间可以共享相同的内存单元，并可利用这些共享单元来实现数据交换、实时通信和必要的同步操作。</p>
<p>对于同一可运行对象的多个线程，可运行对象的成员变量自然就是这些线程共享的数据单元。</p>
<p>使用Runnable接口可以轻松实现多个线程共享相同数据，只要用同一可运行对象作为参数创建多个线程就可以了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用Thread子类程序来模拟航班售票系统，实现3个售票窗口发售某次航班的10张机票，一个售票窗口用一个线程来表示。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TrheadSale</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(tickets&gt;<span class="number">0</span>) &#123;</span><br><span class="line">				System.out.println(<span class="built_in">this</span>.getNmae()+<span class="string">&quot; 售机票第&quot;</span> + tickets-- + <span class="string">&quot;号&quot;</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				System.exit(<span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App11_4</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">ThreadSale</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadSale</span>();</span><br><span class="line">		<span class="type">ThreadSale</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadSale</span>();</span><br><span class="line">		<span class="type">ThreadSale</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadSale</span>();</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">		t3.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Thread-0 售机票第10号</span><br><span class="line">Thread-0 售机票第9号</span><br><span class="line">Thread-2 售机票第10号</span><br><span class="line">Thread-2 售机票第9号</span><br><span class="line">Thread-2 售机票第8号</span><br><span class="line">Thread-2 售机票第7号</span><br><span class="line">Thread-2 售机票第6号</span><br><span class="line">Thread-2 售机票第5号</span><br><span class="line">Thread-0 售机票第8号</span><br><span class="line">Thread-1 售机票第10号</span><br><span class="line">Thread-2 售机票第4号</span><br><span class="line">Thread-0 售机票第7号</span><br><span class="line">Thread-0 售机票第6号</span><br><span class="line">Thread-0 售机票第5号</span><br><span class="line">Thread-2 售机票第3号</span><br><span class="line">Thread-1 售机票第9号</span><br><span class="line">Thread-0 售机票第4号</span><br><span class="line">Thread-0 售机票第3号</span><br><span class="line">Thread-0 售机票第2号</span><br><span class="line">Thread-0 售机票第1号</span><br><span class="line">Thread-2 售机票第2号</span><br><span class="line">Thread-1 售机票第8号</span><br><span class="line">Thread-1 售机票第7号</span><br><span class="line">Thread-1 售机票第6号</span><br><span class="line">Thread-2 售机票第1号</span><br><span class="line">Thread-1 售机票第5号</span><br><span class="line">Thread-1 售机票第4号</span><br><span class="line">Thread-1 售机票第3号</span><br><span class="line">Thread-1 售机票第2号</span><br><span class="line">Thread-1 售机票第1号</span><br></pre></td></tr></table></figure>
<p>创建了三个售票口对象分开分线程卖票，tickets并不共享</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用Runnable接口程序来模拟航班售票系统，利用同一可运行对象实现3个售票窗口发售某次航班的10张机票，一个售票窗口用一个线程来表示。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadSale</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 售机票第&quot;</span> + tickets-- + <span class="string">&quot;号&quot;</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				System.exit(<span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App11_4</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">ThreadSale</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadSale</span>();</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(t, <span class="string">&quot;第1售票窗口&quot;</span>);</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(t, <span class="string">&quot;第2售票窗口&quot;</span>);</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(t, <span class="string">&quot;第3售票窗口&quot;</span>);</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">		t3.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">第1售票窗口售机票第10号</span><br><span class="line">第3售票窗口售机票第9号</span><br><span class="line">第2售票窗口售机票第8号</span><br><span class="line">第1售票窗口售机票第7号</span><br><span class="line">第3售票窗口售机票第6号</span><br><span class="line">第3售票窗口售机票第3号</span><br><span class="line">第3售票窗口售机票第2号</span><br><span class="line">第2售票窗口售机票第5号</span><br><span class="line">第1售票窗口售机票第4号</span><br><span class="line">第3售票窗口售机票第1号</span><br></pre></td></tr></table></figure>
<p>即每个线程调用的是同一个ThreadSale对象中的run()方法，访问的是同一个对象中的变量tickets，这种情况下变量tickets才是共享的资源。</p>
<p>Runnable接口适合处理多线程访问同一资源的情况，并且可以避免由于Java语言的单继承性带来的局限。</p>
<h2 id="多线程的同步控制"><a href="#多线程的同步控制" class="headerlink" title="多线程的同步控制"></a>多线程的同步控制</h2><p>当一个线程对共享的数据进行操作时，应使之成为一个”原子操作”，即在没有完成相关操作之前，<br>不允许其他线程打断它，否则就会破坏数据的完整性，必然会得到错误的处理结果，这就是线程的同步。</p>
<p><code>线程间互斥</code>：所以说被多个线程共享的数据在同一时刻只允许一个线程处于操作之中。</p>
<p>线程执行过程中，在执行有关的若干个动作时，没有能够保证独占相关的资源，而是在对该资源进行处理时又被其他线程的操作打断或干扰而引起的。</p>
<p><code>线程同步</code>：必须保证线程在一个完整的操作所有动作的执行过程中，都占有相关资源而不被打断，这就是线程同步的概念。</p>
<p><code>临界资源</code>、<code>同步资源</code>：多线程共享的资源或数据。<br><code>临界代码</code>、<code>临界区</code>：每个线程中访问临界资源的那一段代码。<br><code>临界资源</code>：在一个时刻只能被一个线程访问的资源<br><code>临界区</code>：访问临界资源的那段代码</p>
<p>在Java语言中每个对象都有一个”互斥锁”与之相连。当线程A获得了一个对象的互斥锁后，线程B若也想获得该对象的互斥锁，就必须等待线程A完成规定的操作并释放出互斥锁后，才能获得该对象的互斥锁，并执行线程B中的操作。</p>
<p>为了保证互斥，Java语言使用synchronized关键字来标识同步的资源，这里的资源可以是一种类型的数据，也就是对象，也可以是一个方法，还可以是一段代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同步语句</span></span><br><span class="line">Synchronized(对象) &#123;</span><br><span class="line">	临界代码段</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同步方法1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> 返回类型 方法名() &#123;</span><br><span class="line">	方法体</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同步方法2</span></span><br><span class="line"><span class="keyword">public</span> 返回类型 方法名() &#123;</span><br><span class="line">	<span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">		方法体</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>synchronized的功能是：首先判断对象或方法的互斥锁是否在，若在就获得互斥锁，然后就可以执行紧随其后的临界代码段或方法体；如果对象或方法的互斥锁不在（已被其他线程拿走），就进入等待状态，直到获得互斥锁。</p>
<p>（1）synchronized锁定的通常是临界代码。由于所有锁定同一个临界代码的线程之间在synchronized代码块上是互斥的，也就是说，这些线程的synchronized代码块之间是串行执行的，不再是互相交替穿插并发执行，因而保证了synchronized代码块操作的原子性。<br>（2）synchronized代码块中的代码数量越少越好，包含的范围越小越好，否则就会失去多线程并发执行的很多优势。<br>（3）若两个或多个线程锁定的不是同一个对象，则它们的synchronized代码块可以互相交替穿插并发执行。<br>（4）所有的非synchronized代码块或方法，都可自由调用。如线程A获得了对象的互斥锁，调用对象的synchronized代码块，其他线程仍然可以自由调用该对象的所有非synchronized方法和代码。<br>（5）任何时刻，一个对象的互斥锁只能被一个线程所拥有。<br>（6）只有当一个线程执行完它所调用对象的所有synchronized代码块或方法时，该线程才会释放这个对象的互斥锁。<br>（7）临界代码中的共享变量应定义为private型。否则，其他类的方法可能直接访问和操作该共享变量，这样synchronized的保护就失去了意义。<br>（8）由于(7)的原因，只能用临界代码中的方法访问共享变量。故锁定的对象通常是this，即通常格式都是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;…&#125;</span><br></pre></td></tr></table></figure>
<p>（9）一定要保证，所有对临界代码中共享变量的访问与操作均在synchronized代码块中进行。<br>（10）对于一个static型的方法，即类方法，要么整个方法是synchronized，要么整个方法不是synchronized。<br>（11）如果synchronized用在类声明中，则表示该类中的所有方法都是synchronized的。</p>
<h2 id="线程之间的通信"><a href="#线程之间的通信" class="headerlink" title="线程之间的通信"></a>线程之间的通信</h2><p>java.lang.Object类的wait()、notify()和notifyAll()等方法为线程间的通信提供了有效手段。</p>
<ul>
<li>Object类中用于线程间通信的常用方法</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">常用方法</th>
<th style="text-align:center">功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public final void wait()</td>
<td style="text-align:center">如果一个正在执行同步代码(synehronized)的线程A执行了wait()调用(在对象x上)，该线程暂停执行而进入对象x的等待队列，并释放已获得的对象x的互斥锁。线程A要一直等到其他线程在对象x上调用notify( )或notifyAll()方法，才能够在重新获得对象x的互斥锁后继续执行(从wait()语句后继续执行)</td>
</tr>
<tr>
<td style="text-align:center">public void notify()</td>
<td style="text-align:center">唤醒正在等待该对象互斥锁的第一个线程</td>
</tr>
<tr>
<td style="text-align:center">public void notifyAll()</td>
<td style="text-align:center">唤醒正在等待该对象互斥锁的所有线程，具有最高优先级的线程首先被唤醒并执行</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>wait()、notify()和notifyAll()只能在同步代码块里调用。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两个线程模拟存票、售票古城，但要求每存入一张票，就售出一张票，售出后，再存入，直至售完为止。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tickets</span> &#123;</span><br><span class="line">	<span class="keyword">protected</span> <span class="type">int</span> size;	<span class="comment">//总票数</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;	<span class="comment">//票号</span></span><br><span class="line">	<span class="type">boolean</span> <span class="variable">available</span> <span class="operator">=</span> <span class="literal">false</span>;	<span class="comment">//是否有票可售</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Tickets</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.size = size;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">()</span> &#123;	<span class="comment">//同步方法存票</span></span><br><span class="line">		<span class="keyword">if</span>(available) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				wait();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;			</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;存入第【&quot;</span> + (++number) + <span class="string">&quot;】号票&quot;</span>);</span><br><span class="line">		available = <span class="literal">true</span>;</span><br><span class="line">		notify();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123;	<span class="comment">//同步方法取票</span></span><br><span class="line">	<span class="keyword">if</span>(available) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				wait();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;			</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;售出第【&quot;</span> + (++number) + <span class="string">&quot;】号票&quot;</span>);</span><br><span class="line">		available = <span class="literal">false</span>;</span><br><span class="line">		notify();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (number == size) &#123;	<span class="comment">//售完最后一张票后，设置一个结束标志</span></span><br><span class="line">			number = size + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;	<span class="comment">//存票</span></span><br><span class="line">	<span class="type">Tickets</span> <span class="variable">t</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(Tickets t)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.t = t;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">while</span>(t.number &lt; t.size) &#123;</span><br><span class="line">			t.put();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;	<span class="comment">//售票</span></span><br><span class="line">	<span class="type">Tickets</span> <span class="variable">t</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(Tickets t)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.t = t;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">while</span>(t.number &lt;= t.size) &#123;</span><br><span class="line">			t.sell();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App11_8</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Tickets</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tickets</span>(<span class="number">10</span>);</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Producer</span>(t).start();</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Consumer</span>(t).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="本章小结-5"><a href="#本章小结-5" class="headerlink" title="本章小结"></a>本章小结</h2><ul>
<li>线程(thread)是指程序的运行流程。多线程机制可以同时运行多个程序块，使程序运行的效率变得更高，也可以克服传统程序语言所无法设计的问题。</li>
<li>多任务与多线程是两个不同的概念。多任务是针对操作系统而言的，表示操作系统可以同时运行多个应用程序；而多线程是针对一个程序而言的，表示在一个程序内部可以同时执行多个线程。</li>
<li>创建线程有两种方法：一种是继承java.lang包中的Thread类；另一种是用户在定义自己的类中实现Runnable接口。</li>
<li>run()方法给出了线程要执行的任务。若是派生自Thread类，必须把线程的程序代码编写在run()方法内，实现覆盖操作；若是实现Runnable接口，必须在实现Runnable接口的类中定义run()方法。</li>
<li>如果在类中要激活线程，必须先做好下列两件事情：①此类必须是派生自Thread类或实现Runnable接口，使自己成为它的子类；②线程的任务必须写在run()方法内。</li>
<li>每一个线程，在其创建和消亡之前，均会处于下列五种状态之一：新建状态、就绪状态、运行状态、阻塞状态和消亡状态。</li>
<li>阻塞状态的线程一般情况下可由下列情况所产生：(1)该线程调用对象的wait()方法；(2)该线程本身调用了sleep()方法；(3)该线程和另一个线程join()在一起；(4)有优先级更高的线程处于就绪状态。</li>
<li>解除阻塞的原因有：(1)如果线程是由调用对象的wait()方法所阻塞的，则该对象的notify()方法被调用时可解除阻塞；(2)线程进入睡眠(sleep)状态，但指定的睡眠时间到了。</li>
<li>Thread类中的sleep()方法可以用来控制线程睡眠时间，睡眠时间的长短全由sleep()方法中的参数而定，单位为1/1000s。</li>
<li>线程在运行时，因不需要外部的数据或方法，就不必关心其他线程的状态或行为，这样的线程称为独立、不同步的或是异步执行的。</li>
<li>被多个线程共享的数据在同一时刻只允许一个线程处于操作之中，这就是同步控制。</li>
<li>当一个线程对共享的数据进行操作时，在没有完成相关操作之前，应使之成为一个”原子操作”，即不允许其他线程打断它，否则可能会破坏数据的完整性，而得到错误的处理结果。</li>
<li>synchronized锁定的是一个具体对象，通常是临界区对象。所有锁定同一个对象的线程之间，在synchronized代码块上是互斥的，也就是说，这些线程的synchronized代码块之间是串行执行的，不再是互相交替穿插并发执行，因而保证了synchronized代码块操作的原子性。</li>
<li>由于所有锁定同一个对象的线程之间，在synchronized代码块上是互斥的，这些线程的synchronized代码块之间是串行执行的，故synchronized代码块中的代码数量越少越好，包含的范围越小越好，否则多线程就会失去很多并发执行的优势。</li>
<li>任何时刻，一个对象的互斥锁只能被一个线程所拥有。</li>
<li>只有当一个线程执行完它所调用对象的所有synchronized代码块或方法时，该线程才会自动释放这个对象的互斥锁。</li>
<li>一定要保证，所有对临界区共享变量的访问与操作均在synchronized代码块中进行。</li>
</ul>
<h2 id="课后习题-5"><a href="#课后习题-5" class="headerlink" title="课后习题"></a>课后习题</h2><ul>
<li>简述线程的基本概念。程序、进程、线程的关系是什么？</li>
<li>什么是多线程？为什么程序的多线程功能是必要的？</li>
<li>多线程与多任务的差异是什么？</li>
<li>线程有哪些基本状态？这些状态是如何定义的？</li>
<li>Java程序实现多线程有哪两个途径？</li>
<li>在什么情况下，必须以类实现Runnable接口来创建线程？</li>
<li>什么是线程的同步？程序中为什么要实现线程的同步？是如何实现同步的？</li>
<li>假设某家银行可接受顾客的存款，每进行一次存款，便可计算出存款的总额。现有两名顾客，每人分三次，每次存入100元钱。试编程来模拟顾客的存款操作。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bank</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Bank</span><span class="params">(<span class="type">int</span> money)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.money = money;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;存入&quot;</span> + number + <span class="string">&quot;元&quot;</span>);</span><br><span class="line">		<span class="built_in">this</span>.money += number;</span><br><span class="line">		System.out.println(<span class="string">&quot;银行剩余&quot;</span> + <span class="built_in">this</span>.money + <span class="string">&quot;元&quot;</span>);</span><br><span class="line">		</span><br><span class="line">        notify();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (number &lt;= <span class="built_in">this</span>.money) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            System.out.println(<span class="string">&quot;取出&quot;</span> + number + <span class="string">&quot;元&quot;</span>);</span><br><span class="line">            <span class="built_in">this</span>.money -= number;</span><br><span class="line">            System.out.println(<span class="string">&quot;银行剩余&quot;</span> + <span class="built_in">this</span>.money + <span class="string">&quot;元&quot;</span>);</span><br><span class="line">            </span><br><span class="line">        	notify();</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">	<span class="type">Bank</span> <span class="variable">b</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(String name, Bank b)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="built_in">this</span>.b = b;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;顾客&quot;</span> + name);</span><br><span class="line">			b.put(<span class="number">100</span>);</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">D11_8</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Bank</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bank</span>(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Consumer</span>(<span class="string">&quot;No1&quot;</span>, b).start();</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Consumer</span>(<span class="string">&quot;No2&quot;</span>, b).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">HibisciDai</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://hibiscidai.com/2021/12/25/JAVA程序设计基础-第6版陈国君2006-学习笔记2/">http://hibiscidai.com/2021/12/25/JAVA程序设计基础-第6版陈国君2006-学习笔记2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://hibiscidai.com">HibisciDai</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JAVA/">JAVA</a><a class="post-meta__tags" href="/tags/JAVA%E5%9F%BA%E7%A1%80/">JAVA基础</a><a class="post-meta__tags" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="/img/zhifubaodashang.jpg"><div class="post-qr-code__desc">支付宝打赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="/img/weixin.png"><div class="post-qr-code__desc">微信打赏</div></div></div><div class="social-share pull-right" data-disabled="linkedin,diandian"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/12/30/JAVA%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80-%E7%AC%AC6%E7%89%88%E9%99%88%E5%9B%BD%E5%90%9B2006-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/"><i class="fa fa-chevron-left">  </i><span>JAVA程序设计基础-第6版陈国君2006-学习笔记3</span></a></div><div class="next-post pull-right"><a href="/2021/12/20/JAVA%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80-%E7%AC%AC6%E7%89%88%E9%99%88%E5%9B%BD%E5%90%9B2006-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/"><span>JAVA程序设计基础-第6版陈国君2006-学习笔记1</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="lv-container" data-id="city" data-uid="MTAyMC8zNTQ2NC8xMjAwMA=="><script>(function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
})(document, 'script');</script></div></div></div><footer class="footer-bg" style="background-image: url(/img/banner2.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2017 - 2023 By HibisciDai</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/js/katex.js"></script><script src="/js/search/local-search.js"></script><script id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" data-click="false"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>