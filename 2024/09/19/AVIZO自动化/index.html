<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="AVIZO自动化"><meta name="keywords" content="Avizo,石油地质,数字岩心"><meta name="author" content="HibisciDai"><meta name="copyright" content="HibisciDai"><title>AVIZO自动化 | HibisciDai</title><link rel="shortcut icon" href="/img/avatar.png"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="manifest" href="/manifest.json"><link rel="manifest" href="/manifest.json"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '6.1.0'
} </script><meta name="generator" content="Hexo 6.1.0"><link rel="alternate" href="/atom.xml" title="HibisciDai" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#AVIZO%E8%87%AA%E5%8A%A8%E5%8C%96"><span class="toc-number">1.</span> <span class="toc-text">AVIZO自动化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-%E6%A8%A1%E6%9D%BF%E9%A1%B9%E7%9B%AE"><span class="toc-number">1.1.</span> <span class="toc-text">9.1 模板项目</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-1-%E6%A8%A1%E6%9D%BF%E9%A1%B9%E7%9B%AE%E8%AF%B4%E6%98%8E"><span class="toc-number">1.1.1.</span> <span class="toc-text">9.1.1 模板项目说明</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-1-1-%E5%A6%82%E4%BD%95%E4%BF%9D%E5%AD%98%E6%A8%A1%E6%9D%BF%E9%A1%B9%E7%9B%AE"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">9.1.1.1 如何保存模板项目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-1-2-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%A8%A1%E6%9D%BF%E9%A1%B9%E7%9B%AE"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">9.1.1.2 如何使用模板项目</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-Avizo-%E5%90%AF%E5%8A%A8"><span class="toc-number">1.2.</span> <span class="toc-text">9.2 Avizo 启动</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-1-%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%80%89%E9%A1%B9"><span class="toc-number">1.2.1.</span> <span class="toc-text">9.2.1 命令行选项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-2-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-number">1.2.2.</span> <span class="toc-text">9.2.2 环境变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-3-%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC"><span class="toc-number">1.2.3.</span> <span class="toc-text">9.2.3 用户自定义启动脚本</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3-%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99"><span class="toc-number">1.3.</span> <span class="toc-text">9.3 脚本编写</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-1-%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.3.1.</span> <span class="toc-text">9.3.1 脚本编写介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-2-Tcl%E7%AE%80%E4%BB%8B"><span class="toc-number">1.3.2.</span> <span class="toc-text">9.3.2 Tcl简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-2-1-Tcl%E5%88%97%E8%A1%A8%E3%80%81%E5%91%BD%E4%BB%A4%E5%92%8C%E6%B3%A8%E9%87%8A"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">9.3.2.1 Tcl列表、命令和注释</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-2-2-Tcl%E5%8F%98%E9%87%8F"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">9.3.2.2 Tcl变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-2-3-Tcl%E5%91%BD%E4%BB%A4%E6%9B%BF%E6%8D%A2"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">9.3.2.3 Tcl命令替换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-2-4-Tcl-%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">9.3.2.4 Tcl 控制结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-2-5-%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84Tcl%E8%BF%87%E7%A8%8B"><span class="toc-number">1.3.2.5.</span> <span class="toc-text">9.3.2.5 用户自定义的Tcl过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-2-6-%E5%88%97%E8%A1%A8%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C"><span class="toc-number">1.3.2.6.</span> <span class="toc-text">9.3.2.6 列表和字符串操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-3-Avizo-%E8%84%9A%E6%9C%AC%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.3.3.</span> <span class="toc-text">9.3.3 Avizo 脚本接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-3-1-%E9%A2%84%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">9.3.3.1 预定义变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-3-2-%E5%AF%B9%E8%B1%A1%E5%91%BD%E4%BB%A4"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">9.3.3.2 对象命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-4-%E5%85%A8%E5%B1%80%E5%91%BD%E4%BB%A4"><span class="toc-number">1.3.4.</span> <span class="toc-text">9.3.4 全局命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-4-1-%E8%A7%86%E5%9B%BE%E5%91%BD%E4%BB%A4%E9%80%89%E9%A1%B9"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">9.3.4.1 视图命令选项</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%EF%BC%9A"><span class="toc-number">1.3.4.1.1.</span> <span class="toc-text">命令：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-4-2-%E4%B8%BB%E7%AA%97%E5%8F%A3%E5%91%BD%E4%BB%A4%E9%80%89%E9%A1%B9"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">9.3.4.2 主窗口命令选项</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%EF%BC%9A-1"><span class="toc-number">1.3.4.2.1.</span> <span class="toc-text">命令：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-3-4-3-%E6%8E%A7%E5%88%B6%E5%8F%B0%E5%91%BD%E4%BB%A4%E9%80%89%E9%A1%B9"><span class="toc-number">1.3.4.2.2.</span> <span class="toc-text">9.3.4.3 控制台命令选项</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-4-4-%E9%A1%B6%E5%B1%82%E7%AA%97%E5%8F%A3%E7%9A%84%E9%80%9A%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">1.3.4.3.</span> <span class="toc-text">9.3.4.4 顶层窗口的通用命令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%EF%BC%9A-2"><span class="toc-number">1.3.4.3.1.</span> <span class="toc-text">命令：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-4-5-%E8%BF%9B%E5%BA%A6%E6%9D%A1%E5%91%BD%E4%BB%A4%E9%80%89%E9%A1%B9"><span class="toc-number">1.3.4.4.</span> <span class="toc-text">9.3.4.5 进度条命令选项</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4"><span class="toc-number">1.3.4.4.1.</span> <span class="toc-text">命令</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-4-6-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%91%BD%E4%BB%A4%E9%80%89%E9%A1%B9"><span class="toc-number">1.3.4.5.</span> <span class="toc-text">9.3.4.6 应用程序命令选项</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4-1"><span class="toc-number">1.3.4.5.1.</span> <span class="toc-text">命令</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-4-7-%E5%85%B6%E4%BB%96%E5%85%A8%E5%B1%80%E5%91%BD%E4%BB%A4"><span class="toc-number">1.3.4.6.</span> <span class="toc-text">9.3.4.7 其他全局命令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4-2"><span class="toc-number">1.3.4.6.1.</span> <span class="toc-text">命令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-5-Avizo-%E8%84%9A%E6%9C%AC%E6%96%87%E4%BB%B6"><span class="toc-number">1.3.5.</span> <span class="toc-text">9.3.5 Avizo 脚本文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-6-%E9%85%8D%E7%BD%AE%E5%BC%B9%E5%87%BA%E8%8F%9C%E5%8D%95"><span class="toc-number">1.3.6.</span> <span class="toc-text">9.3.6 配置弹出菜单</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-7-%E6%B3%A8%E5%86%8C%E7%82%B9%E5%87%BB%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.7.</span> <span class="toc-text">9.3.7 注册点击回调函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-8-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E5%99%A8%E5%9C%A8Tcl%E4%B8%AD"><span class="toc-number">1.3.8.</span> <span class="toc-text">9.3.8 文件读取器在Tcl中</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-4-%E4%BD%BF%E7%94%A8-MATLAB-%E4%B8%8E-Avizo"><span class="toc-number">1.4.</span> <span class="toc-text">9.4 使用 MATLAB 与 Avizo</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-4-1-%E4%BD%BF%E7%94%A8-MATLAB-%E8%84%9A%E6%9C%AC"><span class="toc-number">1.4.1.</span> <span class="toc-text">9.4.1 使用 MATLAB 脚本</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Python-Scripting"><span class="toc-number">2.</span> <span class="toc-text">Python Scripting</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-6-Python-%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99"><span class="toc-number">2.1.</span> <span class="toc-text">11.6 Python 脚本编写</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-6-1-Python-%E6%96%87%E6%A1%A3"><span class="toc-number">2.1.1.</span> <span class="toc-text">11.6.1 Python 文档</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-6-1-1-Python-%E7%AE%80%E4%BB%8B"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">11.6.1.1 Python 简介</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#11-6-1-1-1-%E4%BD%BF%E7%94%A8-Python"><span class="toc-number">2.1.1.1.1.</span> <span class="toc-text">11.6.1.1.1 使用 Python</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Python%E6%8E%A7%E5%88%B6%E5%8F%B0"><span class="toc-number">2.1.1.1.1.1.</span> <span class="toc-text">Python控制台</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%92%8C%E5%91%BD%E4%BB%A4"><span class="toc-number">2.1.1.1.1.2.</span> <span class="toc-text">常用快捷键和命令</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11-6-1-1-2-%E5%85%B3%E4%BA%8EPython%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">2.1.1.1.2.</span> <span class="toc-text">11.6.1.1.2 关于Python的注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%8C%85"><span class="toc-number">2.1.1.1.2.1.</span> <span class="toc-text">软件包</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95"><span class="toc-number">2.1.1.1.2.2.</span> <span class="toc-text">语法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-6-1-2-%E5%B5%8C%E5%85%A5%E5%BC%8FPython%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">11.6.1.2 嵌入式Python的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#11-6-1-2-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">2.1.1.2.1.</span> <span class="toc-text">11.6.1.2.1 概述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11-6-1-2-2-%E7%A4%BA%E4%BE%8B%EF%BC%9A%E4%B8%8E%E6%A8%A1%E5%9D%97%E4%BA%A4%E4%BA%92"><span class="toc-number">2.1.1.2.2.</span> <span class="toc-text">11.6.1.2.2 示例：与模块交互</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11-6-1-2-3-%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%BC%80%E5%8F%91%E8%84%9A%E6%9C%AC"><span class="toc-number">2.1.1.2.3.</span> <span class="toc-text">11.6.1.2.3 示例：开发脚本</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11-6-1-2-4-%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.1.2.4.</span> <span class="toc-text">11.6.1.2.4 示例：创建一个函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-6-1-3-%E5%B8%B8%E7%94%A8%E5%85%A8%E5%B1%80%E5%91%BD%E4%BB%A4"><span class="toc-number">2.1.1.3.</span> <span class="toc-text">11.6.1.3 常用全局命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-6-1-4-%E6%A8%A1%E5%9D%97%E7%AE%A1%E7%90%86"><span class="toc-number">2.1.1.4.</span> <span class="toc-text">11.6.1.4 模块管理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#11-6-1-4-1-%E6%A8%A1%E5%9D%97%E5%B1%9E%E6%80%A7"><span class="toc-number">2.1.1.4.1.</span> <span class="toc-text">11.6.1.4.1 模块属性</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B1%9E%E6%80%A7"><span class="toc-number">2.1.1.4.1.1.</span> <span class="toc-text">什么是属性</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%B1%9E%E6%80%A7%E5%88%97%E8%A1%A8"><span class="toc-number">2.1.1.4.1.2.</span> <span class="toc-text">常见属性列表</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#11-6-1-4-2-%E6%A8%A1%E5%9D%97%E6%96%B9%E6%B3%95"><span class="toc-number">2.1.1.4.1.3.</span> <span class="toc-text">11.6.1.4.2 模块方法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%96%B9%E6%B3%95"><span class="toc-number">2.1.1.4.1.4.</span> <span class="toc-text">什么是方法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95%E5%88%97%E8%A1%A8"><span class="toc-number">2.1.1.4.1.5.</span> <span class="toc-text">常见方法列表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-6-1-5-%E8%84%9A%E6%9C%AC%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.1.1.5.</span> <span class="toc-text">11.6.1.5 脚本对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#11-6-1-5-1-%E4%BB%80%E4%B9%88%E6%98%AF-Python-%E8%84%9A%E6%9C%AC%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.1.1.5.1.</span> <span class="toc-text">11.6.1.5.1 什么是 Python 脚本对象</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%84%9A%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.1.5.1.1.</span> <span class="toc-text">脚本结构</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%AB%AF%E5%8F%A3"><span class="toc-number">2.1.1.5.1.2.</span> <span class="toc-text">创建端口</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Bounding-Box-%E8%84%9A%E6%9C%AC%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.1.1.5.1.3.</span> <span class="toc-text">Bounding Box 脚本示例</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11-6-1-5-2-%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6"><span class="toc-number">2.1.1.5.2.</span> <span class="toc-text">11.6.1.5.2 资源文件</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E4%B8%8B%E6%8B%89%E8%8F%9C%E5%8D%95%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6"><span class="toc-number">2.1.1.5.2.1.</span> <span class="toc-text">结构化下拉菜单资源文件</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E5%AE%8F%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6"><span class="toc-number">2.1.1.5.2.2.</span> <span class="toc-text">结构化宏资源文件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-6-1-6-Python-%E7%8E%AF%E5%A2%83%E5%92%8C%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">2.1.1.6.</span> <span class="toc-text">11.6.1.6 Python 环境和包管理器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%83%8C%E6%99%AF"><span class="toc-number">2.1.1.6.1.</span> <span class="toc-text">背景</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0"><span class="toc-number">2.1.1.6.2.</span> <span class="toc-text">描述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE-EDM"><span class="toc-number">2.1.1.6.3.</span> <span class="toc-text">如何安装和配置 EDM</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%90%9C%E7%B4%A2%E5%92%8C%E5%AE%89%E8%A3%85%E5%8C%85"><span class="toc-number">2.1.1.6.4.</span> <span class="toc-text">如何搜索和安装包</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%97%E5%87%BA%E5%BD%93%E5%89%8D%E5%AE%89%E8%A3%85%E7%9A%84%E5%8C%85"><span class="toc-number">2.1.1.6.5.</span> <span class="toc-text">如何列出当前安装的包</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%87%8D%E6%96%B0%E5%88%9D%E5%A7%8B%E5%8C%96-Avizo-%E5%8C%85"><span class="toc-number">2.1.1.6.6.</span> <span class="toc-text">如何重新初始化 Avizo 包</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-6-1-7-Python-%E5%8C%85%E5%88%97%E8%A1%A8"><span class="toc-number">2.1.1.7.</span> <span class="toc-text">11.6.1.7 Python 包列表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-6-2-Python-%E6%95%99%E7%A8%8B"><span class="toc-number">2.1.2.</span> <span class="toc-text">11.6.2 Python 教程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-6-2-1-Python-%E6%95%99%E7%A8%8B-%E5%9C%A8-Avizo-%E4%B8%AD%E4%BD%BF%E7%94%A8-Python-%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%B7%A5%E5%85%B7"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">11.6.2.1 Python 教程 - 在 Avizo 中使用 Python 生态系统中的工具</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-7-1-%E4%BD%BF%E7%94%A8-MATLAB-%E8%84%9A%E6%9C%AC"><span class="toc-number">2.1.3.</span> <span class="toc-text">11.7.1 使用 MATLAB 脚本</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Thermo-Fisher-Python-API-documentation"><span class="toc-number">3.</span> <span class="toc-text">Thermo Fisher Python API documentation</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Object-handling-classes"><span class="toc-number">3.1.</span> <span class="toc-text">Object handling classes</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#hx-core-HxObjectFactory"><span class="toc-number">3.1.1.</span> <span class="toc-text">hx.core.HxObjectFactory</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#create-classname"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">create(classname)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%82%E6%95%B0"><span class="toc-number">3.1.1.1.1.</span> <span class="toc-text">参数:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E"><span class="toc-number">3.1.1.1.2.</span> <span class="toc-text">返回:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.1.1.1.3.</span> <span class="toc-text">示例:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#get-obj-name"><span class="toc-number">3.1.1.2.</span> <span class="toc-text">get(obj_name)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-1"><span class="toc-number">3.1.1.2.1.</span> <span class="toc-text">参数:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E-1"><span class="toc-number">3.1.1.2.2.</span> <span class="toc-text">返回:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Raises"><span class="toc-number">3.1.1.2.3.</span> <span class="toc-text">Raises:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">3.1.1.2.4.</span> <span class="toc-text">示例:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#load-filename"><span class="toc-number">3.1.1.3.</span> <span class="toc-text">load(filename)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-2"><span class="toc-number">3.1.1.3.1.</span> <span class="toc-text">参数:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E-2"><span class="toc-number">3.1.1.3.2.</span> <span class="toc-text">返回:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Raises-1"><span class="toc-number">3.1.1.3.3.</span> <span class="toc-text">Raises:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2"><span class="toc-number">3.1.1.3.4.</span> <span class="toc-text">示例:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hx-core-HxProject"><span class="toc-number">3.1.2.</span> <span class="toc-text">hx.core.HxProject</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#add-obj"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">add(obj)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-3"><span class="toc-number">3.1.2.1.1.</span> <span class="toc-text">参数:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-3"><span class="toc-number">3.1.2.1.2.</span> <span class="toc-text">示例:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#create-classname-1"><span class="toc-number">3.1.2.2.</span> <span class="toc-text">create(classname)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-4"><span class="toc-number">3.1.2.2.1.</span> <span class="toc-text">参数:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E-3"><span class="toc-number">3.1.2.2.2.</span> <span class="toc-text">返回:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Notes"><span class="toc-number">3.1.2.2.3.</span> <span class="toc-text">Notes</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-4"><span class="toc-number">3.1.2.2.4.</span> <span class="toc-text">示例:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#get-obj-name-1"><span class="toc-number">3.1.2.3.</span> <span class="toc-text">get(obj_name)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-5"><span class="toc-number">3.1.2.3.1.</span> <span class="toc-text">参数:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Raises-2"><span class="toc-number">3.1.2.3.2.</span> <span class="toc-text">Raises:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-5"><span class="toc-number">3.1.2.3.3.</span> <span class="toc-text">示例:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#load-filename-1"><span class="toc-number">3.1.2.4.</span> <span class="toc-text">load(filename)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-6"><span class="toc-number">3.1.2.4.1.</span> <span class="toc-text">参数:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E-4"><span class="toc-number">3.1.2.4.2.</span> <span class="toc-text">返回:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Notes-1"><span class="toc-number">3.1.2.4.3.</span> <span class="toc-text">Notes</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-6"><span class="toc-number">3.1.2.4.4.</span> <span class="toc-text">示例:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#remove-obj"><span class="toc-number">3.1.2.5.</span> <span class="toc-text">remove(obj)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-7"><span class="toc-number">3.1.2.5.1.</span> <span class="toc-text">参数:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Raises-3"><span class="toc-number">3.1.2.5.2.</span> <span class="toc-text">Raises:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-7"><span class="toc-number">3.1.2.5.3.</span> <span class="toc-text">示例:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#remove-all"><span class="toc-number">3.1.2.6.</span> <span class="toc-text">remove_all()</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-8"><span class="toc-number">3.1.2.6.1.</span> <span class="toc-text">示例:</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Path-management"><span class="toc-number">3.2.</span> <span class="toc-text">Path management</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#hx-core-HxPaths"><span class="toc-number">3.2.1.</span> <span class="toc-text">hx.core.HxPaths</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#appdata-dir"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">appdata_dir</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#executable-dir"><span class="toc-number">3.2.1.2.</span> <span class="toc-text">executable_dir</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#home-dir"><span class="toc-number">3.2.1.3.</span> <span class="toc-text">home_dir</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#install-data-dir"><span class="toc-number">3.2.1.4.</span> <span class="toc-text">install_data_dir</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#install-dir"><span class="toc-number">3.2.1.5.</span> <span class="toc-text">install_dir</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#python-modules-dir"><span class="toc-number">3.2.1.6.</span> <span class="toc-text">python_modules_dir</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#python-script-objects-dir"><span class="toc-number">3.2.1.7.</span> <span class="toc-text">python_script_objects_dir</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#python-share-dir"><span class="toc-number">3.2.1.8.</span> <span class="toc-text">python_share_dir</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tutorials-dir"><span class="toc-number">3.2.1.9.</span> <span class="toc-text">tutorials_dir</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Messaging-utilities"><span class="toc-number">3.3.</span> <span class="toc-text">Messaging utilities</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#hx-core-HxMessage"><span class="toc-number">3.3.1.</span> <span class="toc-text">hx.core.HxMessage</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#confirmations-message-button0-text-button1-text"><span class="toc-number">3.3.1.1.</span> <span class="toc-text">confirmations(message, button0_text, button1_text)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-8"><span class="toc-number">3.3.1.1.1.</span> <span class="toc-text">参数:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E-5"><span class="toc-number">3.3.1.1.2.</span> <span class="toc-text">返回:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-9"><span class="toc-number">3.3.1.1.3.</span> <span class="toc-text">示例:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#error-message-button0-text-%E2%80%9D%E2%80%9D-button1-text-%E2%80%9D%E2%80%9D-button2-text-%E2%80%9D%E2%80%9D-default-button-index-1-escape-button-index-1"><span class="toc-number">3.3.1.2.</span> <span class="toc-text">error(message, button0_text&#x3D;””, button1_text&#x3D;””, button2_text&#x3D;””, default_button_index&#x3D;-1, escape_button_index&#x3D;-1)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-9"><span class="toc-number">3.3.1.2.1.</span> <span class="toc-text">参数:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E-6"><span class="toc-number">3.3.1.2.2.</span> <span class="toc-text">返回:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-10"><span class="toc-number">3.3.1.2.3.</span> <span class="toc-text">示例:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#info-message-do-not-show-again-key-%E2%80%9D%E2%80%9D"><span class="toc-number">3.3.1.3.</span> <span class="toc-text">info(message, do_not_show_again_key&#x3D;””)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-10"><span class="toc-number">3.3.1.3.1.</span> <span class="toc-text">参数:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E-7"><span class="toc-number">3.3.1.3.2.</span> <span class="toc-text">返回:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-11"><span class="toc-number">3.3.1.3.3.</span> <span class="toc-text">示例:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#overwrite-filename"><span class="toc-number">3.3.1.4.</span> <span class="toc-text">overwrite(filename)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-11"><span class="toc-number">3.3.1.4.1.</span> <span class="toc-text">参数:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E-8"><span class="toc-number">3.3.1.4.2.</span> <span class="toc-text">返回:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#question-message-button0-text-button1-text-button2-text-%E2%80%9D%E2%80%9D-default-button-index-1-escape-button-index-1-do-not-show-again-key-%E2%80%9D%E2%80%9D"><span class="toc-number">3.3.1.5.</span> <span class="toc-text">question(message, button0_text, button1_text, button2_text&#x3D;””, default_button_index&#x3D;-1, escape_button_index&#x3D;-1, do_not_show_again_key&#x3D;””)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-12"><span class="toc-number">3.3.1.5.1.</span> <span class="toc-text">参数:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E-9"><span class="toc-number">3.3.1.5.2.</span> <span class="toc-text">返回:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-12"><span class="toc-number">3.3.1.5.3.</span> <span class="toc-text">示例:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#warning-message-button0-text-%E2%80%9D%E2%80%9D-button1-text-%E2%80%9D%E2%80%9D-button2-text-%E2%80%9D%E2%80%9D-default-button-index-1-escape-button-index-1-do-not-show-again-key-%E2%80%9D%E2%80%9D"><span class="toc-number">3.3.1.6.</span> <span class="toc-text">warning(message, button0_text&#x3D;””, button1_text&#x3D;””, button2_text&#x3D;””, default_button_index&#x3D;-1, escape_button_index&#x3D;-1, do_not_show_again_key&#x3D;””)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-13"><span class="toc-number">3.3.1.6.1.</span> <span class="toc-text">参数:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E-10"><span class="toc-number">3.3.1.6.2.</span> <span class="toc-text">返回:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-13"><span class="toc-number">3.3.1.6.3.</span> <span class="toc-text">示例:</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hierarchy-of-objects"><span class="toc-number">3.4.</span> <span class="toc-text">Hierarchy of objects</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#hx-core-McInterface"><span class="toc-number">3.4.1.</span> <span class="toc-text">hx.core.McInterface</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7"><span class="toc-number">3.4.1.1.</span> <span class="toc-text">属性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#all-interfaces"><span class="toc-number">3.4.1.1.1.</span> <span class="toc-text">all_interfaces</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-14"><span class="toc-number">3.4.1.1.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">3.4.1.2.</span> <span class="toc-text">方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#get-all-interface-names"><span class="toc-number">3.4.1.2.1.</span> <span class="toc-text">get_all_interface_names()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E-11"><span class="toc-number">3.4.1.2.2.</span> <span class="toc-text">返回:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-15"><span class="toc-number">3.4.1.2.3.</span> <span class="toc-text">示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hx-core-HxBase"><span class="toc-number">3.4.2.</span> <span class="toc-text">hx.core.HxBase</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#python-avizo%E4%BB%A3%E7%A0%81%E6%B5%8B%E8%AF%95"><span class="toc-number">4.</span> <span class="toc-text">python+avizo代码测试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%88%9B%E5%BB%BA%E6%96%B9%E6%B3%95"><span class="toc-number">4.1.</span> <span class="toc-text">代码创建方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#helloworld"><span class="toc-number">4.2.</span> <span class="toc-text">helloworld</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E5%B9%B6%E8%BF%9B%E8%A1%8C%E5%88%87%E7%89%87%E6%98%BE%E7%A4%BA"><span class="toc-number">4.3.</span> <span class="toc-text">读取文件并进行切片显示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2"><span class="toc-number">4.4.</span> <span class="toc-text">阈值分割</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#avizo%E4%B8%ADImage-Segmentation%E6%96%B9%E6%B3%95"><span class="toc-number">4.4.1.</span> <span class="toc-text">avizo中Image Segmentation方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2"><span class="toc-number">4.4.2.</span> <span class="toc-text">是否需要阈值分割</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B2%E7%8E%87%E8%AE%A1%E7%AE%97%E5%8F%8A%E5%88%86%E6%9E%90"><span class="toc-number">4.5.</span> <span class="toc-text">曲率计算及分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Image-Curvature"><span class="toc-number">4.5.1.</span> <span class="toc-text">Image Curvature</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Image-Statistics"><span class="toc-number">4.5.2.</span> <span class="toc-text">Image Statistics</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Image-Curvature-Image-Statistics"><span class="toc-number">4.5.3.</span> <span class="toc-text">Image Curvature + Image Statistics</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E8%A1%A8%E6%A0%BC"><span class="toc-number">4.5.4.</span> <span class="toc-text">读取表格</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2%E8%AE%A1%E7%AE%97%E6%9B%B2%E7%8E%87%E6%A1%88%E4%BE%8B"><span class="toc-number">4.6.</span> <span class="toc-text">阈值分割计算曲率案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2D"><span class="toc-number">4.6.1.</span> <span class="toc-text">2D</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3D-%E5%8D%95%E4%B8%AA"><span class="toc-number">4.6.2.</span> <span class="toc-text">3D-单个</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/Avatar.png"></div><div class="author-info__name text-center">HibisciDai</div><div class="author-info__description text-center">HibisciDai'Blog</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">244</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">88</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">33</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友情链接</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://github.com/HibisciDai/hexo-theme-melody">HexoTheme-github</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://molunerfinn.com/">molunerfinn</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/img/banner2.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">HibisciDai</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/about">关于我</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/gallery">相册</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">AVIZO自动化</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2024-09-19</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/AvizoUsersGuide/">AvizoUsersGuide</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">32.5k</span><span class="post-meta__separator">|</span><span>阅读时长: 116 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><img src="/2024/09/19/AVIZO%E8%87%AA%E5%8A%A8%E5%8C%96/AVIZO%E8%87%AA%E5%8A%A8%E5%8C%96.png" class="" title="AVIZO自动化">
<p>AVIZO自动化</p>
<span id="more"></span>
<h1 id="AVIZO自动化"><a href="#AVIZO自动化" class="headerlink" title="AVIZO自动化"></a>AVIZO自动化</h1><p>第9章《自动化、自定义和扩展》主要讲解了如何使用Avizo的自动化、自定义和扩展功能。以下是详细介绍：</p>
<p>9.1 模板项目</p>
<p>模板项目用于简化对相似数据集的重复任务处理。用户可以将原始项目保存为模板，以便在相同类型的数据上重复使用。模板项目可以通过右键菜单或“项目 &gt; 创建对象”子菜单加载和执行。模板项目为自动化重复操作提供了便捷的途径。</p>
<p>9.2 Avizo启动<br>这一节描述了Avizo的启动选项，包括：</p>
<p>命令行选项：可用于配置Avizo启动时的行为，例如日志记录、禁用图形界面等。<br>环境变量：用户可以通过环境变量设置临时目录、启用或禁用特定功能（例如3D立体视图）。<br>用户定义的启动脚本：可以通过编写用户定义的启动脚本（如Avizo.init）定制Avizo的行为，包含注册文件格式、模块和编辑器等。</p>
<p>9.3 脚本编写</p>
<p>这一节介绍了如何使用脚本来控制Avizo，实现自动化和自定义任务。Avizo的脚本基于Tcl语言，用户可以通过编写Tcl脚本来操控Avizo的大部分功能，包括：</p>
<p>命令替换：使用括号[]执行命令并返回结果。<br>控制结构：支持if-else条件判断、for循环、while循环等控制结构。<br>用户自定义过程：使用proc定义新函数或过程，支持灵活参数列表和局部变量。<br>列表和字符串操作：Tcl中的所有内容都是通过列表构建的，提供了多个操作列表的命令。</p>
<p>9.4 使用MATLAB与Avizo集成</p>
<p>Avizo提供了与MATLAB的集成模块，允许用户从Avizo传递数据到MATLAB进行复杂计算，并将结果返回到Avizo中。通过这种方式，用户可以在Avizo中执行MATLAB脚本、调用用户自定义的MATLAB函数、以及使用字段结构等。</p>
<p>总的来说，第9章提供了Avizo的高级功能，允许用户通过模板、脚本编写和MATLAB集成来自动化和扩展工作流程 。</p>
<h2 id="9-1-模板项目"><a href="#9-1-模板项目" class="headerlink" title="9.1 模板项目"></a>9.1 模板项目</h2><p>这一节描述了如何使用模板项目。</p>
<h3 id="9-1-1-模板项目说明"><a href="#9-1-1-模板项目说明" class="headerlink" title="9.1.1 模板项目说明"></a>9.1.1 模板项目说明</h3><p>模板项目可以用于简化对一组相似数据的重复任务处理。模板项目是原始项目的副本，可以在相同类型的其他数据上重新应用。</p>
<h4 id="9-1-1-1-如何保存模板项目"><a href="#9-1-1-1-如何保存模板项目" class="headerlink" title="9.1.1.1 如何保存模板项目"></a>9.1.1.1 如何保存模板项目</h4><p>要创建模板项目，请从文件菜单中选择“另存项目为模板”（Save Project As Template）。这时会弹出一个输入选择对话框，列出所有可能的模板输入（当前的所有数据对象）。模板输入代表在执行模板时必须提供的数据集。您可以更改每个所选模板输入的标签。由于该标签会在模板执行期间显示出来，因此标签应当通用且有意义。默认标签是原始数据对象的名称。注意：未使用的数据对象会默认被过滤，但您可以通过选择“包含未使用的数据”（Include unused data）选项将其包含在模板项目中。</p>
<p>如果模板只包含一个输入，对话框会询问您是否希望将模板与该类型的数据关联。如果点击“确定”，则该模板会在右键菜单中的模板子菜单下（Templates submenu）对所有相同数据类型的对象可用。</p>
<p>最后，将弹出文件对话框以命名输出文件。文件名也是模板的名称，即将显示在模板菜单中的名称。内置的模板项目存储在“share/templates”文件夹中，但您可能没有足够的权限在该目录中创建新文件。</p>
<img src="/2024/09/19/AVIZO%E8%87%AA%E5%8A%A8%E5%8C%96/Figure9.1.png" class="" title="Figure 9.1: The template project save dialog.">
<img src="/2024/09/19/AVIZO%E8%87%AA%E5%8A%A8%E5%8C%96/Figure9.2.png" class="" title="Figure 9.2: Data Type association is possible if template has only one input.">
<p>您可以将自定义模板保存在任何目录中。每次启动 Avizo 时，它们都会自动重新加载。</p>
<h4 id="9-1-1-2-如何使用模板项目"><a href="#9-1-1-2-如何使用模板项目" class="headerlink" title="9.1.1.2 如何使用模板项目"></a>9.1.1.2 如何使用模板项目</h4><p>内置的模板项目和已知的用户自定义模板项目会在Avizo启动时自动加载。加载模板并不意味着实例化模板项目。模板项目仅在用户请求时创建，例如通过“项目 &gt; 创建对象…”菜单。一个例外是：如果用户通过“打开数据”对话框加载模板文件，则模板资源会被加载并执行。</p>
<p>如果模板与某种数据类型相关联，您可以使用该类型的数据对象的右键菜单创建实例。在这种情况下，将立即使用所选数据对象创建模板。</p>
<p>对于其他模板，您可以从“项目 &gt; 创建对象…”菜单的模板子菜单中创建实例。模板也可能出现在宏按钮列表中。在这种情况下，模板执行时将出现以下对话框：</p>
<img src="/2024/09/19/AVIZO%E8%87%AA%E5%8A%A8%E5%8C%96/Figure9.3.png" class="" title="Figure 9.3: The template project run dialog.">
<p>每个模板输入都会显示其模板输入名称和一个组合框，用于选择将用于该输入的数据集。每个组合框中的候选数据根据其数据类型进行过滤。您可以通过取消选中“检查输入类型”选项来禁用此过滤并显示项目视图中的所有数据。如果没有适合的数据对象，组合框将为空。您还可以随时选择“&lt;加载文件…&gt;”项，显示文件打开对话框并选择数据文件。</p>
<p>对于色彩映射的特殊处理：默认情况下，项目视图中已存在的色彩映射会按原样重新使用。例如，模板项目中的对象可能会受到范围变化的影响。您还可以选择不与现有对象共享色彩映射，方法是选择“独立色彩映射”选项。</p>
<h2 id="9-2-Avizo-启动"><a href="#9-2-Avizo-启动" class="headerlink" title="9.2 Avizo 启动"></a>9.2 Avizo 启动</h2><p>这一节描述了一些与 Avizo 启动相关的选项，包括：</p>
<ul>
<li>命令行选项</li>
<li>环境变量</li>
<li>Avizo 启动脚本</li>
</ul>
<h3 id="9-2-1-命令行选项"><a href="#9-2-1-命令行选项" class="headerlink" title="9.2.1 命令行选项"></a>9.2.1 命令行选项</h3><p>本节介绍 Avizo 支持的命令行选项。通常，在 Unix 系统上，Avizo 是通过位于 bin 子目录中的启动脚本启动的。这个脚本通常链接到 /usr/local/bin/Avizo 或类似位置。用户也可以定义一个指向 bin/start 的 Avizo 别名。</p>
<p>在 Windows 系统上，Avizo 通常通过开始菜单或桌面图标启动。不过，用户也可以直接调用 bin/arch-Win64VC10-Optimize/Avizo.exe 来启动。在这种情况下，支持与 Unix 系统相同的命令行选项。</p>
<p>Avizo 的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Avizo [options] [files ...]</span><br></pre></td></tr></table></figure>
<p>命令行中指定的数据文件将自动加载。除了数据文件外，还可以指定脚本文件。这些脚本将在程序启动时执行。</p>
<p>支持的选项如下：</p>
<ul>
<li>help </li>
</ul>
<p>打印命令行选项的简要说明。</p>
<ul>
<li>version</li>
</ul>
<p>打印 Avizo 的版本信息。</p>
<ul>
<li>no stencils</li>
</ul>
<p>指示 Avizo 不在其 3D 图形窗口中请求模板缓冲区。此选项可用于在某些低端 PC 图形板上利用硬件加速。</p>
<ul>
<li>no overlays</li>
</ul>
<p>指示 Avizo 不在其 3D 图形窗口中使用叠加平面。如果在远程显示上重定向 Avizo 时遇到问题，可以使用此选项。</p>
<ul>
<li>no gui</li>
</ul>
<p>启动 Avizo 而不打开任何窗口。此选项对于批处理模式下执行脚本很有用。</p>
<ul>
<li>logfile filename</li>
</ul>
<p>将控制台窗口中打印的所有消息也写入指定的日志文件。此选项尤其适用于与 -no gui 选项结合使用。</p>
<ul>
<li>depth number</li>
</ul>
<p>此选项仅在 Linux 系统上支持。它指定首选的深度缓冲区深度。Linux 系统上的默认值为 16 位。</p>
<ul>
<li>style={windows | motif | cde} </li>
</ul>
<p>此选项设置 Avizo 的 Qt 用户界面的显示样式。</p>
<ul>
<li>debug</li>
</ul>
<p>此选项仅适用于开发者版本。它会导致本地包以调试版本执行。默认情况下将使用优化代码。</p>
<ul>
<li>cmd command [  - host hostname ] [ - port port] </li>
</ul>
<p>向正在运行的 Avizo 应用程序发送 Tcl 命令。可以选择指定主机名和端口号。在 Avizo 控制台窗口中键入 app -listen 后，才能接收命令。</p>
<ul>
<li>clusterdaemon</li>
</ul>
<p>以 VR 守护程序模式启动，适用于集群从节点（Avizo XScreen 扩展）。这可能会被服务替代。有关更多信息，请参阅在线文档。</p>
<ul>
<li>tclcmd command</li>
</ul>
<p>在启动应用程序时执行 Tcl 命令。</p>
<ul>
<li>edition { LiteEdition | AvizoEdition }</li>
</ul>
<p>在特定版本下启动 Avizo。</p>
<h3 id="9-2-2-环境变量"><a href="#9-2-2-环境变量" class="headerlink" title="9.2.2 环境变量"></a>9.2.2 环境变量</h3><p>执行 Avizo 不需要特别的环境设置。在 Unix 系统上，某些环境变量（如共享库路径或 AVIZO_ROOT 目录）会由 Avizo 启动脚本自动设置。用户还可以设置其他环境变量来控制某些功能，这些变量列举如下。在 Unix 系统上，可以使用 setenv（适用于 csh 或 tcsh）或 export（适用于 sh、bash 或 ksh）来设置环境变量。在 Windows 上，可以在系统属性对话框中定义环境变量（Microsoft Windows）。</p>
<ul>
<li>AVIZO_DATADIR</li>
</ul>
<p>一个数据目录路径。此目录将用作文件对话框的默认目录。请注意，为了快速访问多个目录，您可以使用操作系统功能（例如在文件对话框中添加收藏夹位置列表），或者使用包含快捷方式或指向其他目录的链接的目录。</p>
<ul>
<li>AVIZO_TEXMEM</li>
</ul>
<p>指定以兆字节为单位的纹理内存量。如果未设置此变量，将应用一些启发式算法来确定系统上可用的纹理内存量。然而，这些启发式算法可能并不总是得出正确的值。在这种情况下，可以使用此变量来提高体积渲染模块的性能。</p>
<ul>
<li>AVIZO_MULTISAMPLE</li>
</ul>
<p>在高端图形系统上，默认使用多采样视觉。这种方式可以实现高效的场景抗锯齿。如果您希望禁用此功能，请将环境变量 AVIZO_MULTISAMPLE 设置为 0。请注意，在其他系统上，特别是在 PC 上，抗锯齿无法通过应用程序控制，而是必须直接在图形驱动程序中激活。</p>
<ul>
<li>AVIZO_NO_LICENSE_MESSAGE</li>
</ul>
<p>默认情况下，当您的 Avizo 许可证即将到期时，Avizo 会向控制台发出警告消息。这使您可以及时采取行动，防止在许可证到期时意外中断 Avizo 的使用。要禁用这些消息，请将此变量设置为 1。</p>
<ul>
<li>AVIZO_NO_OVERLAYS</li>
</ul>
<p>如果设置此变量，Avizo 将不会在其 3D 图形窗口中使用叠加平面。通过 -no overlays 命令行选项可以获得相同的效果。如果在远程显示上重定向 Avizo 时遇到问题，或者您的 X 服务器不支持叠加视觉，可以关闭叠加。</p>
<ul>
<li>AVIZO_NO_SPLASH_SCREEN</li>
</ul>
<p>如果设置此变量，Avizo 在初始化时不会显示启动画面。</p>
<ul>
<li>AVIZO_LOCAL</li>
</ul>
<p>指定包含用户定义模块的本地 Avizo 目录。此目录中的 IO 例程或模块将替代主 Avizo 目录中定义的例程或模块。此环境变量将覆盖开发向导中设置的本地 Avizo 目录（有关详细信息，请参阅 Avizo 程序员指南）。</p>
<ul>
<li>AVIZO_SMALLFONT</li>
</ul>
<p>仅适用于 Unix 系统。如果设置了此变量，即使屏幕分辨率为 1280x1024 或更高，所有在属性区中显示的端口也将使用小字体。默认情况下，小字体只会在较低分辨率的情况下使用。</p>
<ul>
<li>AVIZO_XSHM</li>
</ul>
<p>仅适用于 Unix 系统。如果您希望在 Avizo 的分割编辑器中禁止使用 X 共享内存扩展，请将此变量设置为 0。</p>
<ul>
<li>AVIZO_SPACEMOUSE</li>
</ul>
<p>如果 Avizo 发现连接了 Spacemouse（详见 <a target="_blank" rel="noopener" href="http://www.3dconnexion.com">http://www.3dconnexion.com</a> ），Spacemouse 支持将自动启用。如果驱动程序已安装，则控制台窗口中会打印一条消息。通过 Spacemouse，您可以在 3D 查看器窗口中导航。支持两种模式：旋转模式和飞行模式。可以通过按下 Spacemouse 按钮 1 或 2 来切换两种模式。更多配置选项可能在 Avizo.init 文件中可用。<br>3Dconnexion Spacemouse 限制：</p>
<ul>
<li>Mac OS X 不支持 Spacemouse。</li>
<li>Avizo 和 AvizoClue 应用程序会识别 Spacemouse。</li>
<li>尚未完全支持六自由度运动。</li>
<li>Spacemouse 只能控制第一个查看器。</li>
<li>在旋转模式下，无法平移相机或上下移动。</li>
<li>在飞行模式下，无法绕物体旋转或上下移动。</li>
<li><p>默认情况下，按钮 1 用于打开菜单，必须重新配置为“按钮 1”功能。</p>
</li>
<li><p>AVIZO STEREO ON DEFAULT</p>
</li>
</ul>
<p>如果设置了此变量，则默认情况下 3D 查看器将以 OpenGL 原始立体模式打开。<br>这样，可以避免从单声道切换到立体模式时出现的屏幕闪烁。目前，该变量仅在 Unix 系统上受支持。</p>
<ul>
<li>TMPDIR</li>
</ul>
<p>此变量指定应将临时数据存储在哪个目录中。如果未设置，则此类数据将在 /tmp 下创建。此外，此变量由 Avizo 的作业队列解释。</p>
<h3 id="9-2-3-用户自定义启动脚本"><a href="#9-2-3-用户自定义启动脚本" class="headerlink" title="9.2.3 用户自定义启动脚本"></a>9.2.3 用户自定义启动脚本</h3><p>Avizo 可以通过提供用户自定义的启动脚本进行某些定制。默认的启动脚本名为 Avizo.init，位于 Avizo 安装目录的 share/resources/Avizo 子目录中。每次程序启动时，都会读取此脚本。此启动脚本的功能包括注册文件格式、模块和编辑器，以及加载默认的颜色映射。</p>
<p>如果在当前工作目录中找到名为 Avizo.init 的文件，则会读取该文件而不是默认的启动脚本。如果没有找到该文件，在 Unix 系统上会检查用户的主目录中是否存在名为 .Avizo 的启动脚本。下面是一个用户定义启动脚本的示例：</p>
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行默认启动脚本</span></span><br><span class="line"><span class="keyword">source</span> <span class="variable">$AVIZO_ROOT</span>/share/resources/Avizo/Avizo.init <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置均匀的黑色背景</span></span><br><span class="line">viewer <span class="number">0</span> setBackgroundMode <span class="number">0</span></span><br><span class="line">viewer <span class="number">0</span> setBackgroundColor black</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为帮助浏览器选择非默认字体大小</span></span><br><span class="line">help setFontSize <span class="number">12</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过按 [F3] 键恢复摄像机设置</span></span><br><span class="line"><span class="keyword">proc</span><span class="title"> onKeyF3</span> &#123; &#125; &#123;</span><br><span class="line">    viewer setCameraOrientation <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">3.14159</span></span><br><span class="line">    viewer setCameraPosition <span class="number">0</span> <span class="number">0</span> <span class="number">-2.50585</span></span><br><span class="line">    viewer setCameraFocalDistance <span class="number">2.50585</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在此示例中，首先执行系统的默认启动脚本，以确保所有 Avizo 对象被正确注册。接着进行一些特定的设置，最后为功能键 [F3] 定义了一个快捷键过程。您也可以为其他功能键定义此类过程。此外，还可以定义类似 onKeyShiftF3 或 onKeyCtrlF3 的过程。这些过程在按下功能键同时按住 [SHIFT] 或 [CTRL] 键时执行。</p>
<h2 id="9-3-脚本编写"><a href="#9-3-脚本编写" class="headerlink" title="9.3 脚本编写"></a>9.3 脚本编写</h2><p>本节描述如何在 Avizo 中使用脚本功能。</p>
<h3 id="9-3-1-脚本编写介绍"><a href="#9-3-1-脚本编写介绍" class="headerlink" title="9.3.1 脚本编写介绍"></a>9.3.1 脚本编写介绍</h3><p>本章专为高级 Avizo 用户而写。如果您不知道什么是脚本编写，那么很可能不需要本章中描述的功能。</p>
<p>除了通过图形用户界面的交互控制之外，大多数 Avizo 功能也可以通过特定的命令访问。这允许您自动化某些流程，创建用于管理日常任务或演示的脚本。Avizo 的脚本命令基于 Tcl（工具命令语言）。这意味着您可以使用 Tcl 编写带有 Avizo 特定扩展的命令脚本。</p>
<p>可以在 Avizo 的控制台窗口中键入命令，如第 8.1.13 节中所述。直接在控制台窗口中输入的命令将立即执行。或者，也可以将命令写入文本文件，然后作为整体执行。</p>
<p>本章内容如下：</p>
<p>9.3.2 Tcl 简介 提供了 Tcl 脚本语言的简短介绍。本节与 Avizo 相关性不大。</p>
<p>9.3.3 Avizo 脚本接口 解释了与脚本编写相关的 Avizo 特定命令和概念。包括全局命令参考。</p>
<p>9.3.5 Avizo 脚本文件 解释了编写和执行脚本文件的不同方法，包括脚本对象、资源文件和功能键绑定的 Tcl 过程的参考。</p>
<p>9.3.6 配置弹出菜单 描述了如何使用脚本命令配置对象的弹出菜单，并如何创建执行脚本的新条目。</p>
<p>9.3.7 注册拾取回调 描述了如何将脚本回调附加到对象或查看器中，并在用户拾取事件时调用它们。</p>
<p>9.3.8 Tcl 文件读取器 解释了如何注册用 Tcl 实现的自定义文件读取器。</p>
<h3 id="9-3-2-Tcl简介"><a href="#9-3-2-Tcl简介" class="headerlink" title="9.3.2 Tcl简介"></a>9.3.2 Tcl简介</h3><p>本章简要介绍Tcl脚本语言。如果你已经熟悉Tcl，你可以跳过本节。然而，请注意，输出到Avizo控制台时，应该使用echo命令，而不是puts命令。</p>
<p>本章并不打算涵盖Tcl语言的所有细节。要了解Tcl语言的完整文档或参考手册，请参阅John K. Ousterhout撰写的《Tcl and the Tk Toolkit》。许多其他关于Tcl的书籍也涵盖了Tk GUI工具包，但请注意，Tk在Avizo中并未使用。</p>
<p>你也可以在互联网上找到Tcl文档和参考手册，例如在<a target="_blank" rel="noopener" href="http://www.scriptics.com">http://www.scriptics.com</a> ，或者通过搜索引擎查找”Tcl教程”或”Tcl文档”。</p>
<p>当你在Avizo控制台中键入Tcl命令时，命令会在按下回车键后立即执行。使用Avizo控制台提供的自动补全和历史功能，参见第8.1.13节（控制台窗口）。</p>
<h4 id="9-3-2-1-Tcl列表、命令和注释"><a href="#9-3-2-1-Tcl列表、命令和注释" class="headerlink" title="9.3.2.1 Tcl列表、命令和注释"></a>9.3.2.1 Tcl列表、命令和注释</h4><p>首先，请注意Tcl是区分大小写的：set和Set并不相同。</p>
<p>Tcl命令是由空格分隔的单词列表。第一个单词代表命令名称，后续的单词被视为该命令的参数。例如，尝试输入Avizo特定的命令echo，该命令将所有参数打印到Avizo控制台。尝试键入：</p>
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo Hello World</span><br></pre></td></tr></table></figure>
<p>这将输出字符串”Hello World”。注意，Tcl命令可以用分号（;）或换行符分隔。如果你想连续执行两个echo命令，可以这样：</p>
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo Hello World ; echo Hello World2</span><br></pre></td></tr></table></figure>
<p>或者这样：</p>
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo Hello World</span><br><span class="line">echo Hello World2</span><br></pre></td></tr></table></figure>
<p>除了命令，你还可以在Tcl代码中插入注释。注释以 # 字符开头，并以换行符结束：</p>
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是一个注释</span></span><br><span class="line">echo Hello World</span><br></pre></td></tr></table></figure>
<h4 id="9-3-2-2-Tcl变量"><a href="#9-3-2-2-Tcl变量" class="headerlink" title="9.3.2.2 Tcl变量"></a>9.3.2.2 Tcl变量</h4><p>Tcl中可以使用变量。变量表示某个特定的状态或值。使用Tcl代码，可以查询、定义和修改占位符的值。要定义一个变量，可以使用命令：</p>
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> name value</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> i <span class="number">1</span></span><br><span class="line"><span class="keyword">set</span> myVar foobar</span><br></pre></td></tr></table></figure>
<p>请注意，在Tcl中，内部所有变量都是字符串类型。因为set命令要求一个作为变量值的参数，所以你必须对包含空格的值加引号：</p>
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> Output <span class="string">&quot;Hello World&quot;</span></span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> Output &#123;Hello World&#125;</span><br></pre></td></tr></table></figure>
<p>要替换变量名为varname的值，需要在变量名前加上$符号。表达式$varname将被替换为变量的值。在上面的定义之后：</p>
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="variable">$Output</span></span><br></pre></td></tr></table></figure>
<p>将会在控制台窗口中打印：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello World</span><br></pre></td></tr></table></figure>
<p>同时，</p>
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="string">&quot;$i.) $Output&quot;</span></span><br></pre></td></tr></table></figure>
<p>将输出<code>1.) Hello World</code>。注意，对于使用双引号 “ 括起的字符串，会执行变量替换，但对于使用大括号{}括起的字符串，则不会进行替换。大括号内甚至允许换行符。然而，在Avizo控制台中不可能输入多行命令。</p>
<h4 id="9-3-2-3-Tcl命令替换"><a href="#9-3-2-3-Tcl命令替换" class="headerlink" title="9.3.2.3 Tcl命令替换"></a>9.3.2.3 Tcl命令替换</h4><p>在Tcl中进行数学计算时，可以使用<code>expr</code>命令，该命令将评估其参数并返回表达式的值。例如：</p>
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">expr</span> <span class="number">5</span> / ( <span class="number">7</span> + <span class="number">3</span>)</span><br><span class="line"><span class="keyword">expr</span> <span class="variable">$i</span> + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>为了将像 expr 这样的命令的结果用于后续命令，必须使用 Tcl 中一个重要的机制：命令替换。命令替换由方括号 [] 表示。任何用方括号括起来的列表都会首先作为一个单独的命令执行，[…] 构造将被命令的结果替换。这类似于 Unix 命令 shell 中的反引号构造 …。例如，为了将变量 i 的值增加 1，可以使用：</p>
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> i [<span class="keyword">expr</span> <span class="variable">$i</span> + <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>当然，命令表达式可以任意嵌套。执行顺序总是从最内层的括号对到最外层的括号对：</p>
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo [<span class="keyword">expr</span> <span class="number">5</span> * [<span class="keyword">expr</span> <span class="number">7</span> + [<span class="keyword">expr</span> <span class="number">3</span> + <span class="number">3</span>]]]</span><br></pre></td></tr></table></figure>
<h4 id="9-3-2-4-Tcl-控制结构"><a href="#9-3-2-4-Tcl-控制结构" class="headerlink" title="9.3.2.4 Tcl 控制结构"></a>9.3.2.4 Tcl 控制结构</h4><p>另一个重要的语言元素是 if-else 结构、for 循环和 while 循环。这些结构通常是多行结构，因此不适合在 Avizo 控制台中方便地输入。如果您想尝试下面的示例，可以使用您选择的文本编辑器将它们写入文件，如 C:\test.txt，然后通过输入以下命令执行该文件：</p>
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">source</span> C:\test.txt</span><br></pre></td></tr></table></figure>
<p>首先介绍 if-then 机制。它用于在某个表达式求值为 “true” 时执行一些代码（意思是值不为 0）：</p>
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> a <span class="number">7</span></span><br><span class="line"><span class="keyword">set</span> b <span class="number">8</span></span><br><span class="line"><span class="keyword">if</span> &#123;<span class="variable">$a</span> &lt; <span class="variable">$b</span>&#125; &#123;</span><br><span class="line">    echo <span class="string">&quot;$a is smaller than $b&quot;</span></span><br><span class="line">&#125; elseif &#123;<span class="variable">$a</span> == <span class="variable">$b</span>&#125; &#123;</span><br><span class="line">    echo <span class="string">&quot;$a equals $b&quot;</span></span><br><span class="line">&#125; else &#123;</span><br><span class="line">    echo <span class="string">&quot;$a is greater than $b&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>elseif 和 else 部分是可选的。可以使用多个 elseif 部分，但只能有一个 if 和一个 else 部分。</p>
<p>另一个重要结构是条件循环。像 if 命令一样，它基于检查条件表达式。与 if 不同的是，条件代码会多次执行，只要表达式求值为 true：</p>
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;<span class="keyword">set</span> i <span class="number">1</span>&#125; &#123;<span class="variable">$i</span> &lt; <span class="number">100</span>&#125; &#123;<span class="keyword">set</span> i [<span class="keyword">expr</span> <span class="variable">$i</span>*<span class="number">2</span>]&#125; &#123;</span><br><span class="line">    echo <span class="variable">$i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，这段代码等同于：</p>
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> i <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> &#123;<span class="variable">$i</span> &lt; <span class="number">100</span>&#125; &#123;</span><br><span class="line">    echo <span class="variable">$i</span></span><br><span class="line">    <span class="keyword">set</span> i [<span class="keyword">expr</span> <span class="variable">$i</span> * <span class="number">2</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个循环都会产生输出 1、2、4、8、16、32、64。<br>如果要对列表的所有元素执行循环，还有另一个非常方便的命令：</p>
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> x &#123;<span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">8</span> <span class="number">16</span> <span class="number">32</span> <span class="number">64</span>&#125; &#123;</span><br><span class="line">	echo <span class="variable">$x</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这将生成与上一个示例相同的输出。请注意，括号中的表达式是以空格分隔的单词列表。</p>
<h4 id="9-3-2-5-用户自定义的Tcl过程"><a href="#9-3-2-5-用户自定义的Tcl过程" class="headerlink" title="9.3.2.5 用户自定义的Tcl过程"></a>9.3.2.5 用户自定义的Tcl过程</h4><p>在Tcl中，使用 proc 命令来定义一个新的函数或过程。proc 需要两个参数：一个参数名称列表和要执行的Tcl代码。一旦定义了一个过程，它就可以像任何其他Tcl命令一样使用：</p>
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">proc</span><span class="title"> computeAverageA</span> &#123;a b&#125; &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">expr</span> (<span class="variable">$a</span>+<span class="variable">$b</span>)/<span class="number">2.0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">proc</span><span class="title"> computeAverageB</span> &#123;a b c&#125; &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">expr</span> (<span class="variable">$a</span>+<span class="variable">$b</span>+<span class="variable">$c</span>)/<span class="number">3.0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">echo <span class="string">&quot;average of 2 and 3: [computeAverageA 2 3]&quot;</span></span><br><span class="line">echo <span class="string">&quot;average of 2,3,4: [computeAverageB 2 3 4]&quot;</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，参数列表定义了可以在过程体内使用的局部变量的名称（例如 $a）。return 命令用于定义过程的结果。这个结果是通过方括号 [] 进行命令替换时使用的值。</p>
<p>如果想定义一个具有可变数量参数的过程，必须使用特殊参数名称 args。如果参数列表中只包含这个词，新的命令将接受任意数量的参数，并且这些参数会作为一个列表传递给名为 args 的变量：</p>
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">proc</span><span class="title"> computeAverage</span> args &#123;</span><br><span class="line">    <span class="keyword">set</span> result <span class="number">0</span></span><br><span class="line">    <span class="keyword">foreach</span> x <span class="variable">$args</span> &#123;</span><br><span class="line">        <span class="keyword">set</span> result [<span class="keyword">expr</span> <span class="variable">$result</span> + <span class="variable">$x</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">expr</span> <span class="variable">$result</span> / [<span class="keyword">llength</span> <span class="variable">$args</span>]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，llength 命令返回 args 列表中包含的元素数量。</p>
<p>注意，过程内定义的变量 result 具有局部作用域，这意味着它在过程体外是未知的。此外，全局变量的值在过程内也是未知的，除非使用 global 关键字声明该全局变量：</p>
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> x <span class="number">3</span></span><br><span class="line"><span class="keyword">proc</span><span class="title"> printX</span> &#123;&#125; &#123;</span><br><span class="line">    <span class="keyword">global</span> x</span><br><span class="line">    echo <span class="string">&quot;x的值是 $x&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于过程还有很多内容，例如参数传递、在过程外部上下文中执行命令等。请参阅Tcl参考书以获取这些高级主题。</p>
<h4 id="9-3-2-6-列表和字符串操作"><a href="#9-3-2-6-列表和字符串操作" class="headerlink" title="9.3.2.6 列表和字符串操作"></a>9.3.2.6 列表和字符串操作</h4><p>最后，在这简短的Tcl介绍结束时，我们回到列表的概念。基本上Tcl中的一切都是通过列表构造的，因此了解最重要的列表操作命令以及理解一些微妙的细节是非常重要的。</p>
<p>下面是一个示例，展示了如何获取一个输入的数字列表并构造一个输出列表，其中每个元素的值是输入列表中相应元素的两倍：</p>
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> input [<span class="keyword">list</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line"><span class="keyword">set</span> output [<span class="keyword">list</span>]</span><br><span class="line"><span class="keyword">foreach</span> element <span class="variable">$input</span> &#123;</span><br><span class="line">    <span class="keyword">lappend</span> output [<span class="keyword">expr</span> <span class="variable">$element</span> * <span class="number">2</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以将列表看作是用空格分隔列表元素的简单字符串。这意味着可以不用列表命令来实现与前面例子相同的结果：</p>
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> input <span class="string">&quot;1 2 3 4 5&quot;</span></span><br><span class="line"><span class="keyword">set</span> output <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">foreach</span> element <span class="variable">$input</span> &#123;</span><br><span class="line">    <span class="keyword">append</span> output [<span class="keyword">expr</span> <span class="variable">$element</span> * <span class="number">2</span>] <span class="string">&quot; &quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>append命令类似于lappend，但它只是在现有字符串的末尾添加字符串。当你开始嵌套列表时，列表操作变得更加复杂。嵌套列表用嵌套的大括号表示，例如：</p>
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> input &#123;<span class="number">1</span> <span class="number">2</span> &#123;<span class="number">3</span> <span class="number">4</span> <span class="number">5</span> &#123;<span class="number">6</span> <span class="number">7</span>&#125; <span class="number">8</span> &#125; <span class="number">9</span>&#125;</span><br><span class="line"><span class="keyword">foreach</span> x <span class="variable">$input</span> &#123;</span><br><span class="line">    echo <span class="variable">$x</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此命令的结果将是：</p>
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">5</span> &#123;<span class="number">6</span> <span class="number">7</span>&#125; <span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure>
<p>请注意，当构造列表时，Tcl会自动引用不是单个词的字符串。以下是一个示例：</p>
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> i [<span class="keyword">list</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"><span class="keyword">lappend</span> i <span class="string">&quot;4 5 6&quot;</span></span><br><span class="line">echo <span class="variable">$i</span></span><br></pre></td></tr></table></figure>
<p>将输出：</p>
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> &#123;<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>&#125;</span><br></pre></td></tr></table></figure>
<p>你可以使用lindex命令来访问列表的单个元素。lindex接受两个参数：列表和所需元素的索引号，索引从0开始：</p>
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> i [<span class="keyword">list</span> a b c d e]</span><br><span class="line">echo [<span class="keyword">lindex</span> <span class="variable">$i</span> <span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<p>将输出结果为 c：</p>
<h3 id="9-3-3-Avizo-脚本接口"><a href="#9-3-3-Avizo-脚本接口" class="headerlink" title="9.3.3 Avizo 脚本接口"></a>9.3.3 Avizo 脚本接口</h3><p>尽管 Tcl 语言本身并不是面向对象的，Avizo 的脚本接口是面向对象的。Avizo 项目视图中的每个对象都有一个与之关联的命令。此外，还有几个与 Avizo 中的全局对象（如查看器或 Avizo 主窗口）相关的全局命令。</p>
<p>与项目视图中的对象关联的命令（例如，“Ortho Slice”模块或“Isosurface”模块）仅在该对象存在时才存在。这些命令与项目视图中显示的对象名称相同。通常，特定对象的脚本接口包含许多不同的功能。Avizo 对象相关命令的通用语法是：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;object-name&gt; &lt;command-word&gt; &lt;optional-arguments&gt; ...</span><br></pre></td></tr></table></figure>
<p>例如，如果存在一个名为“Global Axes”的对象（从 Avizo 菜单中选择 View/Axis），那么你可以使用类似以下的命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;GlobalAxes&quot; deselect</span><br><span class="line">&quot;GlobalAxes&quot; select</span><br><span class="line">&quot;GlobalAxes&quot; setIconPosition 100 100</span><br></pre></td></tr></table></figure>
<p>注意：模块名称使用驼峰命名法。命令中可能出现这三个词：“Global Axes”、“GlobalAxes”或 GlobalAxes。</p>
<p>请记住使用 Avizo 控制台提供的自动补全和历史功能（参见第 8.1.13 节“控制台窗口”），以节省打字时间。</p>
<p>如果你已经使用过 Avizo，你可能注意到 Avizo 模块的参数和行为是通过其端口控制的。选择模块时，端口提供了用户界面来更改其值。所有端口也可以通过命令接口控制。其通用语法是：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;object-name&gt; &lt;port-name&gt; &lt;port-command&gt; &lt;optional-arguments&gt; ...</span><br></pre></td></tr></table></figure>
<p>例如，对于“Global Axes”，你可以输入：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;GlobalAxes&quot; options setValue 1 1</span><br><span class="line">&quot;GlobalAxes&quot; thickness setValue 1.5</span><br><span class="line">&quot;GlobalAxes&quot; fire</span><br></pre></td></tr></table></figure>
<p>当你输入这些命令时，你会注意到用户界面中的值会立即更改。然而，模块的计算方法在显式调用 fire 命令之前不会被调用。这允许你先为多个端口设置值，而无需在每个命令之后重新计算。然而请注意，一些模块在连接新输入对象时会自动重置其某些端口。在这种情况下，你可能需要在为每个端口设置值后调用 fire。</p>
<p>通常，端口名称与图形用户界面中显示的文本标签相同，除了删除了空格并且命令名称以小写字母开头。要找出特定模块的所有端口名称，请使用以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;object-name&gt; allPorts</span><br></pre></td></tr></table></figure>
<p>几乎所有端口都提供 setValue 和 getValue 命令。当然，参数数量和语法取决于端口。</p>
<p>对象相关命令类型<code>&lt;object-name&gt; &lt;port-name&gt; setValue ...</code>构成了典型 Avizo 脚本的 90% 以上。然而，除了端口命令外，许多 Avizo 对象还提供其他特定命令。特定模块的命令接口在用户参考指南中有详细描述。当选择模块时，单击属性区域中的“?”按钮可以快速找到相应页面。</p>
<p>作为快速帮助，输入对象名称而不加任何选项将显示该对象可用的所有命令。请注意，这也会显示未记录、未发布和实验性的命令。为了获取有关特定模块或端口命令的更多信息，你可以将其输入控制台窗口而不加任何参数，然后按 F1 键。这将打开帮助浏览器，显示命令的描述。</p>
<p>Avizo 对象是类层次结构的一部分。与 C++ 编程接口类似，脚本命令也可以由派生类从其基类继承。这意味着像轴对象这样的特定对象，除了其自己的特定命令外，还提供其基类中的所有命令。模块文档中提供了指向基类命令的链接。</p>
<h4 id="9-3-3-1-预定义变量"><a href="#9-3-3-1-预定义变量" class="headerlink" title="9.3.3.1 预定义变量"></a>9.3.3.1 预定义变量</h4><p>在Avizo Tcl中存在一些预定义变量，它们具有特殊的含义。这些变量包括：</p>
<ul>
<li><p>AVIZO ROOT: Avizo安装目录。</p>
</li>
<li><p>AVIZO LOCAL: 个人Avizo开发目录（仅限Avizo XPand扩展）。</p>
</li>
<li><p>SCRIPTFILE: 当前正在执行的Tcl脚本文件。</p>
</li>
<li><p>SCRIPTDIR: 当前正在执行的脚本所在的目录。</p>
</li>
<li><p>hideNewModules: 如果设置为1，初始创建的新模块图标将被隐藏。请谨慎设置此变量，并在严格必要时使用。为了避免意外地持续隐藏创建的模块（例如在脚本中断的情况下），应在使用后立即恢复此变量。</p>
</li>
</ul>
<h4 id="9-3-3-2-对象命令"><a href="#9-3-3-2-对象命令" class="headerlink" title="9.3.3.2 对象命令"></a>9.3.3.2 对象命令</h4><p>Avizo模块和数据对象的基本命令接口在用户指南的参考部分的”对象”章节中进行了描述。对象命令的基本语法如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;object&gt; &lt;command&gt; &lt;arguments&gt; ...</span><br></pre></td></tr></table></figure>
<p>其中，<code>&lt;object&gt;</code> 是指对象的名称，<code>&lt;command&gt;</code> 表示要执行的命令。每个模块或数据对象可能定义自己的一组命令，除了其基类定义的命令之外。在”对象”章节中描述的命令由所有模块和数据对象提供。</p>
<p>全局命令将在下一节中介绍。</p>
<h3 id="9-3-4-全局命令"><a href="#9-3-4-全局命令" class="headerlink" title="9.3.4 全局命令"></a>9.3.4 全局命令</h3><p>本节列出了Avizo特定的全局Tcl命令。这些命令中的一些与Avizo中的某些全局对象相关联，如控制台窗口、主窗口或查看器窗口。其他命令如load或echo则不属于此类。以下命令分为不同的子部分：</p>
<p>• viewer command options (viewer)<br>• main window command options (theMain)<br>• console command options (theMsg)<br>• common commands for top-level windows<br>• progress bar command options (workArea)<br>• application command options (app)<br>• other global commands</p>
<ul>
<li>查看器命令选项（viewer）</li>
<li>主窗口命令选项（theMain）</li>
<li>控制台命令选项（theMsg）</li>
<li>顶级窗口的通用命令</li>
<li>进度条命令选项（workArea）</li>
<li>应用程序命令选项（app）</li>
<li>其他全局命令</li>
</ul>
<h4 id="9-3-4-1-视图命令选项"><a href="#9-3-4-1-视图命令选项" class="headerlink" title="9.3.4.1 视图命令选项"></a>9.3.4.1 视图命令选项</h4><p>可以在控制台窗口中输入对视图的命令。语法为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">viewer [&lt;number&gt;] <span class="built_in">command</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>&lt;number&gt;</code> 指定要操作的视图。数值 0 表示主视图，可省略以方便操作。</p>
<h5 id="命令："><a href="#命令：" class="headerlink" title="命令："></a>命令：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">viewer [&lt;number&gt;] snapshot [-offscreen [&lt;width&gt; &lt;height&gt;]] [-stereo] [-alpha] [-tiled &lt;nx&gt; &lt;ny&gt;] &lt;filename&gt; [filename2]</span><br></pre></td></tr></table></figure>
<p>此命令截取当前场景的快照，并将其保存为指定的文件名。图像格式由文件名的扩展名自动决定。支持的格式列表包括：TIFF (.tif, .tiff)、SGI-RGB (.rgb, .sgi, .bw)、JPEG (.jpg, .jpeg)、PNM (.pgm, .ppm)、BMP (.bmp)、PNG (.png) 和 EPS (.eps)。如果没有提供视图编号，将从所有视图中截取快照，前提是从“视图”菜单中选择了2个或4个视图布局。</p>
<p>如果指定了 <code>-offscreen</code> 选项，将使用最大尺寸为 2048x2048 的屏幕外渲染。在这种情况下，即使是视图 0，也需要指定视图编号。如果没有明确指定宽度和高度，图像的尺寸将为当前视图的大小。</p>
<p><strong>注意</strong>： 如果视图中有多个可见的透明对象，并且想使用屏幕外渲染，请将透明度模式设置为“Blend Delayed”，并在拍摄快照之前检查所有对象是否正确渲染。</p>
<p>如果使用了 <code>-stereo</code> 选项，将创建立体模式图像。在这种情况下，filename2 文件可用于指定保存立体图像第二个视图的文件。</p>
<p>如果使用了 <code>-alpha</code> 选项，将创建具有透明背景的快照图像。</p>
<p>如果使用了 <code>-tiled nx ny</code> 选项，将使用 nx 和 ny 指定的拼贴渲染进行渲染，在水平和垂直方向上各渲染nx和ny个拼贴。</p>
<p><code>viewer [&lt;number&gt;] setPosition &lt;x&gt; &lt;y&gt;</code><br>（仅限顶级模式）设置视图窗口相对于屏幕左上角的位置。如果在同一窗口中显示了多个视图，则设置顶级窗口的位置。</p>
<p><code>viewer [&lt;number&gt;] getPosition</code><br>返回视图窗口的位置。如果同一窗口中显示了多个视图，则返回顶级窗口的位置。</p>
<p><code>viewer [&lt;number&gt;] setSize &lt;width&gt; &lt;height&gt;</code><br>（仅限顶级模式）设置视图窗口的大小。宽度和高度指定的是实际的图形区域大小。窗口的大小可能会稍大一些，因为还包括视图装饰和窗口框架。</p>
<p><strong>注意</strong>：当视图未按请求的大小调整时，控制台会打印警告消息。设置新大小时，可能出现以下情况导致视图未能按请求大小调整：</p>
<ul>
<li>视图在顶级窗口中，且给定的大小太小（例如：10x10）。</li>
<li>视图不在顶级窗口中，且主窗口无法调整为更小的尺寸（例如，Mac上的统一标题和工具栏或具有最小宽度的停靠窗口阻止了主窗口调整大小）。</li>
</ul>
<p><code>viewer [&lt;number&gt;] getSize</code><br>返回不带装饰和窗口框架的视图窗口大小。</p>
<p><code>viewer [&lt;number&gt;] setCamera &lt;camera-string&gt;</code><br>恢复所有相机设置。相机字符串应为 getCamera 命令的输出。</p>
<p><code>viewer [&lt;number&gt;] getCamera</code><br>此命令返回当前的相机设置，即位置、方向、焦距、类型和高度角（用于透视相机）或高度（用于正交相机）。这些值以 Avizo 命令的形式返回，可以执行这些命令以恢复相机设置。完整的命令字符串也可以传递给 setCamera 一次执行。</p>
<p><code>viewer [&lt;number&gt;] setCameraPosition &lt;x&gt; &lt;y&gt; &lt;z&gt;</code><br>定义相机在世界坐标中的位置。</p>
<p><code>viewer [&lt;number&gt;] getCameraPosition</code><br>返回相机在世界坐标中的位置。</p>
<p><code>viewer [&lt;number&gt;] setCameraOrientation &lt;x&gt; &lt;y&gt; &lt;z&gt; &lt;a&gt;</code><br>定义相机的方向。默认情况下，相机朝负z方向看，y轴向上。任何其他方向可以作为相对于默认方向的旋转来指定。旋转由一个旋转轴 x y z 以及旋转角度 a（以弧度为单位）指定。</p>
<p><code>viewer [&lt;number&gt;] getCameraOrientation</code><br>以与 setCameraOrientation 相同的格式返回当前相机的方向。</p>
<p><code>viewer [&lt;number&gt;] setCameraFocalDistance &lt;value&gt;</code><br>定义相机的焦距。焦距用于计算在交互查看模式下场景旋转的中心。</p>
<p><code>viewer [&lt;number&gt;] getCameraFocalDistance</code><br>返回当前相机的焦距。</p>
<p><code>viewer [&lt;number&gt;] setCameraHeightAngle &lt;degrees&gt;</code><br>以角度设置透视相机的高度角。减小角度会使视野变小，从而“放大”效果，类似于远摄镜头。如果不专门想改变相机的视野，通常更好的方法是将相机移得更近来放大对象。这条命令对正交相机无效。</p>
<p><code>viewer [&lt;number&gt;] getCameraHeightAngle</code><br>返回透视相机的高度角。</p>
<p><code>viewer [&lt;number&gt;] setCameraHeight &lt;height&gt;</code><br>设置正交相机视图体积的高度。此命令对透视相机无效。</p>
<p><code>viewer [&lt;number&gt;] getCameraHeight</code><br>返回正交相机的高度。</p>
<p><code>viewer [&lt;number&gt;] setCameraType &lt;perspective|orthographic&gt;</code><br>设置相机的类型，参数为透视（perspective）或正交（orthographic）。</p>
<p><code>viewer [&lt;number&gt;] getCameraType</code><br>返回当前相机的类型。</p>
<p><code>viewer [&lt;number&gt;] setTransparencyType &lt;type&gt;</code><br>此命令定义透明对象渲染策略。类型参数是介于0到8之间的数字，分别对应以下透明度模式：Screen Door、Add、Add Delayed、Add Sorted、Blend、Blend Delayed、Blend Sorted、Sorted Layers 和 Sorted Layers Delayed。建议使用模式8以获得最准确的结果，默认使用模式6。</p>
<p><code>viewer [&lt;number&gt;] getTransparencyType</code><br>返回当前使用的透明度模式。</p>
<p><code>viewer [&lt;number&gt;] setSortedLayersNumPasses &lt;value&gt;</code><br>当透明度模式为Sorted Layers或Sorted Layers Delayed时，此命令设置渲染的通过次数。通常，4次通过（默认值）能给出良好的效果。</p>
<p><code>viewer [&lt;number&gt;] getSortedLayersNumPasses</code><br>返回使用的渲染通过次数。</p>
<p><code>viewer [&lt;number&gt;] setBackgroundColor &lt;r&gt; &lt;g&gt; &lt;b&gt;</code><br>设置背景颜色，颜色值可以用RGB整数值（0到255）或小数（0.0到1.0）表示，也可以直接使用文本（如”white”）。</p>
<p><code>viewer [&lt;number&gt;] getBackgroundColor</code><br>返回主背景颜色，以RGB三元组（0到1之间的值）表示。</p>
<p><code>viewer [&lt;number&gt;] setBackgroundColor2 &lt;r&gt; &lt;g&gt; &lt;b&gt;</code><br>设置次背景颜色，次背景颜色用于非均匀背景模式。</p>
<p><code>viewer [&lt;number&gt;] getBackgroundColor2</code><br>返回次背景颜色，以RGB三元组（0到1之间的值）表示。</p>
<p><code>viewer setBackgroundMode &lt;mode&gt;</code><br>允许指定不同的背景模式。如果 mode 设置为 0，将显示均匀的背景。mode 1 表示渐变背景。mode 2 会显示棋盘格模式，这有助于理解透明对象的形状。最后，mode 3 在背景中绘制通过 setBackgroundImage 预定义的图像。</p>
<p><code>viewer getBackgroundMode</code><br>返回当前的背景模式。</p>
<p><code>viewer setBackgroundImage &lt;imagefile&gt; [&lt;imagefile2&gt;] [-stereo]</code><br>此命令允许在查看器背景中放置任意光栅图像。图像不得大于查看器窗口，否则会被裁剪。将通过文件扩展名自动检测图像文件格式，支持的格式与 snapshot 命令相同，除了 EPS 格式外。如果指定了第二个图像文件，并且使用的是立体渲染模式，则此文件将用作右眼图像。如果指定了 -stereo 选项且只有一个图像文件，则假设该文件包含左右眼的组合视图，并将自动分离这些视图。</p>
<p><code>viewer getBackgroundImage</code><br>返回通过 setBackgroundImage 定义的最后一个背景图像文件的文件名。如果指定了一对立体图像，则返回两个文件名。如果 setBackgroundImage 使用了 -stereo 选项，则也会返回该选项。</p>
<p><code>viewer [&lt;number&gt;] setAutoRedraw &lt;state&gt;</code><br>如果 state 为 0，则自动重绘模式关闭。在这种情况下，查看器窗口中的图像不会更新，除非发送 redraw 命令。如果 state 为 1，自动重绘模式再次开启。在脚本中，临时禁用自动重绘模式可能会很有用。</p>
<p><code>viewer [&lt;number&gt;] isAutoRedraw</code><br>返回自动重绘模式是否开启的状态。</p>
<p><code>viewer [&lt;number&gt;] redraw</code><br>此命令强制当前场景重新绘制。如果自动重绘模式已禁用，则只需要进行明确的重绘。</p>
<p><code>viewer [&lt;number&gt;] rotate &lt;degrees&gt; [x|y|z|m|u|v]</code><br>绕轴旋转相机。通过第二个参数指定轴，以下选项可用：x、y、z、m、u、v。</p>
<p>• x: the x-axis (1,0,0)<br>• y: the y-axis (0,1,0<br>• z: the z-axis (0,0,1)<br>• m: the most vertical axis of x, y, or z<br>• u: the viewer’s up direction<br>• v: the view direction</p>
<p>最后一个选项的作用与用户界面的旋转按钮相同。在大多数情况下，m 选项最合适。为了向后兼容，默认值为 u。</p>
<p><code>viewer [&lt;number&gt;] setDecoration &lt;state&gt;</code><br>此命令已废弃。</p>
<p><code>viewer [&lt;number&gt;] saveScene [-b] [-r] [-z] &lt;filename&gt;</code><br>将查看器中显示的所有几何体保存为 Open Inventor 3D 图形格式文件。请注意：由于许多 Avizo 模块使用了自定义的 Open Inventor 节点，场景通常无法在外部程序（如 ivview）中正确显示。可用的选项如下：</p>
<p>-b: 以二进制格式保存 Open Inventor 文件。<br>-r: 保存查看器中显示的几何体以及其他属性。<br>-z: 将 Open Inventor 文件保存为压缩格式（使用 zip 压缩）。</p>
<p><code>viewer [&lt;number&gt;] viewAll</code><br>重置相机，使整个场景可见。此方法会自动在查看器中显示第一个对象时调用。</p>
<p><code>viewer [&lt;number&gt;] show</code><br>打开指定的查看器，并确保查看器窗口位于屏幕上的所有其他窗口之上。</p>
<p><code>viewer [&lt;number&gt;] hide</code><br>关闭指定的查看器。</p>
<p><code>viewer [&lt;number&gt;] isVisible</code><br>此命令显示指定的查看器是否可见。</p>
<p><code>viewer [&lt;number&gt;] fogRange &lt;min&gt; &lt;max&gt;</code><br>设置雾效的衰减范围，该范围可通过视图菜单引入查看器场景。默认范围为 [0, 1]。范围内的值对应于场景点距相机的距离，其中离相机最近的点的值为 0，最远的点的值为 1。限制衰减范围意味着衰减将在指定最小值达到时开始，并在指定最大值达到时达到最大。由于雾效的最大衰减与不可见性相同，因此所有超过最大值的点将显示为背景。</p>
<p><code>viewer [&lt;number&gt;] setVideoFormat pal|ntsc</code><br>设置视图窗口的尺寸为 PAL 601 或 NTSC 601 分辨率，即 720x576 像素或 720x486 像素。当前装饰设置将被考虑在内。</p>
<p><code>viewer [&lt;number&gt;] setVideoFrame &lt;state&gt;</code><br>如果 state 为 1，则在查看器的覆盖平面中显示一个帧。这一帧显示了视频播放器上安全显示图像的区域。设置为 0 则关闭此帧。注意：在覆盖平面中显示的对象不会通过 snapshot 命令保存到文件中。</p>
<p><code>viewer [&lt;number&gt;] getViewerSpinAnimation</code><br>如果查看器旋转动画已启用，返回 1，否则返回 0。</p>
<p><code>viewer [&lt;number&gt;] setViewerSpinAnimation &lt;state&gt;</code><br>如果 state 为 1，启用查看器旋转动画。否则，传递 0 作为状态将关闭查看器旋转动画。注意：查看器旋转动画的状态会保存为首选项，因此重启 Avizo 后仍保持不变。</p>
<p><code>viewer [&lt;number&gt;] setViewing &lt;state&gt;</code><br>开启或关闭查看器的查看状态。如果 state 为 1，查看器进入查看模式；如果为 0，关闭查看模式。</p>
<p>设置查看器的查看状态。如果 state 为 0，查看器切换到交互模式；如果为 1，则切换到查看模式。</p>
<p><code>viewer [&lt;number&gt;] getViewing</code><br>返回当前查看状态：0 表示交互模式，1 表示查看模式。</p>
<p><code>viewer [&lt;number&gt;] linkViewers [&lt;ID&gt;...]</code><br>此命令用于将多个查看器链接在一起。它的操作与相应的 GUI 操作一致。</p>
<p><code>viewer [&lt;number&gt;] unlinkViewers [&lt;ID&gt;...] [all]</code><br>此命令用于取消已链接的查看器。</p>
<h4 id="9-3-4-2-主窗口命令选项"><a href="#9-3-4-2-主窗口命令选项" class="headerlink" title="9.3.4.2 主窗口命令选项"></a>9.3.4.2 主窗口命令选项</h4><p>命令 theMain 允许你访问并控制 Avizo 的主窗口。除了下列列出的特定命令选项外，所有在 9.3.4.4 节（顶层窗口的通用命令）中列出的子命令也可以使用。</p>
<h5 id="命令：-1"><a href="#命令：-1" class="headerlink" title="命令："></a>命令：</h5><p><code>theMain snapshot filename</code><br>创建并保存主窗口的快照图像。图像文件的格式由文件名扩展名决定。任何 Avizo 支持的标准图像文件格式都可以使用，例如 .jpg、.tif、.png 或 .bmp。</p>
<p><code>theMain setViewerTogglesOnIcons &#123;0|1&#125;</code><br>启用或禁用 Avizo 项目视图中对象图标上的橙色查看器切换。</p>
<p><code>theMain ignoreShow [0|1]</code><br>启用或禁用特殊用途的 “no show” 标志。如果设置了该标志，后续的 mainWindow show 命令将被忽略。这对于在 Avizo XScreen 扩展环境中运行标准 Avizo 脚本非常有用。如果不带参数调用该命令，则仅返回标志的当前值。</p>
<p><code>theMain showConsole [0|1]</code><br>启用或禁用 Avizo 中控制台窗口的显示。</p>
<h5 id="9-3-4-3-控制台命令选项"><a href="#9-3-4-3-控制台命令选项" class="headerlink" title="9.3.4.3 控制台命令选项"></a>9.3.4.3 控制台命令选项</h5><p>命令 theMsg 允许您访问和控制 Avizo 控制台窗口。除了下列的特定命令选项外，9.3.4.4 节（顶层窗口的通用命令）中列出的所有子命令也可以使用。</p>
<p>命令：</p>
<p><code>theMsg error &lt;message&gt; [&lt;btn0-text&gt;] [&lt;btn1-text&gt;] [&lt;btn2-text&gt;]</code><br>弹出一个带有指定消息的错误对话框。该对话框可以配置多达三个不同的按钮。命令会阻塞，直到用户按下按钮。返回按下按钮的 ID。</p>
<p><code>theMsg warning &lt;message&gt; [&lt;btn0-text&gt;] [&lt;btn1-text&gt;] [&lt;btn2-text&gt;]</code><br>弹出一个带有指定消息的警告对话框。对话框可以配置多达三个不同的按钮。命令会阻塞，直到用户按下按钮。返回按下按钮的 ID。</p>
<p><code>theMsg question &lt;message&gt; [&lt;btn0-text&gt;] [&lt;btn1-text&gt;] [&lt;btn2-text&gt;]</code><br>弹出一个带有指定消息的问题对话框。该对话框可以配置多达三个不同的按钮。命令会阻塞，直到用户按下按钮。返回按下按钮的 ID。</p>
<p><code>theMsg overwrite &lt;filename&gt;</code><br>弹出一个对话框，询问用户是否可以覆盖指定的文件。如果用户点击“确定”，则返回 1，否则返回 0。</p>
<h4 id="9-3-4-4-顶层窗口的通用命令"><a href="#9-3-4-4-顶层窗口的通用命令" class="headerlink" title="9.3.4.4 顶层窗口的通用命令"></a>9.3.4.4 顶层窗口的通用命令</h4><p>这些命令适用于所有打开独立顶层窗口的 Avizo 对象，特别是 Avizo 主窗口（theMain）、控制台窗口（theMsg）和查看器窗口（viewer 0）。例如，您可以使用相应的全局命令和 setPosition 或 getPosition 来设置或获取这些窗口的位置。</p>
<h5 id="命令：-2"><a href="#命令：-2" class="headerlink" title="命令："></a>命令：</h5><ul>
<li><p><code>getFrameGeometry</code><br>返回窗口的位置和大小，包括窗口框架。共返回四个数字。前两个数字表示窗口框架左上角相对于桌面左上角的位置，后两个数字表示窗口的大小（像素）。</p>
</li>
<li><p><code>getGeometry</code><br>返回窗口的位置和大小，不包括窗口框架。共返回四个数字。前两个数字表示窗口左上角相对于桌面左上角的位置，后两个数字表示窗口的大小（像素）。</p>
</li>
<li><p><code>getPosition</code><br>返回窗口左上角的位置，包括窗口框架。此结果与 getFrameGeometry 返回的前两个数字相同。</p>
</li>
<li><p><code>getRelativeGeometry</code><br>返回窗口的位置和大小，包括窗口框架，以相对坐标表示。桌面的大小为 (1,1)。窗口的位置和大小以 0 到 1 之间的小数表示。</p>
</li>
<li><p><code>getSize</code><br>返回窗口的大小，不包括窗口框架。此结果与 getGeometry 返回的后两个数字相同。</p>
</li>
<li><p><code>hide</code><br>隐藏窗口。</p>
</li>
<li><p><code>setCaption &lt;text&gt;</code><br>设置显示在窗口框架中的窗口标题。</p>
</li>
<li><p><code>setFrameGeometry &lt;x y width height&gt;</code><br>设置窗口的位置和大小，包括窗口框架。需要指定四个数字，即 x 和 y 位置、窗口宽度和高度。</p>
</li>
<li><p><code>setGeometry &lt;x y width height&gt;</code><br>设置窗口的位置和大小，不包括窗口框架。需要指定四个数字，即 x 和 y 位置、窗口宽度和高度。</p>
</li>
<li><p><code>setPosition &lt;x y&gt;</code><br>设置窗口的左上角位置，包括窗口框架。需要指定两个数字，即 x 和 y 坐标。</p>
</li>
<li><p><code>setRelativeGeometry &lt;x y width height&gt;</code><br>以相对桌面大小的比例设置窗口的位置和大小，包括窗口框架。输入值应该在 0 到 1 之间。</p>
</li>
<li><p><code>setSize &lt;width height&gt;</code><br>设置窗口的大小，不包括窗口框架。需要指定两个数字，即窗口的宽度和高度。</p>
</li>
<li><p><code>show</code><br>显示窗口。</p>
</li>
<li><p><code>showMinimized</code><br>使窗口在图标状态下可见。</p>
</li>
<li><p><code>showMaximized</code><br>使窗口在最大化状态下可见</p>
</li>
</ul>
<h4 id="9-3-4-5-进度条命令选项"><a href="#9-3-4-5-进度条命令选项" class="headerlink" title="9.3.4.5 进度条命令选项"></a>9.3.4.5 进度条命令选项</h4><p>workArea 命令允许你访问位于Avizo主窗口底部的进度条。你可以打印信息或检查是否按下了停止按钮。</p>
<h5 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h5><ul>
<li><p><code>workArea setProgressInfo &lt;text&gt;</code><br>设置要显示在进度条中的信息文本。该文本可用于描述某些计算期间的状态。</p>
</li>
<li><p><code>workArea setProgressValue &lt;value&gt;</code><br>设置进度条的值。该参数必须是0到1之间的浮点数。例如，值0.8表示当前任务已经完成了80%。</p>
</li>
<li><p><code>workArea startWorking [&lt;message&gt;]</code><br>激活停止按钮。调用此命令后，Avizo的停止按钮变为活动状态。在脚本中，可以通过调用workArea wasInterrupted来检查是否按下了停止按钮。当停止按钮处于活动状态时，除非在脚本中调用workArea stopWorking，否则无法与其他任何小部件进行交互。因此，不应直接在控制台窗口中输入此命令，而应仅在脚本文件或Tcl过程（procedure）中使用它。</p>
</li>
<li><p><code>workArea stopWorking</code><br>停用停止按钮。当通过workArea startWorking启动的计算任务完成或用户按下停止按钮时，调用此命令。该命令还会恢复调用startWorking之前显示的进度信息文本。</p>
</li>
<li><p><code>workArea wasInterrupted</code><br>检查用户是否按下了停止按钮。此命令应仅在workArea startWorking和workArea stopWorking之间使用。如果有多个嵌套计算任务且用户按下了停止按钮，那么在到达第一级之前，后续所有对wasInterrupted的调用都将返回true。</p>
</li>
</ul>
<h4 id="9-3-4-6-应用程序命令选项"><a href="#9-3-4-6-应用程序命令选项" class="headerlink" title="9.3.4.6 应用程序命令选项"></a>9.3.4.6 应用程序命令选项</h4><p>app 命令提供了与Avizo本身相关的几个选项，而不是特定于某个对象或组件。</p>
<h5 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h5><ul>
<li><p><code>app version</code><br>返回当前的Avizo版本。</p>
</li>
<li><p><code>app uname</code><br>返回简化的操作系统名称。</p>
</li>
<li><p><code>app arch</code><br>返回Avizo的架构字符串，例如arch-Win32VC8-Optimize、arch-LinuxAMD64-Optimize。</p>
</li>
<li><p><code>app hostid</code><br>返回创建Avizo许可证密钥所需的主机ID。</p>
</li>
<li><p><code>app listen [port]</code><br>打开一个套接字，Tcl命令可以通过该套接字发送。可以选择性地指定TCP/IP端口。<br>警告： 这可能会创建安全漏洞。除非在防火墙后且您明确知道自己在做什么，否则请勿使用此功能。</p>
</li>
<li><p><code>app close</code><br>关闭Avizo Tcl端口。</p>
</li>
<li><p><code>app port</code><br>返回Avizo Tcl端口号。如果套接字未打开，则返回-1。</p>
</li>
<li><p><code>app send &lt;command&gt; [&lt;host&gt; [&lt;port&gt;]]</code><br>将Tcl命令发送到监听的Avizo实例。如果未指定主机或端口，则Avizo实例会将命令发送给自己。</p>
</li>
<li><p><code>app opengl</code><br>检索有关所用 OpenGL 驱动程序的信息，包括版本号和支持的扩展。如果报告渲染问题，这些信息可以发送到热线。</p>
</li>
<li><p><code>app cluster</code><br>返回当前节点状态，如果某个集群模式处于活动状态，则该状态可以是“主”或“从”，否则，则简单地为“单个”。</p>
</li>
<li><p><code>app memTotal [-k | -m | -g]</code><br>返回系统的物理内存（以字节为单位）。可选开关 -k、-m、-g 分别将输出转换为千字节、兆字节或千兆字节。</p>
</li>
<li><p><code>app memAvail [-k | -m | -g]</code><br>返回系统的可用内存（以字节为单位）。可选开关 -k、-m、-g 分别将输出转换为千字节、兆字节或千兆字节。请注意，根据操作系统的不同，输出可能与其他工具报告的输出不同。</p>
</li>
</ul>
<h4 id="9-3-4-7-其他全局命令"><a href="#9-3-4-7-其他全局命令" class="headerlink" title="9.3.4.7 其他全局命令"></a>9.3.4.7 其他全局命令</h4><h5 id="命令-2"><a href="#命令-2" class="headerlink" title="命令"></a>命令</h5><ul>
<li><p><code>addTimeout msec procedure [arg]</code><br>安排在 msec 毫秒后调用 Tcl 过程。如果指定了 arg，它将作为参数传递给该过程。指定的过程只会被调用一次。如果需要，您可以在超时过程中再次安排它。例如：addTimeout 10000 echo {10 seconds are over.}</p>
</li>
<li><p><code>all [-selected | -visible | -hidden] [type]</code><br>返回当前在项目视图中的所有 Avizo 对象的列表。如果指定了 type，则只返回具有该 C++ 类类型（或派生对象）的对象。搜索可以分别限于已选择的、可见的或隐藏的对象。例如：all -hidden HxColormap.</p>
</li>
<li><p><code>aminfo [-a outfile|-b outfile] Avizo-File</code><br>如果只使用文件名作为参数，此命令将打开必须是 Avizo 数据格式的文件并打印头信息。如果使用 -a 或 -b 选项，则指定为参数的输出文件 outfile 将分别以 ASCII (-a) 或二进制 (-b) 格式写入。因此，aminfo 可用于将二进制 Avizo 数据转换为 ASCII，反之亦然。</p>
</li>
<li><p><code>clear</code><br>清除控制台窗口。</p>
</li>
<li><p><code>create class name [instance name]</code><br>创建 Avizo 对象（如模块或数据对象）的实例。返回实例名称。请注意，数据对象通常不是通过这种方式创建的，而是通过从文件加载它们。例如：create HxOrthoSlice MySlice.</p>
</li>
<li><p><code>dso options</code><br>控制动态库（“动态共享对象”）的加载。提供以下选项：</p>
</li>
</ul>
<p><code>addPath path ...</code>: 添加路径到加载动态库时搜索的目录列表中。<br><code>verbose &#123;0|1&#125;</code>: 开启或关闭与动态库相关的调试信息。<br><code>open &lt;package&gt;</code>: 尝试加载指定的动态库。只需指定包名，例如 hxfield。此名称将自动转换为平台相关的名称，例如 Linux 上的 libhxfield.so 或 Windows 上的 hxfield.dll。<br><code>unloadPackage &lt;package&gt;</code>: 卸载（如果可能）指定的动态库。<br><code>execute &lt;package&gt; &lt;function&gt;</code>: 执行在指定动态库中定义的函数。</p>
<ul>
<li><p><code>echo args</code><br>将其参数打印到 Avizo 控制台。请使用此命令，而不是原生的 Tcl 命令 puts，后者会打印到标准输出。</p>
</li>
<li><p><code>help arguments</code><br>不带参数时，打开 Avizo 帮助浏览器。</p>
</li>
<li><p><code>httpd [port]</code><br>启动内置的HTTP服务器。HTTP服务器将交付任何请求的文档。如果请求的文档以“.hx”结尾，Avizo将不会交付它，而是将其作为Tcl脚本执行。这可以用于从网页浏览器控制Avizo。<strong>警告：</strong>该命令可能会产生安全漏洞，除非你在防火墙后且清楚自己在做什么，否则不要使用此功能。</p>
</li>
<li><p><code>limit &#123;datasize | stacksize | coredumpsize&#125; size</code><br>更改进程限制。仅适用于Unix平台。使用“unlimited”作为无限制的大小。大小必须以字节为单位指定。或者，你可以使用1000k表示1000千字节或1m表示1兆字节。</p>
</li>
<li><p><code>load [fileformat] options files</code><br>从一个或多个文件中加载数据。可以选择指定文件格式以覆盖Avizo的自动文件格式识别。文件格式使用与在Avizo文件对话框中的文件格式组合框中显示的标签相同。使用全局命令fileFormats可以获得Avizo支持的所有文件格式列表。可以使用FTP或HTTP协议读取远程文件。</p>
</li>
</ul>
<p>其他选项包括：</p>
<ul>
<li><code>browse</code>：显示打开数据窗口。</li>
<li><code>avizoscript</code>：打开Avizo脚本文件。</li>
<li><code>avizo</code>：Avizo的本地通用文件格式。用于加载许多不同的数据对象，如在规则或四面体网格上定义的字段、分割结果、颜色映射或顶点集（如地标）。</li>
<li><code>dataOnly</code>：阻止导入器创建显示模块，适用于hx文件。</li>
</ul>
<p>继续翻译如下：</p>
<ul>
<li><code>load [fileformat] options files</code></li>
</ul>
<p>从一个或多个文件中加载数据。可以选择指定文件格式以覆盖Avizo的自动文件格式识别。文件格式使用与在Avizo文件对话框中的文件格式组合框中显示的标签相同。使用全局命令fileFormats可以获得Avizo支持的所有文件格式列表。可以使用FTP或HTTP协议读取远程文件。</p>
<p>其他选项包括：</p>
<ul>
<li>browse：显示打开数据窗口。</li>
<li>avizoscript：打开Avizo脚本文件。</li>
<li>avizo：Avizo的本地通用文件格式。用于加载许多不同的数据对象，如在规则或四面体网格上定义的字段、分割结果、颜色映射或顶点集（如地标）。</li>
<li>dataOnly：阻止导入器创建显示模块，适用于hx文件。</li>
</ul>
<p>Options for raw data:<br>load -raw FileName Endianess IndexOrder<br>DataType nDataVar dimX dimY dimZ<br>xMin xMax yMin yMax zMin zMax</p>
<p>Options for DICOM data:</p>
<ul>
<li><p>nodialog: option prevent the Dicom dialog box from being shown.</p>
</li>
<li><p><code>mem</code><br>Prints out some memory statistics.</p>
</li>
<li><p><code>quit</code><br>Immediately quits Avizo.</p>
</li>
<li><p><code>remove fobjectname | -all | -selectedg</code><br>Removes objects from Project View.<br>• objectname: the specified Avizo object.<br>• -all: all objects.<br>• -selected: selected objects.</p>
</li>
</ul>
<p>从项目视图中删除对象。<br>• objectname：指定的 Avizo 对象。<br>• -all：所有对象。<br>• -selected：选定对象。</p>
<ul>
<li><p><code>removeTimeout procedure [arg]</code><br>Unschedules a Tcl procedure previously scheduled with addTimeout.<br>取消先前使用 addTimeout 安排的 Tcl 过程。</p>
</li>
<li><p><code>rename objectname newname</code><br>Changes instance name of an object. Identical to objectname setLabel newname, except that it<br>returns 1 if successful, and nothing if unsuccessful.<br>更改对象的实例名称。与 objectname setLabel newname 相同，不同之处在于如果成功则返回 1，如果不成功则不返回任何内容。</p>
</li>
<li><p><code>sleep sec</code><br>Waits for sec seconds. Avizo will not process events in that time.<br>等待 sec 秒。Avizo 将不会在这段时间内处理事件。</p>
</li>
<li><p><code>source filename</code><br>Loads and executes Tcl commands from the specified file. If the script file contains the extension<br>.hx, the load command may be used as well.<br>从指定文件加载并执行 Tcl 命令。如果脚本文件包含扩展名 .hx，也可以使用加载命令。</p>
</li>
<li><p><code>system command</code><br>Executes an external program. Do not use this unless you know what you are doing.<br>执行外部程序。除非您知道自己在做什么，否则不要使用此功能。</p>
</li>
<li><p><code>saveProject</code><br>Saves current project. If the project is not previously saved, then the project will be saved in the<br>Avizo root dir as Untitled.hx.<br>保存当前项目。如果之前未保存该项目，则该项目将作为 Untitled.hx 保存在 Avizo 根目录中。</p>
</li>
<li><p><code>saveProjectAs [-forceAutoSave | -packAndGo] arg</code><br>A copy of the current project will be saved as arg in Avizo root dir.(e.g., saveProjectAs<br>myProject). When using a path, a full path needs to be specified and a .hx extension needs to be<br>added on the project name (e.g., saveProjectAs c:/work/myProject.hx). Optionally, a<br>forceAutoSave parameter can be specified to force auto saving of modified data without displaying<br>a warning dialog. If parameter packAndGo is specified, in the same folder where the project file<br>is saved, a new folder will be created and it will contain all data necessary for loading the saved<br>project. Note: If a file exists it will not be overwritten.<br>当前项目的副本将作为 arg 保存在 Avizo 根目录中。（例如，saveProjectAs<br>myProject）。使用路径时，需要指定完整路径，并在项目名称上添加 .hx 扩展名（例如，saveProjectAs c:/work/myProject.hx）。或者，可以指定 forceAutoSave 参数以强制自动保存修改后的数据而不显示警告对话框。如果指定了参数 packAndGo，则在保存项目文件的同一文件夹中，将创建一个新文件夹，其中包含加载已保存项目所需的所有数据。注意：如果文件存在，则不会覆盖它。</p>
</li>
<li><p><code>theObjectPool setSelectionOrder ffirst objectg fsecond objectg...</code><br>This command reorders the selection so that it matches the given object order. Selected objects not contained inside this list will be moved at the end of the selection (their relative order will not be<br>changed though).<br>此命令将重新排列所选内容，使其与给定的对象顺序相匹配。不包含在此列表中的所选对象将移动到所选内容的末尾（但它们的相对顺序不会改变）。</p>
</li>
<li><p><code>thePreferences [save | load] filename</code><br>This command saves or loads preferences to/from the file specified as filename.<br>此命令将首选项保存到指定为文件名的文件中，或从指定为文件名的文件中加载首选项。</p>
</li>
<li><p><code>theProperties [show | hide]</code><br>This command shows or hides the Properties panel in Avizo.<br>此命令显示或隐藏 Avizo 中的属性面板。</p>
</li>
<li><p><code>theProjectView [show | hide]</code><br>This command shows or hides the Project View panel in Avizo.<br>此命令显示或隐藏 Avizo 中的项目视图面板。</p>
</li>
<li><p><code>fileFormats</code><br>Shows all file formats which can be used in Avizo.<br>显示可在 Avizo 中使用的所有文件格式。</p>
</li>
</ul>
<h3 id="9-3-5-Avizo-脚本文件"><a href="#9-3-5-Avizo-脚本文件" class="headerlink" title="9.3.5 Avizo 脚本文件"></a>9.3.5 Avizo 脚本文件</h3><p>值得注意的是，一个 Avizo 项目本质上就是一个 Tcl 脚本，它能够重新生成当前的 Avizo 状态。因此，通常可以通过交互式地创建一个 Avizo 项目，将其保存为“保存项目”，并使用它作为脚本编写的起点。</p>
<p>在 Avizo 中执行 Tcl 命令的最简单方式是在 Avizo 控制台窗口中输入命令。然而，对于像循环或过程这样的多行结构，使用这种方式并不实用。在这种情况下，建议将 Tcl 代码写入文件，并通过 source 文件名 命令执行该文件。你还可以在一个文件中使用 source 命令以包含另一个文件的内容。</p>
<p>另一种方法是使用 load 文件名 命令或通过文件菜单中的“打开项目…”选项并使用文件浏览器加载文件。不过，要让 Avizo 识别该文件格式，文件名必须以 .hx 结尾，或者文件内容必须以以下标题行开头：</p>
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Avizo Script</span></span><br></pre></td></tr></table></figure>
<p>在 Avizo 启动时，有一些 Tcl 文件会被自动加载。启动时，程序会查找当前目录或主目录中的 .Avizo 文件（详见 9.2.3 节，启动脚本）。如果没有找到这样的用户自定义启动脚本，默认的初始化脚本 Avizo.init 将从 $AVIZO_LOCAL/share/resources/Avizo 或 $AVIZO_ROOT/share/resources/Avizo 目录加载。该脚本随后会读取所有 .rc 文件，这些文件用于注册模块和数据类型。因此，用户可以通过简单地向该目录添加新的 .rc 文件或修改 Avizo.init 文件来自定义 Avizo 的启动行为。</p>
<p>另一种执行 Tcl 代码的方式是定义与功能键相关联的过程。如果存在名为 onKeyF2、onKeyF3、…、onKeyShiftF2、…、onKeyCtrlF2、… 等的预定义过程，当相应的键在 Avizo 主窗口、控制台窗口或查看器窗口中按下时，这些过程将被自动调用。要定义这些过程，可以将其写入一个文件并使用 source 加载，或者将其写入 Avizo.init 或某个 .rc 文件中。例如：</p>
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">proc</span><span class="title"> onKeyF2</span> &#123; &#125; &#123;</span><br><span class="line">  echo <span class="string">&quot;Key F2 was hit&quot;</span></span><br><span class="line">  viewer <span class="number">0</span> viewAll</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：<br>某些功能键已保留给 Avizo 特定的操作。例如，[F1] 永远用于帮助，[F2] 在项目视图或树视图中用于对象重命名。</p>
<p>最后，Tcl 脚本也可以在 GUI 中表示并与用户界面结合使用。在 Avizo 中，这被称为脚本模块。</p>
<h3 id="9-3-6-配置弹出菜单"><a href="#9-3-6-配置弹出菜单" class="headerlink" title="9.3.6 配置弹出菜单"></a>9.3.6 配置弹出菜单</h3><p>在 Avizo 中，所有可以附加到数据对象的模块都会列在对象的弹出菜单中，该菜单通过右键单击对象图标激活。对于某些应用来说，在创建新模块后使用 Tcl 命令自定义这些模块是有意义的。有时还需要在对象的弹出菜单中添加新条目，以执行特定的脚本。本节将介绍如何通过修改 Avizo 资源文件或创建新文件来实现这些目标。</p>
<p>Avizo 的资源文件位于目录 $AVIZO_ROOT/share/resources 中，其中 $AVIZO_ROOT 表示 Avizo 的安装目录。资源文件实际上是普通的脚本文件，只是使用 .rc 作为后缀。当 Avizo 启动时，资源目录中的所有资源文件都会被读取。在资源文件中，可以使用特殊的 Tcl 命令注册模块、编辑器和 IO 例程。注册一个模块意味着指定它在弹出菜单中的名称，它可以附加的对象类型，模块所在的共享库或 DLL 的名称，等等。例如，Multi-Thresholding 模块通过以下命令在文件 hxlattice.rc 中注册：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module -name &quot;Multi-Thresholding&quot; \</span><br><span class="line">-check &#123; ![$PRIMARY hasInterface HxLabelLattice3] &amp;&amp;</span><br><span class="line"><span class="meta prompt_">([$</span><span class="language-bash">PRIMARY primType]&lt;3 || [<span class="variable">$PRIMARY</span> primType]==7 || [<span class="variable">$PRIMARY</span> primType]==8) &#125; \</span></span><br><span class="line"><span class="language-bash">-primary <span class="string">&quot;HxUniformScalarField3 HxStackedScalarField3&quot;</span> \</span></span><br><span class="line"><span class="language-bash">-category <span class="string">&quot;&#123;Image Segmentation&#125;&quot;</span> \</span></span><br><span class="line"><span class="language-bash">-class <span class="string">&quot;HxLabelVoxel&quot;</span> \</span></span><br><span class="line"><span class="language-bash">-dso <span class="string">&quot;libhxlattice.so&quot;</span></span></span><br></pre></td></tr></table></figure>
<p>该命令的不同选项具有以下含义：</p>
<ul>
<li>选项 -name 指定模块的名称或标签，它将显示在弹出菜单中。</li>
<li>选项 -primary 表示该模块可以附加到类型为 HxUniformScalarField3 或 HxStackedScalarField3 的数据对象上。这意味着 Multi-Thresholding 只会包含在这些对象的弹出菜单中。</li>
<li>选项 -check 指定一个附加的 Tcl 表达式，该表达式在菜单弹出之前会被执行。如果表达式失败，模块将从菜单中删除。对于 Multi-Thresholding 模块，它会检查输入对象是否提供了 HxLabelLattice3 接口，即输入是否是一个标签场。尽管标签图像可以被视为 3D 图像，但对其进行阈值分割是没有意义的。因此，Multi-Thresholding 仅对原始 3D 图像提供，而不适用于标签场。还会检查输入的原始数据类型（有符号/无符号整数、浮点、短整型等）。这里，Multi-Thresholding 模块不支持浮点或双精度标签图像输入。</li>
<li>选项 -category 表示 Multi-Thresholding 应该出现在主弹出菜单的 “Image Segmentation” 子菜单中。如果模块不应出现在子菜单中，而是直接在弹出菜单中显示，则应使用类别 Main。</li>
<li>选项 -class 指定模块的内部类名称。对象的内部类名称可以使用命令 getTypeId 检索。正是这个类名称必须用于上述的 -primary 选项，而不是通过 -name 定义的对象标签。</li>
<li>最后，选项 -package 指定定义该模块的包（共享库或 DLL）。</li>
</ul>
<p>除了这些标准选项，还可以使用额外的 -proc 选项指定在创建模块后执行的额外 Tcl 命令。例如，假设你在一个医疗项目中，需要识别头部 CT 图像中的立体定位标记。此时，可以在弹出菜单中添加一个 Multi-Thresholding 模块的自定义版本，并预定义适当的材质名称和阈值。可以通过在 $AVIZO_ROOT/share/resources 目录中添加一个新资源文件，或者直接在 hxlattice.rc 文件中添加以下命令来实现：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">module -name &quot;Stereotaxy&quot; \</span><br><span class="line">-primary &quot;HxUniformScalarField3 HxStackedScalarField3&quot; \</span><br><span class="line">-check &#123; ![$PRIMARY hasInterface HxLabelLattice3] &#125; \</span><br><span class="line">-category &quot;&#123;Image Segmentation&#125;&quot; \</span><br><span class="line">-class &quot;HxLabelVoxel&quot; \</span><br><span class="line">-package &quot;hxlattice&quot; \</span><br><span class="line">-proc &#123; $this regions setValue &quot;Exterior Bone Markers&quot;; \</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">this fire; \</span></span><br><span class="line"><span class="language-bash"><span class="variable">$this</span> boundary01 setValue 150; \</span></span><br><span class="line"><span class="language-bash"><span class="variable">$this</span> boundary12 setvalue 300 &#125;</span></span><br></pre></td></tr></table></figure>
<p>上述 Tcl 代码中的变量 $this 指的是新创建的模块，即 Multi-Thresholding 模块。注意，这些命令是在模块连接到弹出菜单的源对象之前执行的。某些模块在连接到新的输入对象时会进行一些特殊的初始化，这些初始化可能会覆盖使用自定义 -proc 选项通过 Tcl 命令设置的值。在这种情况下，可以通过以下命令显式连接模块到输入对象：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">this data connect <span class="variable">$PRIMARY</span>;</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">this fire;</span></span><br></pre></td></tr></table></figure>
<p>其中 Tcl 变量 $PRIMARY 指的是输入对象。同样，该变量也用于上述 -check 选项中定义的 Tcl 表达式。</p>
<p>除了基于现有模块创建自定义弹出菜单条目外，还可以定义完全新的条目，这些条目只执行 Tcl 命令。例如，我们可以在每个 Avizo 对象的弹出菜单中添加一个新的子菜单“编辑”，并在此处放入通常包含在 Avizo 主窗口的“编辑”菜单中的“隐藏”、“删除”和“复制”命令。这可以通过以下方式实现：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">module -name &quot;Remove&quot; \</span><br><span class="line">    -primary &quot;HxObject&quot; \</span><br><span class="line">    -proc &#123; remove $PRIMARY &#125; \</span><br><span class="line">    -category &quot;Edit&quot;</span><br><span class="line">module -name &quot;Hide&quot; \</span><br><span class="line">    -primary &quot;HxObject&quot; \</span><br><span class="line">    -proc &#123; $PRIMARY hideIcon &#125; \</span><br><span class="line">    -category &quot;Edit&quot;</span><br><span class="line">module -name &quot;Duplicate&quot; \</span><br><span class="line">    -primary &quot;HxData&quot; \</span><br><span class="line">    -proc &#123; $PRIMARY duplicate &#125; \</span><br><span class="line">    -category &quot;Edit</span><br></pre></td></tr></table></figure>
<p>当然，也可以使用 <code>-proc</code> 命令执行普通的 Avizo 脚本，甚至 Avizo 脚本对象。</p>
<h3 id="9-3-7-注册点击回调函数"><a href="#9-3-7-注册点击回调函数" class="headerlink" title="9.3.7 注册点击回调函数"></a>9.3.7 注册点击回调函数</h3><p>点击回调函数是附加到模块或查看器上的 Tcl 过程。当点击事件发生在目标上时，会调用该回调函数。可以通过在模块或查看器上使用 Tcl 命令 setPickCallback 来注册此类回调：</p>
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;module&gt; setPickCallback &lt;<span class="keyword">proc</span>&gt; [&lt;EventType&gt;]<span class="title"></span></span><br><span class="line"><span class="title">viewer</span> &lt;n&gt;<span class="title"> setPickCallback</span> &lt;<span class="keyword">proc</span>&gt; [&lt;EventType&gt;]</span><br></pre></td></tr></table></figure>
<p>每个模块或查看器只能附加一个回调。为了分离回调，只需调用注册命令而不带参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;module&gt; setPickCallback</span><br><span class="line">viewer &lt;n&gt; setPickCallback</span><br></pre></td></tr></table></figure>
<p>可选的 <code>&lt;EventType&gt;</code> 参数用于指定触发回调的事件类型。其他事件将被忽略。该参数可以取以下值：</p>
<ul>
<li>MouseButtonPress, MouseButtonRelease（任意鼠标按钮）</li>
<li>VRButtonPress, VRButtonRelease（任意3D按钮）</li>
<li>MouseButton1Press, MouseButton1Release 等（特定的鼠标按钮）</li>
<li>VRButton0Press, VRButton0Release 等（特定的3D按钮）</li>
</ul>
<p>默认值为 MouseButton1Press。</p>
<p>实际的回调过程 <code>&lt;proc&gt;</code> 预期接收一个参数，该参数被解释为一个关联数组，并编码所有点击信息。定义的元素如下：</p>
<ul>
<li>object：被点击几何体所属的 Avizo 对象的名称</li>
<li>x：被点击点的 x 坐标</li>
<li>y：被点击点的 y 坐标</li>
<li>z：被点击点的 z 坐标</li>
<li>idx：被点击元素的索引</li>
<li>stateBefore：事件发生之前的修饰符状态</li>
<li>stateAfter：事件发生之后的修饰符状态</li>
</ul>
<p>回调过程应返回 0，如果未处理点击事件，这样其他回调过程可以被调用。以下是一个示例：</p>
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">proc</span><span class="title"> pickCallback</span> arg &#123;</span><br><span class="line">    <span class="keyword">array</span> <span class="keyword">set</span> a <span class="variable">$arg</span></span><br><span class="line">    echo <span class="string">&quot;$a(object) : picked element $a(idx)&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，任何模块都可以向该参数数组添加特定信息。所有元素可以通过以下方式显示：</p>
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">proc</span><span class="title"> pickCallback</span> arg &#123;</span><br><span class="line">    echo <span class="string">&quot;arg = &#123; $arg &#125;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，一些 Avizo 模块会追加额外的数据：</p>
<ul>
<li>Vertex View：idx 是被点击的点索引</li>
<li>Point Cloud View：idx 是被点击的点索引</li>
<li>Line Set View：idx 是被点击的线索引，pt0 和 pt1 是被点击段的两个点</li>
<li>Surface View：idx 是被点击的三角形索引</li>
<li>Hexa/Tetra Grid View：idx 是被点击的三角形索引，tetra0 和 tetra1 是相邻的四面体</li>
<li>Grid Boundary：idx 是被点击的三角形索引，originalIdx 是网格中的索引，tetra0 和 tetra1 是相邻的四面体</li>
</ul>
<h3 id="9-3-8-文件读取器在Tcl中"><a href="#9-3-8-文件读取器在Tcl中" class="headerlink" title="9.3.8 文件读取器在Tcl中"></a>9.3.8 文件读取器在Tcl中</h3><p>本节介绍如何注册一个由Tcl实现的自定义文件读取器。</p>
<p>首先，需要在全局作用域中声明Tcl读取器函数。该函数必须接受一个文件列表作为输入参数，并返回成功读取的文件数量。</p>
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">proc</span><span class="title"> myReaderInTcl</span> &#123;args&#125; &#123;</span><br><span class="line">    echo <span class="string">&quot;myReaderInTcl $args&quot;</span></span><br><span class="line"><span class="comment">    # 其他相关处理</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着，必须使用以下模板将Tcl读取器函数注册到目标文件格式声明中：</p>
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataFile -name <span class="string">&quot;MyFormat&quot;</span> ... -<span class="keyword">package</span> hxcore -<span class="keyword">load</span> hxReadByTcl -loadArgs <span class="string">&quot;-cmd myReaderInTcl&quot;</span></span><br></pre></td></tr></table></figure>
<p>使用 -loadArgs 来指定自定义的Tcl读取器函数。参数 -package hxcore -load hxReadByTcl 需按原样填写，不做修改。这些参数用于设置内部包装器，该包装器将调用Tcl解释器。</p>
<p>可以在Tcl脚本中声明自定义读取器，或将其包含在一个资源文件中，在应用程序启动时加载。</p>
<h2 id="9-4-使用-MATLAB-与-Avizo"><a href="#9-4-使用-MATLAB-与-Avizo" class="headerlink" title="9.4 使用 MATLAB 与 Avizo"></a>9.4 使用 MATLAB 与 Avizo</h2><p>本节介绍如何在 Avizo 中使用 MATLAB 脚本。</p>
<h3 id="9-4-1-使用-MATLAB-脚本"><a href="#9-4-1-使用-MATLAB-脚本" class="headerlink" title="9.4.1 使用 MATLAB 脚本"></a>9.4.1 使用 MATLAB 脚本</h3><p>在本教程中，您将学习如何通过使用 MATLAB 计算模块（The MathWorks, Inc.）将复杂的计算集成到 Avizo 中。</p>
<p>为了使用 MATLAB 计算模块，MATLAB 必须正确安装在您的计算机上。此外，为了使该模块能够与 MATLAB 计算引擎建立连接，您可能需要注册 MATLAB 引擎（在 Windows 上），并根据您的系统设置环境变量以包含 MATLAB 库或程序在搜索路径中。请参阅 MATLAB 计算模块的文档以了解安装细节和限制。</p>
<p>本教程，作为在线文档提供，涵盖了以下主题，通过各种示例进行讲解：</p>
<ul>
<li>加载和执行 MATLAB 脚本。</li>
<li>在 Avizo 和 MATLAB 之间传递各种数据类型，并将数据导出回 Avizo。</li>
<li>使用字段结构。</li>
<li>使用时间滑块控制脚本变量。</li>
<li>从脚本中调用用户自定义的 MATLAB 函数。</li>
<li>你可以通过这些步骤来学习如何将 MATLAB 的复杂计算功能与 Avizo 集成，从而执行更加精确和复杂的数据处理任务。</li>
</ul>
<h1 id="Python-Scripting"><a href="#Python-Scripting" class="headerlink" title="Python Scripting"></a>Python Scripting</h1><p><a target="_blank" rel="noopener" href="https://www.thermofisher.cn/cn/zh/home/electron-microscopy/products/software-em-3d-vis/3d-visualization-analysis-software/python-scripting.html">Amira-Avizo Software and PerGeos Software Python Integration</a></p>
<p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=tUlZFJj-aYs">Amira-Avizo Software | Introduction to Python scripting</a></p>
<p><a href="D:\Program Files\Avizo-2019.1\share\doc\python\html\index.html">Thermo Fisher Python API documentation</a></p>
<h2 id="11-6-Python-脚本编写"><a href="#11-6-Python-脚本编写" class="headerlink" title="11.6 Python 脚本编写"></a>11.6 Python 脚本编写</h2><p>本节描述了如何在Avizo中使用Python脚本。</p>
<h3 id="11-6-1-Python-文档"><a href="#11-6-1-Python-文档" class="headerlink" title="11.6.1 Python 文档"></a>11.6.1 Python 文档</h3><p>本章按如下方式组织：</p>
<p>11.6.1.1 Python 简介<br>11.6.1.2 内嵌 Python 的使用<br>11.6.1.3 常见的全局命令<br>11.6.1.4 模块管理<br>11.6.1.5 脚本对象<br>11.6.1.6 Python 环境和包管理器<br>11.6.1.7 Python 包列表<br>Avizo Python API 文档可以在此处查看。</p>
<blockquote>
<p>安装文件’\share\doc\python\html\index.html’</p>
</blockquote>
<h4 id="11-6-1-1-Python-简介"><a href="#11-6-1-1-Python-简介" class="headerlink" title="11.6.1.1 Python 简介"></a>11.6.1.1 Python 简介</h4><p>什么是Python</p>
<p>Python是一种高级的、面向对象的、解释型语言，首次实现于1989年。<br>(<a target="_blank" rel="noopener" href="https://www.python.org/dev/peps/pep-0020/">https://www.python.org/dev/peps/pep-0020/</a>)</p>
<p>• Beautiful is better than ugly<br>• Explicit is better than implicit<br>• Simple is better than complex<br>• Complex is better than complicated<br>• Readability counts</p>
<ul>
<li>美比丑好</li>
<li>明确比隐含好</li>
<li>简单比复杂好</li>
<li>复杂比难懂好</li>
<li>可读性很重要</li>
<li>包含的内容</li>
</ul>
<p>Avizo 使用 Python 3.5.2。关于如何使用Python 3.X的详细信息可以在以下链接找到：<br><a target="_blank" rel="noopener" href="https://docs.python.org/3.5/tutorial/index.html">https://docs.python.org/3.5/tutorial/index.html</a> 。许多包都已包含在Python的安装中（参见此处的Python包列表）。Numpy 和 Scipy 是此安装中包含的两个最流行的Python包。</p>
<p>Numpy 是用于处理多维数组的扩展，它允许元素操作、比较、逻辑操作、统计等。Numpy数组在C中实现，计算速度更快。更多信息请参见：<a target="_blank" rel="noopener" href="http://www.numpy.org/">http://www.numpy.org/</a> 。</p>
<p>Scipy 是一个提供科学计算工具的扩展，例如插值、积分、图像处理、线性代数、信号处理和统计。更多信息请参见：<a target="_blank" rel="noopener" href="http://www.scipy.org/">http://www.scipy.org/</a> 。</p>
<p>从 Python 2 迁移到 Python 3</p>
<p>Python 2 和 Python 3 之间存在一些兼容性问题。关于迁移到Python 3的官方文档可以在这里找到：<br><a target="_blank" rel="noopener" href="https://docs.python.org/3.5/howto/pyporting.html">https://docs.python.org/3.5/howto/pyporting.html</a> 。</p>
<h5 id="11-6-1-1-1-使用-Python"><a href="#11-6-1-1-1-使用-Python" class="headerlink" title="11.6.1.1.1 使用 Python"></a>11.6.1.1.1 使用 Python</h5><p>本节并不旨在涵盖Python语言的所有应用和细节。要了解更多关于Python、Scipy和Numpy的信息，请参阅前一节中的链接。要了解Python如何与Avizo交互，请继续阅读第11.6.1.2节《内嵌Python的使用》。</p>
<h6 id="Python控制台"><a href="#Python控制台" class="headerlink" title="Python控制台"></a>Python控制台</h6><p>可以通过 Windows &gt; Consoles 访问控制台。控制台面板具有带有多个不同工具的标签界面。控制台充当Python解释器，因此任何编写的命令在按Enter键后将立即执行。执行后将显示赋值或返回值。</p>
<img src="/2024/09/19/AVIZO%E8%87%AA%E5%8A%A8%E5%8C%96/Figure11.4.png" class="" title="Figure 11.4: Accessing the Consoles">
<img src="/2024/09/19/AVIZO%E8%87%AA%E5%8A%A8%E5%8C%96/Figure11.5.png" class="" title="Figure 11.5: Main Python Console Interface">
<img src="/2024/09/19/AVIZO%E8%87%AA%E5%8A%A8%E5%8C%96/Figure11.6.png" class="" title="Figure 11.6: Python Script Object Console Interface">
<p>从左到右图标：</p>
<ul>
<li>删除此内容：删除此解释器中显示的所有内容</li>
<li>删除 Pythonic 对象：这会从 Avizo 的工作区中删除控制台内创建的所有 Python 对象</li>
<li>重定向所有输出：这会将所有解释器的所有输出推送到主控制台</li>
<li>重定向此输出：这会将所有当前控制台的输出推送到主控制台</li>
</ul>
<p>控制台充当 Python 解释器，因此按下 Enter 后将立即执行任何书面命令。执行后将显示赋值或返回值。</p>
<h6 id="常用快捷键和命令"><a href="#常用快捷键和命令" class="headerlink" title="常用快捷键和命令"></a>常用快捷键和命令</h6><ul>
<li><p><code>TAB</code><br>在控制台没有编写任何内容时，按下TAB键会自动补全以下命令 hx_project.get(module)，该命令将为对象创建一个Python句柄。当控制台中有文本时，TAB键将尝试从可用方法、属性和模块列表中自动补全当前字符串。选中的项目会被补全。</p>
</li>
<li><p><code>UP</code> or <code>DOWN</code><br>这些按钮可以循环浏览您最近的历史记录。UP按钮可以检索上一个命令，而DOWN按钮可以检索后续命令。</p>
</li>
</ul>
<h5 id="11-6-1-1-2-关于Python的注意事项"><a href="#11-6-1-1-2-关于Python的注意事项" class="headerlink" title="11.6.1.1.2 关于Python的注意事项"></a>11.6.1.1.2 关于Python的注意事项</h5><h6 id="软件包"><a href="#软件包" class="headerlink" title="软件包"></a>软件包</h6><p>Python是一种面向对象的语言，这意味着代码通常会被分解为类，在实例化时变量和方法可以被对象继承。</p>
<p>这种方式可以避免重复编写经常使用的功能。关于Python面向对象编程（OOP）的更多信息，可以在以下链接中找到：<a target="_blank" rel="noopener" href="http://www.tutorialspoint.com/python/python_classes_objects.htm">Python类和对象教程</a>。</p>
<p>软件包是类、方法和变量的集合，可以被导入到Python的命名空间中。例如，如果用户想要计算sin(π/2)，首先需要将Numpy软件包导入命名空间：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">import</span> numpy</span><br></pre></td></tr></table></figure>
<p>Numpy软件包包含一个sin(x)方法，可以用于计算sin(π/2)：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;numpy.sin(<span class="number">3.1415</span>/<span class="number">2</span>)</span><br><span class="line"><span class="number">0.99999999892691405</span></span><br></pre></td></tr></table></figure>
<p>Numpy已经包含了一个全局变量π，可以通过以下方式访问：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;numpy.pi</span><br><span class="line"><span class="number">3.141592653589793</span></span><br><span class="line">&gt;&gt;&gt;numpy.sin(numpy.pi/<span class="number">2</span>)</span><br><span class="line"><span class="number">1.0</span></span><br></pre></td></tr></table></figure>
<p>导入软件包时，可以将其赋值给变量以简化代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">&gt;&gt;&gt;np.sin(np.pi/<span class="number">2</span>)</span><br><span class="line"><span class="number">1.0</span></span><br></pre></td></tr></table></figure>
<h6 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h6><p>Python支持多种不同的对象类型：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Number</td>
<td style="text-align:center">Integers, floats, complex, booleans</td>
<td style="text-align:center">1, 1.05, 3j+2, 3&gt;2 is True</td>
</tr>
<tr>
<td style="text-align:center">String List</td>
<td style="text-align:center">Sequence of characters Container to group items that can be changed</td>
<td style="text-align:center">“String of charaters” [1, 5, “Dragon”, 948.5]</td>
</tr>
<tr>
<td style="text-align:center">Tuple</td>
<td style="text-align:center">Container to group items that cannot be changed</td>
<td style="text-align:center">(948.5, “Dragon”, 5, 1)</td>
</tr>
<tr>
<td style="text-align:center">Dictionary</td>
<td style="text-align:center">Associated arrays with unique keys</td>
<td style="text-align:center">{‘a’:99, ’b’:’red’, ’c’:’balloons’}</td>
</tr>
<tr>
<td style="text-align:center">Array</td>
<td style="text-align:center">Vectorized numeric array optimized for C</td>
<td style="text-align:center">numpy.ones ((10,5))</td>
</tr>
</tbody>
</table>
</div>
<p>有些类型通过特定的字符标识。例如，单引号或双引号用于创建字符串：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;a = <span class="string">&#x27;这是一个字符串。&#x27;</span></span><br><span class="line">&gt;&gt;&gt;b = <span class="string">&quot;这也是一个字符串。&quot;</span></span><br></pre></td></tr></table></figure>
<p>列表通过方括号进行赋值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;c = [<span class="number">1</span>, <span class="number">5</span>, <span class="string">&quot;Dragon&quot;</span>, <span class="number">948.5</span>]</span><br></pre></td></tr></table></figure>
<p>对象之间可以使用标准语法进行操作：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+  加法        ==  相等</span><br><span class="line">-  减法        !=  不相等</span><br><span class="line">*  乘法        &gt;  大于</span><br><span class="line">/  除法        &lt;  小于</span><br><span class="line">** 指数运算    &lt;= 小于或等于</span><br><span class="line"><span class="meta prompt_">% </span><span class="language-bash"> 取余数      &gt;= 大于或等于</span></span><br></pre></td></tr></table></figure>
<p>某些关键词是保留用于全局变量或执行特定功能的。应尽量避免将这些关键词作为变量使用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">and</span>, <span class="keyword">as</span>, <span class="keyword">assert</span>, <span class="keyword">break</span>, <span class="keyword">class</span>, <span class="keyword">continue</span>, <span class="keyword">def</span>, <span class="keyword">del</span>, <span class="keyword">elif</span>, <span class="keyword">else</span>, <span class="keyword">except</span>, <span class="built_in">exec</span>, <span class="keyword">finally</span>, <span class="keyword">for</span>, <span class="keyword">from</span>, <span class="keyword">global</span>, <span class="keyword">if</span>, <span class="keyword">import</span>, <span class="keyword">in</span>, <span class="keyword">is</span>, <span class="keyword">lambda</span>, <span class="keyword">not</span>, <span class="keyword">or</span>, <span class="keyword">pass</span>, <span class="built_in">print</span>, <span class="keyword">raise</span>, <span class="keyword">return</span>, <span class="keyword">try</span>, <span class="keyword">while</span>, <span class="keyword">with</span>, <span class="keyword">yield</span></span><br></pre></td></tr></table></figure>
<p>关于Python语法和对象类型的更深入的讨论可以在官方教程中找到：<a target="_blank" rel="noopener" href="https://docs.python.org/3.5/tutorial/index.html">Python官方教程</a>。</p>
<h4 id="11-6-1-2-嵌入式Python的使用"><a href="#11-6-1-2-嵌入式Python的使用" class="headerlink" title="11.6.1.2 嵌入式Python的使用"></a>11.6.1.2 嵌入式Python的使用</h4><h5 id="11-6-1-2-1-概述"><a href="#11-6-1-2-1-概述" class="headerlink" title="11.6.1.2.1 概述"></a>11.6.1.2.1 概述</h5><p>与TCL类似，Python已通过Pythonic API在Avizo中实现。Avizo的特定命令允许你访问模块中包含的信息和功能。通过Python与Avizo进行交互有两种主要方式。第一种方式是通过Python控制台，它与TCL控制台分离，这是一个解释器。控制台的基本功能，如Tab自动补全，已经在第11.6.1.1节“Python简介”中描述。</p>
<p>第二种方式是通过脚本模块在Avizo中使用Python。Python脚本模块允许你继承预定义的PyScriptObject类的属性，然后覆盖这些属性，以创建与Avizo集成的扩展。脚本模块的行为类似于Avizo中的常规模块，并可以通过资源文件伴随出现在对象弹出菜单中。资源文件仍然必须用TCL编写。PyScriptObject类中包含以下四种方法，供你方便使用：</p>
<ul>
<li><code>__init__()</code>：构造函数方法，可以包含在项目视图中创建脚本对象时运行的代码。</li>
<li><code>update()</code>：可以调用update方法来更新脚本对象在属性面板中的GUI。</li>
<li><code>compute()</code>：通常包含主要代码的compute方法应在需要进行计算时调用。</li>
<li><code>__del__()</code>：这个析构函数方法可以包含帮助在删除模块时清理命名空间的代码。</li>
</ul>
<h5 id="11-6-1-2-2-示例：与模块交互"><a href="#11-6-1-2-2-示例：与模块交互" class="headerlink" title="11.6.1.2.2 示例：与模块交互"></a>11.6.1.2.2 示例：与模块交互</h5><p>以下是如何通过控制台与项目视图中的模块交互的一个示例，通过创建一个正交切片并更改其属性：</p>
<p>1、确保在工作区显示Python控制台。</p>
<p>2、打开 <code>$AVIZO_ROOT/data/tutorials/chocolate-bar.am</code>。</p>
<ul>
<li>如果启用了自动视图，将会自动创建一个正交切片。删除它。</li>
</ul>
<p>3、要创建正交切片，请在<code>HxProject</code>类中访问<code>create()</code>方法。<code>create()</code>方法要求我们传递我们要创建的对象的类型ID作为字符串参数。</p>
<ul>
<li>如果你不确定对象的类型ID，可以在GUI中创建对象，然后使用TCL控制台中的<code>&lt; module &gt;</code> getTypeId命令来了解其类型。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>hx_project.create(<span class="string">&#x27;HxOrthoSlice&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>4、现在我们需要将正交切片连接到 <code>chocolate-bar.am</code>，但首先我们会使用 get() 方法将正交切片分配给变量，以便以后更容易访问。我们也会对 <code>chocolate-bar.am</code> 执行相同操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;ortho = hx_project.get(<span class="string">&#x27;Ortho Slice&#x27;</span>)</span><br><span class="line">&gt;&gt;&gt;input_data = hx_project.get(<span class="string">&#x27;chocolate-bar.am&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>5、为了将正交切片连接到 <code>chocolate-bar.am</code>，我们需要查看如何访问正交切片的 Data 端口。通过在控制台中打印 <code>portnames</code> 命令的结果，展示可供交互的端口列表：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;ortho.portnames</span><br><span class="line">[<span class="string">&#x27;data&#x27;</span>, <span class="string">&#x27;origin&#x27;</span>, <span class="string">&#x27;normal&#x27;</span>, <span class="string">&#x27;frameSettings&#x27;</span>, ...]</span><br></pre></td></tr></table></figure>
<p>6、从 <code>portnames</code> 命令可以看到 <code>data</code> 端口可能对应于正交切片属性中显示的”Data数据”连接。使用 <code>ports</code> 层级中的 <code>connect()</code> 方法将 <code>chocolate-bar.am</code> 连接到这个端口，然后使用 <code>fire()</code> 方法应用更改：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;ortho.ports.data.connect(input_data)</span><br><span class="line">&gt;&gt;&gt;ortho.fire()</span><br></pre></td></tr></table></figure>
<p>7、我们还可以通过设置 sliceNumber 端口的值来更改切片位置：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;ortho.ports.sliceNumber.value = <span class="number">100</span></span><br><span class="line">&gt;&gt;&gt;ortho.fire()</span><br></pre></td></tr></table></figure>
<p>8、尝试正交切片中的其他端口，查看是否可以更改切片方向和色彩图。要访问这些端口的帮助，可以将 access 命令传递给 help() 方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="built_in">help</span>(ortho.ports.sliceOrientation)</span><br></pre></td></tr></table></figure>
<p>9、通过将它们传递给 help() 方法，进一步了解可供操作的方法和类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="built_in">help</span>(ortho.fire)</span><br></pre></td></tr></table></figure>
<h5 id="11-6-1-2-3-示例：开发脚本"><a href="#11-6-1-2-3-示例：开发脚本" class="headerlink" title="11.6.1.2.3 示例：开发脚本"></a>11.6.1.2.3 示例：开发脚本</h5><p>在本示例中，我们将编写一个简单的脚本来计算数据集边界框的总体积。该脚本可以直接在Avizo的Python控制台中输入，也可以在文本编辑器中输入命令，然后将其复制到Python控制台执行。</p>
<p>1、加载 <code>$AVIZO_ROOT/data/tutorials/chocolate-bar.am</code>。</p>
<p>2、将 <code>chocolate-bar.am</code> 分配给一个变量，以便在后续代码中快速引用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;data = hx_project.get(<span class="string">&#x27;chocolate-bar.am&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>3、创建一个边界框并将其附加到 <code>chocolate-bar.am</code> 上。</p>
<ul>
<li>你可以在创建时直接将边界框分配给一个变量，而不是在单独的命令中创建它后再使用 get() 方法获取。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;bbox = hx_project.create(<span class="string">&#x27;HxBoundingBox&#x27;</span>)</span><br><span class="line">&gt;&gt;&gt;bbox.ports.data.connect(data)</span><br><span class="line">&gt;&gt;&gt;bbox.fire()</span><br></pre></td></tr></table></figure>
<p>4、检索边界框在 X、Y 和 Z 方向的范围，以计算其体积。已经存在一个可以使用的边界框命令，该命令以元组的形式存储这些信息，定义为 <code>((xmin, ymin, zmin), (xmax, ymax, zmax))</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="built_in">type</span>(data.bounding_box)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;tuple&#x27;</span>&gt;</span><br><span class="line">&gt;&gt;&gt;data.bounding_box</span><br><span class="line">((<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>),</span><br><span class="line">(<span class="number">0.02807999961078167</span>,</span><br><span class="line"><span class="number">0.020880000665783882</span>,</span><br><span class="line"><span class="number">0.035280000418424606</span>))</span><br></pre></td></tr></table></figure>
<p>5、Python还可以很容易地从这个两列表元组中提取两个变量。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;min_bounds, max_bounds = data.bounding_box</span><br></pre></td></tr></table></figure>
<p>6、使用方括号 <code>[ ]</code> 访问最小和最大边界列表中的每个索引，并将这些信息插入公式中，以计算框的体积。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;x_extent = max_bounds[<span class="number">0</span>] - min_bounds[<span class="number">0</span>]</span><br><span class="line">&gt;&gt;&gt;y_extent = max_bounds[<span class="number">1</span>] - min_bounds[<span class="number">1</span>]</span><br><span class="line">&gt;&gt;&gt;z_extent = max_bounds[<span class="number">2</span>] - min_bounds[<span class="number">2</span>]</span><br><span class="line">&gt;&gt;&gt;volume = x_extent * y_extent * z_extent</span><br></pre></td></tr></table></figure>
<p>7、最后，以精确的格式将信息打印到控制台。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="built_in">print</span>(<span class="string">&#x27;The volume of %s is %.g.&#x27;</span> % (data.name, volume))</span><br></pre></td></tr></table></figure>
<h5 id="11-6-1-2-4-示例：创建一个函数"><a href="#11-6-1-2-4-示例：创建一个函数" class="headerlink" title="11.6.1.2.4 示例：创建一个函数"></a>11.6.1.2.4 示例：创建一个函数</h5><p>在本例中，我们将边界框体积计算器封装到一个函数中，该函数接受输入数据作为参数，并将答案返回到控制台。关于函数和Python语法的一些注意事项：</p>
<ul>
<li>如果你在Avizo控制台中直接执行，请按<code>SHIFT+ENTER</code>键以输入一个换行符，而不执行代码。</li>
<li>Python要求在函数体内保持一致的缩进。最佳实践是将代码体缩进四个空格（而不是Tab键）。</li>
<li>Avizo中的Python控制台不会为用户自动缩进行，用户必须自行控制缩进。</li>
</ul>
<p>1、加载 <code>$AVIZO_ROOT/data/tutorials/chocolate-bar.am</code><br>2、使用<code>def</code>关键字定义一个名为<code>bbVol</code>的函数，该函数接受单个输入数据集作为参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">bbVol</span>(<span class="params">data_arg</span>):  <span class="comment"># 记住这里要按SHIFT+ENTER键！</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>3、解释器中会显示省略号，表示它正在等待更多代码输入。在此时手动输入四个空格，然后像之前一样，将最小和最大边界框列表赋给变量。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">... </span>min_bounds, max_bounds = data_arg.bounding_box</span><br></pre></td></tr></table></figure>
<p>4、按下<code>SHIFT+ENTER</code>键以创建新行，再次输入四个空格，然后继续执行体积计算器的其余部分。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">... </span>x_extent = max_bounds[<span class="number">0</span>] - min_bounds[<span class="number">0</span>]</span><br><span class="line"><span class="meta">... </span>y_extent = max_bounds[<span class="number">1</span>] - min_bounds[<span class="number">1</span>]</span><br><span class="line"><span class="meta">... </span>z_extent = max_bounds[<span class="number">2</span>] - min_bounds[<span class="number">2</span>]</span><br><span class="line"><span class="meta">... </span>volume = x_extent * y_extent * z_extent</span><br></pre></td></tr></table></figure>
<p>5、最后，添加一个<code>return</code>语句将<code>volume</code>变量返回到控制台。这允许你将计算结果设置为一个变量。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">... </span><span class="keyword">return</span> volume</span><br></pre></td></tr></table></figure>
<p>6、通过按<code>ENTER</code>键执行函数定义，然后使用<code>chocolate-bar.am</code>测试代码。测试将计算结果分配给变量的能力。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bbVol(hx_project.get(<span class="string">&#x27;chocolate-bar.am&#x27;</span>))</span><br><span class="line">The volume of chocolate-bar.am is2e-05。</span><br><span class="line"><span class="number">2e-05</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>chocolatebar_volume = bbVol(hx_project.get(<span class="string">&#x27;chocolate-bar.am&#x27;</span>))</span><br></pre></td></tr></table></figure>
<h4 id="11-6-1-3-常用全局命令"><a href="#11-6-1-3-常用全局命令" class="headerlink" title="11.6.1.3 常用全局命令"></a>11.6.1.3 常用全局命令</h4><p>在 Avizo 的 Python 环境中，有两个主要的函数可以帮助用户探索 Python 的结构。<br><code>dir()</code> 函数允许用户查看给定对象可用的属性和方法的列表。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;ortho = hx_project.get(<span class="string">&#x27;Ortho Slice&#x27;</span>)</span><br><span class="line">&gt;&gt;&gt;<span class="built_in">dir</span>(ortho)</span><br><span class="line">[<span class="string">&#x27;__class__&#x27;</span>, <span class="string">&#x27;__delattr__&#x27;</span>, <span class="string">&#x27;__dir__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__eq__&#x27;</span>, <span class="string">&#x27;__format__&#x27;</span>, <span class="string">&#x27;__ge__&#x27;</span>, <span class="string">&#x27;__getattribute__&#x27;</span>, <span class="string">&#x27;__gt__&#x27;</span>, <span class="string">&#x27;__hash__&#x27;</span>, <span class="string">&#x27;__init__&#x27;</span>, <span class="string">&#x27;__le__&#x27;</span>, <span class="string">&#x27;__lt__&#x27;</span>, <span class="string">&#x27;__ne__&#x27;</span>, <span class="string">&#x27;__new__&#x27;</span>, <span class="string">&#x27;__pyx_vtable__&#x27;</span>, <span class="string">&#x27;__reduce__&#x27;</span>, <span class="string">&#x27;__reduce_ex__&#x27;</span>, <span class="string">&#x27;__repr__&#x27;</span>, <span class="string">&#x27;__setattr__&#x27;</span>, <span class="string">&#x27;__sizeof__&#x27;</span>, <span class="string">&#x27;__str__&#x27;</span>, <span class="string">&#x27;__subclasshook__&#x27;</span>, <span class="string">&#x27;_cpp_classname&#x27;</span>, <span class="string">&#x27;_cpp_package&#x27;</span>, <span class="string">&#x27;_tcl_interp&#x27;</span>, <span class="string">&#x27;all_interfaces&#x27;</span>, <span class="string">&#x27;can_be_renamed&#x27;</span>, <span class="string">&#x27;clip_geometry&#x27;</span>, <span class="string">&#x27;compute&#x27;</span>, <span class="string">&#x27;create_doc_file&#x27;</span>, <span class="string">&#x27;create_port_snaps&#x27;</span>, <span class="string">&#x27;downstream_connections&#x27;</span>, <span class="string">&#x27;duplicate&#x27;</span>, <span class="string">&#x27;execute&#x27;</span>, <span class="string">&#x27;fire&#x27;</span>, <span class="string">&#x27;get_all_interface_names&#x27;</span>, <span class="string">&#x27;icon_color&#x27;</span>, <span class="string">&#x27;icon_position&#x27;</span>, <span class="string">&#x27;icon_visible&#x27;</span>, <span class="string">&#x27;is_geometry_clipped&#x27;</span>, <span class="string">&#x27;is_same_object&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;need_saving&#x27;</span>, <span class="string">&#x27;portnames&#x27;</span>, <span class="string">&#x27;ports&#x27;</span>, <span class="string">&#x27;removable&#x27;</span>, <span class="string">&#x27;selected&#x27;</span>, <span class="string">&#x27;unclip_geometry&#x27;</span>, <span class="string">&#x27;update&#x27;</span>, <span class="string">&#x27;viewer_mask&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>这些信息也可以在你开始输入命令时通过下拉列表显示。</p>
<img src="/2024/09/19/AVIZO%E8%87%AA%E5%8A%A8%E5%8C%96/Figure11.7.png" class="" title="Figure 11.7: Pulldown List of Commands">
<p><code>help()</code> 函数提供了有关属性和方法的详细信息及其使用的示例。<br><code>help()</code> 的输出还包含有关相关父类的信息。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="built_in">help</span>(ortho)</span><br><span class="line">Help on HxPlanarModBase <span class="built_in">object</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HxPlanarModBase</span>(<span class="title class_ inherited__">HxModule</span>)</span><br><span class="line">| This <span class="keyword">is</span> the first <span class="keyword">class</span> <span class="title class_">of</span> HxBase hierarchy which represents items that can be added to the project view.</span><br><span class="line">|</span><br><span class="line">| Method resolution order:</span><br><span class="line">| 	HxPlanarModBase</span><br><span class="line">| 	HxModule</span><br><span class="line">| 	HxObject</span><br><span class="line">| 	HxBase</span><br><span class="line">| 	McInterface</span><br><span class="line">| 	builtins.<span class="built_in">object</span></span><br><span class="line">|</span><br><span class="line">| Methods defined here:</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">| all_interfaces</span><br><span class="line">| Attribute that contains <span class="built_in">all</span> admissible interfaces <span class="keyword">as</span> sub-members.</span><br><span class="line">|</span><br><span class="line">| Examples</span><br><span class="line">| --------</span><br><span class="line">|</span><br><span class="line">| Retrieve an ‘HxBase‘ interface on an orthoslice:</span><br><span class="line">|</span><br><span class="line">| &gt;&gt;&gt; ortho = hx_project.create(’HxOrthoSlice’)</span><br><span class="line">| &gt;&gt;&gt; base = ortho.all_interfaces.HxBase</span><br></pre></td></tr></table></figure>
<p>下方列出了一些更具体的全局命令：</p>
<ul>
<li><code>print()</code> 是 Python 的原生命令，用于在 Avizo 中的 Python 控制台输出结果。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;x = <span class="number">3</span></span><br><span class="line">&gt;&gt;&gt;y = <span class="number">2</span></span><br><span class="line">&gt;&gt;&gt;<span class="built_in">print</span>(<span class="string">&#x27;The sum of %i + %i is %i.&#x27;</span> % (x,y,x+y))</span><br><span class="line">The <span class="built_in">sum</span> of <span class="number">3</span> + <span class="number">2</span> <span class="keyword">is</span> <span class="number">5.</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>import</code> 是 Python 的原生命令，用于通过加载额外的包来扩展 Python 的功能。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;x = <span class="number">3</span></span><br><span class="line">&gt;&gt;&gt;y = <span class="number">2</span></span><br><span class="line">&gt;&gt;&gt;<span class="keyword">import</span> numpy</span><br><span class="line">&gt;&gt;&gt;numpy.add(x,y)</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>一些用于与项目视图交互的有用全局函数包含在 <code>hx_project</code> 方法中。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">hx_project.create()</td>
<td style="text-align:center">创建某个 Avizo 类的实例并将其添加到项目视图中</td>
</tr>
<tr>
<td style="text-align:center">hx_project.remove()</td>
<td style="text-align:center">从项目视图中删除对象</td>
</tr>
<tr>
<td style="text-align:center">hx_project.add()</td>
<td style="text-align:center">将对象添加到项目视图中</td>
</tr>
<tr>
<td style="text-align:center">hx_project.load()</td>
<td style="text-align:center">当指定了文件名时加载定义格式的数据</td>
</tr>
</tbody>
</table>
</div>
<p><code>hx_paths</code> 方法还提供了包含目录路径的变量。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">变量</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">hx_paths.install.dir</td>
<td style="text-align:center">安装目录，也称为 &lt;$AVIZO_ROOT&gt;</td>
</tr>
<tr>
<td style="text-align:center">hx_paths.tutorials.dir</td>
<td style="text-align:center">教程数据目录</td>
</tr>
<tr>
<td style="text-align:center">hx_paths.python_modules.dir</td>
<td style="text-align:center">包含额外包的 Python 模块目录</td>
</tr>
<tr>
<td style="text-align:center">hx_paths.python_script_objects.dir</td>
<td style="text-align:center">包含用户创建的自定义 Python 脚本的 Python 脚本对象目录</td>
</tr>
<tr>
<td style="text-align:center">hx_paths.executable_dir</td>
<td style="text-align:center">包含 Avizo.exe 的目录</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;hx_paths.install_dir</span><br><span class="line"><span class="string">&#x27;C:/Program Files/&lt;INSTALL DIR&gt;&#x27;</span></span><br><span class="line">&gt;&gt;&gt;hx_paths.tutorials_dir</span><br><span class="line"><span class="string">&#x27;C:/Program Files/&lt;INSTALL DIR&gt;/data/tutorials&#x27;</span></span><br><span class="line">&gt;&gt;&gt;hx_paths.python_modules_dir</span><br><span class="line"><span class="string">&#x27;C:/Program Files/&lt;INSTALL DIR&gt;/share/python_modules&#x27;</span></span><br><span class="line">&gt;&gt;&gt;hx_paths.python_script_objects_dir</span><br><span class="line"><span class="string">&#x27;C:/Program Files/&lt;INSTALL DIR&gt;/share/python_script_objects&#x27;</span></span><br><span class="line">&gt;&gt;&gt;hx_paths.executable_dir</span><br><span class="line"><span class="string">&#x27;C:\\Program Files\\&lt;INSTALL DIR&gt;\\bin\\arch-Win64VC12-Optimize\\Avizo.exe&#x27;</span></span><br></pre></td></tr></table></figure>
<h4 id="11-6-1-4-模块管理"><a href="#11-6-1-4-模块管理" class="headerlink" title="11.6.1.4 模块管理"></a>11.6.1.4 模块管理</h4><p>一个包含许多代码片段的完整参考手册，解释了如何配置所有端口和模块，可以从Python参考帮助菜单项中访问。</p>
<h5 id="11-6-1-4-1-模块属性"><a href="#11-6-1-4-1-模块属性" class="headerlink" title="11.6.1.4.1 模块属性"></a>11.6.1.4.1 模块属性</h5><h6 id="什么是属性"><a href="#什么是属性" class="headerlink" title="什么是属性"></a>什么是属性</h6><p>属性是类中包含的数据字段。有些属性可能是只读的。</p>
<h6 id="常见属性列表"><a href="#常见属性列表" class="headerlink" title="常见属性列表"></a>常见属性列表</h6><p>这里的变量 “a” 指的是你的对象的 Python 句柄。</p>
<p><code>a.name</code>:<br>这是一个字符串属性，指的是你的 Avizo 对象的名称。可以分配一个字符串来更改对象的显示名称。</p>
<p><code>a.portnames</code>:<br>这是一个只读列表，包含属于 Avizo 对象的所有端口名称。</p>
<p><code>a.viewer_mask</code>:<br>这是一个整数属性，触发视图中的可见性。有16个配置，可以从 [0, 15] 中设置。如果使用了该范围之外的数字，该数字将在执行模16操作后评估。</p>
<p><code>a.bounding_box</code>:<br>这存储了一对元组，描述对象的空间维度。可以以 ((xmin, ymin, zmin), (xmax, ymax, zmax)) 的格式分配新的维度。</p>
<p><code>a.downstream_connections[x]</code>:<br>这存储了一个只读序列，显示引用它的所有对象。每个连接都分配了一个整数索引 “x”。要从指针中找到对象的名称，可以使用命令 a.downstream_connections[x].get_owner().name</p>
<p><code>a.range</code>:<br>这存储了一个只读的元组，显示数据的强度范围，格式为 (min, max)。</p>
<p><code>a.transform</code>:<br>这存储了一个显示 4x4 转换矩阵的元组。可以分配一个新的转换矩阵。</p>
<h6 id="11-6-1-4-2-模块方法"><a href="#11-6-1-4-2-模块方法" class="headerlink" title="11.6.1.4.2 模块方法"></a>11.6.1.4.2 模块方法</h6><h6 id="什么是方法"><a href="#什么是方法" class="headerlink" title="什么是方法"></a>什么是方法</h6><p>方法是类中包含的函数。许多方法不需要参数。</p>
<h6 id="常见方法列表"><a href="#常见方法列表" class="headerlink" title="常见方法列表"></a>常见方法列表</h6><p>这里的变量 “a” 指的是你的对象的 Python 句柄。</p>
<p><code>a.compute()</code>:<br>如果 a.ports.doIt.was_hit = True，则此方法执行对象的计算。这模拟了在条件允许时单击应用按钮。</p>
<p><code>a.update()</code>:<br>此方法更新对象 GUI 的属性窗口。</p>
<p><code>a.fire()</code>:<br>此方法调用 a.update() 和 a.compute()。</p>
<p><code>a.execute()</code>:<br>此方法结合了上述所有方法，模拟了单击应用按钮并刷新 GUI。</p>
<p><code>a.get_array()</code>:<br>此方法访问对象的 NumPy 数组。访问该数组将阻止对象删除。</p>
<p><code>a.set_array(...)</code>:<br>此方法将 NumPy 数组分配给对象。数组的所有权不会传递，因此未来对数组的更改不会传播，除非重新分配。</p>
<h4 id="11-6-1-5-脚本对象"><a href="#11-6-1-5-脚本对象" class="headerlink" title="11.6.1.5 脚本对象"></a>11.6.1.5 脚本对象</h4><h5 id="11-6-1-5-1-什么是-Python-脚本对象"><a href="#11-6-1-5-1-什么是-Python-脚本对象" class="headerlink" title="11.6.1.5.1 什么是 Python 脚本对象"></a>11.6.1.5.1 什么是 Python 脚本对象</h5><p>Python 脚本对象是一个计算模块，其行为在继承自 PyScriptObject 的 Python 类中进行硬编码。Python 脚本对象对于创建自定义工具非常有用，其功能可通过与 Avizo 计算模块相同的方式访问。</p>
<h6 id="脚本结构"><a href="#脚本结构" class="headerlink" title="脚本结构"></a>脚本结构</h6><p>当你将 Python 脚本对象定义为类时，以下类方法非常有用，但并不要求必须这样定义。任何脚本都会像在控制台中输入的那样运行。变量 self 指代其类的标识。</p>
<p><code>def init(self)</code>:<br>此方法在对象创建时调用。在此处定义脚本结构并设置 GUI 是非常有用的。</p>
<p><code>def del(self)</code>:<br>此方法在对象重新启动或删除时调用。这是清理连接的好地方。</p>
<p><code>def update(self)</code>:<br>当 GUI 需要刷新时调用此方法。</p>
<p><code>def compute(self)</code>:<br>当单击“应用”时调用此方法。</p>
<p>注意：Python 脚本对象的执行是在单独的 Python 解释器上完成的，并且有自己的 Python 控制台。但是，请注意，在某些特殊情况下，例如来自 PyQt 插槽的消息打印，流式传输可能会重定向到主 Python 解释器。</p>
<h6 id="创建端口"><a href="#创建端口" class="headerlink" title="创建端口"></a>创建端口</h6><p>用户通过端口与对象进行交互。端口可以通过简单的分配进行初始化，它们属于 <code>HxPort</code> 类。以下是一些有用的端口：</p>
<p><code>HxConnection</code><br>此端口类允许用户连接模块。模块的类型也可以限制。</p>
<p><code>HxPortFilename</code><br>此端口类允许用户加载或保存文件。端口的功能由 mode 属性定义。文件名可以以文本形式输入或通过文件浏览器访问。</p>
<p><code>HxPortIntSlider</code><br>此端口类包含一个可以通过滑动比例访问的整数值范围。此端口用于定义“Ortho Slice”模块的切片编号。</p>
<p><code>HxPortDoIt</code><br>此端口类控制自动刷新框，并处理应用按钮。</p>
<p><code>HxPortInfo</code><br>此端口类用于为用户提供说明、备注或警告。文本可以在模块属性中找到。</p>
<h6 id="Bounding-Box-脚本示例"><a href="#Bounding-Box-脚本示例" class="headerlink" title="Bounding Box 脚本示例"></a>Bounding Box 脚本示例</h6><p>在本例中，我们将 Bounding Box 体积计算器（在“嵌入式 Python 使用”一章中描述）封装成一个脚本模块，可以通过对象弹出菜单加载到 Avizo GUI 中。</p>
<p>1、打开文本编辑器并创建一个新文件，结构如下。将对象命名为 <code>BoundingBoxVolume</code>。</p>
<ul>
<li>你也可以从 <code>$AVIZO_ROOT/share/python_script_objects/PythonScriptObjectTemplate.pyscro</code> 模板开始。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BoundingBoxVolume</span>(<span class="title class_ inherited__">PyScriptObject</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 这里是初始化代码</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 这里是更新代码</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">compute</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 这里是计算代码</span></span><br></pre></td></tr></table></figure>
<p>2、脚本对象需要能够连接到数据对象，以便知道需要计算体积的 Bounding Box。默认情况下，Python 脚本对象从 <code>PyScriptObject</code> 类继承数据连接。确保它在<code>__init__()</code> 方法中可见。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">    self.data.visible = <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>3、在此示例中，使用 pass 关键字跳过 update() 方法中的 GUI 更新，因为没有需要更新的端口。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>4、在 <code>compute()</code> 方法中，我们希望在没有数据对象连接到脚本模块时停止体积计算。添加一个 <code>if</code> 语句检查数据连接是否为空。如果数据连接为空，使用 <code>return</code> 语句退出 <code>compute()</code> 方法。</p>
<ul>
<li>Python 使用 None 关键字来简化此操作（即：<code>if &lt;expression&gt; is None</code>）</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">compute</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="comment"># 检查是否连接了输入数据</span></span><br><span class="line">    <span class="keyword">if</span> self.<span class="built_in">input</span>.source() <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<p>5、最后，如果逻辑检查失败，因为已连接数据对象，请使用 <code>bbVol</code> 脚本计算体积。使用 <code>source()</code> 方法获取已连接数据对象的名称。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">compute</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="comment"># 检查是否连接了输入数据</span></span><br><span class="line">    <span class="keyword">if</span> self.<span class="built_in">input</span>.source() <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    data = self.<span class="built_in">input</span>.source()</span><br><span class="line">    min_bounds, max_bounds = data.bounding_box</span><br><span class="line">    x_extent = max_bounds[<span class="number">0</span>] - min_bounds[<span class="number">0</span>]</span><br><span class="line">    y_extent = max_bounds[<span class="number">1</span>] - min_bounds[<span class="number">1</span>]</span><br><span class="line">    z_extent = max_bounds[<span class="number">2</span>] - min_bounds[<span class="number">2</span>]</span><br><span class="line">    volume = x_extent * y_extent * z_extent</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;The volume of %s is %.g.&#x27;</span> % (data.name, volume))</span><br></pre></td></tr></table></figure>
<p>6、完成模块后，在 TCL 中创建一个资源文件，以便在对象弹出菜单中将此模块显示为所有数据对象的选项。</p>
<ul>
<li>有关创建资源文件的更多信息，请参考配置弹出菜单部分。</li>
<li>资源文件可在 <code>$AVIZO_ROOT/share/resources/PythonBoundingBoxVolume.rc</code> 中找到。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">module -name <span class="string">&quot;Bounding Box Volume&quot;</span> \</span><br><span class="line">-primary <span class="string">&quot;HxUniformScalarField3&quot;</span> \</span><br><span class="line">-package <span class="string">&quot;py_core&quot;</span> \</span><br><span class="line">-category <span class="string">&quot;&#123;Measure And Analyze&#125;&quot;</span> \</span><br><span class="line">-proc &#123;</span><br><span class="line">    <span class="built_in">set</span> this [[create HxPythonScriptObject] \</span><br><span class="line">    setLabel <span class="string">&quot;Bounding Box Volume&quot;</span>]</span><br><span class="line">    <span class="string">&quot;$this&quot;</span> startStop hideMaskIncrease</span><br><span class="line">    <span class="string">&quot;$this&quot;</span> filename hideMaskIncrease</span><br><span class="line">    <span class="string">&quot;$this&quot;</span> filename setValue \</span><br><span class="line">    	&lt;PRODUCT_PATH&gt;/share/python_script_objects/PythonBoundingBoxVolume.pyscro</span><br><span class="line">    <span class="string">&quot;$this&quot;</span> startStop hit <span class="number">0</span></span><br><span class="line">    <span class="string">&quot;$this&quot;</span> fire</span><br><span class="line">    <span class="keyword">if</span> &#123; [exists $PRIMARY] &#125; &#123;</span><br><span class="line">        $this data connect $PRIMARY</span><br><span class="line">        $this fire</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="11-6-1-5-2-资源文件"><a href="#11-6-1-5-2-资源文件" class="headerlink" title="11.6.1.5.2 资源文件"></a>11.6.1.5.2 资源文件</h5><p>资源文件是一个在 Avizo 启动过程中读取和执行的 TCL 脚本。你可以配置一个资源文件，使你的 Python 脚本对象出现在下拉菜单中或作为宏按钮。资源文件位于 <code>$AVIZO_ROOT/share/resources</code> 目录中。</p>
<h6 id="结构化下拉菜单资源文件"><a href="#结构化下拉菜单资源文件" class="headerlink" title="结构化下拉菜单资源文件"></a>结构化下拉菜单资源文件</h6><p>脚本以 TCL 命令 <code>&lt;module&gt;</code> 开始，后跟一个简单案例的以下标志。在下例中，<code>$PRIMARY</code> 是指你最初右键单击的对象。</p>
<p><code>-name</code><br>这是菜单中模块的名称。</p>
<p><code>-package</code><br>这定义了对象的包。</p>
<p><code>-primary</code><br>这限制了脚本出现时所需的数据类型。</p>
<p><code>-category</code><br>这定义了脚本在菜单中出现的文件夹。</p>
<p><code>-proc</code><br>这是资源文件的主体部分，指定 .pyscro 文件的加载位置以及如何将脚本连接到你最初右键单击的对象。</p>
<h6 id="结构化宏资源文件"><a href="#结构化宏资源文件" class="headerlink" title="结构化宏资源文件"></a>结构化宏资源文件</h6><p>脚本以 TCL 命令 <code>&lt;macroButton&gt;</code> 开始，后跟一个简单案例的以下标志。</p>
<p><code>-add</code><br>这为按钮创建了一个名称。</p>
<p><code>-color</code><br>这控制按钮的颜色。</p>
<p><code>-proc</code><br>这是资源文件的主体部分，指定 <code>.pyscro</code> 文件的加载位置或过程的运行。</p>
<h4 id="11-6-1-6-Python-环境和包管理器"><a href="#11-6-1-6-Python-环境和包管理器" class="headerlink" title="11.6.1.6 Python 环境和包管理器"></a>11.6.1.6 Python 环境和包管理器</h4><h5 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h5><p>本节解释了如何在 Windows 的命令提示符或 Linux/Mac 的终端中列出、安装或更新 Avizo 的新 Python 包。包管理器允许用户创建多个自包含的 Python 环境，每个环境都有自己的 Python 可执行文件（例如 Windows 上的 python.exe）和一组包。每个自包含环境都可以在 Avizo 中使用。</p>
<h5 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h5><p><code>EDM(Enthought Deployment Manager)</code>包管理器可用于安装、删除或升级在两个存储库中提供的 Python 包：</p>
<p>• official ThermoScientific/3dSoftware<br>• enthought/free</p>
<p>此工具应用于查找可用的 Python 包并安装新包。它允许查看、更新和删除已安装的包。此外，它还允许恢复到以前的状态，并恢复到 Avizo 的原始 Python 环境。</p>
<h5 id="如何安装和配置-EDM"><a href="#如何安装和配置-EDM" class="headerlink" title="如何安装和配置 EDM"></a>如何安装和配置 EDM</h5><p>注意：EDM 安装程序可能需要重新启动你的计算机。</p>
<p>EDM 安装程序可以从 Enthought 网站获取：<a target="_blank" rel="noopener" href="https://www.enthought.com/product/enthought-deployment-manager/">https://www.enthought.com/product/enthought-deployment-manager/</a></p>
<p>安装程序会将 EDM（例如，Windows 上的 edm.bat）提取到默认文件夹中（例如，Windows 上的 C:\Enthought\edm）。</p>
<p>要创建一个名为 hxEnv 的新 Python 环境，在 Windows 的命令提示符（转到 EDM 安装目录）和 Linux/Mac 的终端中执行以下命令行（使用与正确架构对应的 .json 文件）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">edm envs <span class="keyword">import</span> -f $AVIZO_ROOT/python/bundles/3dSoftware_win64.json hxEnv</span><br></pre></td></tr></table></figure>
<p>如果此命令失败（例如，出现以下错误消息：“The packages repository ‘ThermoScientific/3dSoftware’ does not exist or is not available under your subscription. Check your repositories settings”），则配置文件 $HOME/.edm.yaml 可能不完整或缺失。打开 $HOME 文件夹（$HOME 环境变量包含用户主目录的绝对路径）并搜索 .edm.yaml 文件。如果它存在，请删除并重新启动 Avizo，它应会重新创建此文件。如果文件仍然缺失，请联系支持人员。</p>
<p>新创建的 Python 环境存储在 <code>$HOME\.edm\envs\hxEnv</code> 中。</p>
<p>要在 Avizo 中使用名为 hxEnv 的新 Python 环境，你需要将环境变量 <code>HX_FORCE_PYTHON_PATH</code> 设置为 <code>$HOME/.edm/envs/hxEnv</code>。</p>
<p>可以通过以下命令获取可用环境的列表：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">edm environments <span class="built_in">list</span></span><br></pre></td></tr></table></figure>
<h5 id="如何搜索和安装包"><a href="#如何搜索和安装包" class="headerlink" title="如何搜索和安装包"></a>如何搜索和安装包</h5><p>首先，按如下方式搜索所需的包：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">edm search &lt;package_name&gt; -e hxEnv</span><br></pre></td></tr></table></figure>
<p>如果该包可用，按如下方式安装：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">edm install &lt;package_name&gt; -e hxEnv</span><br></pre></td></tr></table></figure>
<h5 id="如何列出当前安装的包"><a href="#如何列出当前安装的包" class="headerlink" title="如何列出当前安装的包"></a>如何列出当前安装的包</h5><p>要列出 Avizo 中当前安装的所有包，请输入：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">edm <span class="built_in">list</span> -e hxEnv</span><br></pre></td></tr></table></figure>
<h5 id="如何重新初始化-Avizo-包"><a href="#如何重新初始化-Avizo-包" class="headerlink" title="如何重新初始化 Avizo 包"></a>如何重新初始化 Avizo 包</h5><p>要将 Python 包重新初始化到其原始状态，请使用 .json 文件创建一个新环境，或取消设置 <code>HX_FORCE_PYTHON_PATH</code> 环境变量。取消设置该变量将使 Avizo 使用其嵌入版本。</p>
<p>如果 Python 分发版因在 Avizo 中安装了不受支持的包而变得无法使用，这可能非常有用。</p>
<p>要显示所有可用选项，请使用以下命令：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">edm <span class="built_in">help</span></span><br></pre></td></tr></table></figure>
<h4 id="11-6-1-7-Python-包列表"><a href="#11-6-1-7-Python-包列表" class="headerlink" title="11.6.1.7 Python 包列表"></a>11.6.1.7 Python 包列表</h4><p>以下是 Thermo Scientific Python 中已经包含的包列表：</p>
<p>alabaster 0.7.10-1<br>appdirs 1.4.3-1<br>babel 2.4.0-2<br>backports.abc 0.5-1<br>backports abc remove 0.4-2<br>certifi 2017.7.27.1-1<br>chardet 3.0.4-1<br>colorama 0.3.7-1<br>configobj 5.0.6-2<br>cycler 0.10.0-1<br>cython 0.25.2-1<br>decorator 4.1.2-1<br>distribute remove 1.0.0-4<br>docutils 0.13.1-1<br>h5py 2.7.0-2<br>idna 2.5-1<br>imagesize 0.7.1-1<br>intel runtime 15.0.6.285-2<br>jdcal 1.2-1<br>jinja2 2.9.6-1<br>lxml 3.7.3-2<br>markupsafe 0.23-2<br>matplotlib 2.0.0-5<br>mkl 2017.0.3-1<br>networkx 1.11-7<br>nose 1.3.7-3<br>numexpr 2.6.2-3<br>numpy 1.13.3-3<br>numpydoc 0.6.0-4<br>opencv 3.2.0-3<br>openpyxl 2.4.1-2<br>packaging 16.8-2<br>pandas 0.20.3-3<br>patsy 0.4.1-4<br>pillow 4.0.0-1<br>pip 10.0.1-1<br>py 1.4.34-1<br>pydicom 0.9.9-1<br>pygments 2.2.0-1<br>pyparsing 2.2.0-1<br>pyqt5 5.8.2-3<br>pytables 3.3.0-5<br>pytest 3.1.2-1<br>python dateutil 2.6.0-1<br>pytz 2017.3-1<br>pywavelets 0.5.2-2<br>requests 2.18.4-1<br>scikit learn 0.19.1-2<br>scikits.image 0.13.0-5<br>scipy 1.0.0-2<br>seaborn 0.8.1-2<br>setuptools 38.2.5-1<br>singledispatch 3.4.0.3-1<br>sip 4.19.2-2<br>six 1.10.0-1<br>snowballstemmer 1.2.1-1<br>sphinx 1.5.5-5<br>sphinx rtd theme 0.2.4-1<br>ssl match hostname 3.5.0.1-1<br>statsmodels 0.8.0-4<br>tornado 4.4.2-3<br>urllib3 1.22-1<br>xlwt 1.2.0-1</p>
<h3 id="11-6-2-Python-教程"><a href="#11-6-2-Python-教程" class="headerlink" title="11.6.2 Python 教程"></a>11.6.2 Python 教程</h3><h4 id="11-6-2-1-Python-教程-在-Avizo-中使用-Python-生态系统中的工具"><a href="#11-6-2-1-Python-教程-在-Avizo-中使用-Python-生态系统中的工具" class="headerlink" title="11.6.2.1 Python 教程 - 在 Avizo 中使用 Python 生态系统中的工具"></a>11.6.2.1 Python 教程 - 在 Avizo 中使用 Python 生态系统中的工具</h4><p>将 Python 集成到 Avizo 中的一个优点是，可以使用 Python 工具扩展 Avizo 的功能。这种扩展允许编写封装 Python 函数的脚本对象，以使它们在 Avizo 的图形用户界面中作为模块可用。这些 Python 工具随后可以通过标准的 Avizo 端口进行控制。</p>
<p>本教程演示如何将 Scipy 中的快速傅里叶变换 (FFT) 作为 Avizo 中使用的 FFT 的替代方案进行集成。您可以按照逐步说明操作，或者查看 <code>$AVIZO_ROOT/share/python_script_objects</code> 目录中的相关文件（ScipyFFT.pyscro 和 ScipyFFT.rc）。</p>
<p>从 <code>$AVIZO_ROOT/share/python_script_objects</code> 目录中复制 <code>PythonScriptObjectTemplate.pyscro</code> 文件到您选择的位置，并将其重命名为 <code>ScipyFFT.pyscro</code>。</p>
<p>1、用文本编辑器打开该文件，并通过更改第一行给新模块命名：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ScipyFFT</span>(<span class="title class_ inherited__">PyScriptObject</span>):</span><br></pre></td></tr></table></figure>
<p>2、在初始化函数中，将使用默认数据输入端口进行模块的数据连接，并定义允许的连接类型：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.data.valid_types = [<span class="string">&#x27;HxUniformScalarField3&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>3、最终的初始化函数定义如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">    self.data.valid_types = [<span class="string">&#x27;HxUniformScalarField3&#x27;</span>]</span><br><span class="line">    <span class="comment"># 创建一个“应用”按钮。</span></span><br><span class="line">    self.do_it = HxPortDoIt(self, <span class="string">&#x27;apply&#x27;</span>, <span class="string">&#x27;Apply&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>4、保持 update 函数不变：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>5、FFT 的计算将在 compute 函数中完成。检查是否点击了<code>Apply</code>按钮以及是否选择了输入数据集后，从 Python 中导入几个包。在本例中，我们需要从 scipy 导入 fftpack、从 numpy 导入一些数学函数，以及 time 包来测量执行时间：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> fftpack</span><br><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"><span class="keyword">import</span> time</span><br></pre></td></tr></table></figure>
<p>6、计算的第一步是创建一个变量来存储 FFT 计算的结果作为 3D 均匀标量场。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = hx_project.create(<span class="string">&#x27;HxUniformScalarField3&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>7、要测量执行时间，首先需要在计算开始时获取时间戳：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start_time = time.time()</span><br></pre></td></tr></table></figure>
<p>8、为输入数据创建一个 Python 变量：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">input</span> = self.data.source()</span><br></pre></td></tr></table></figure>
<p>9、要计算输入数据的 FFT 绝对值，执行以下三条命令：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算离散傅里叶变换</span></span><br><span class="line">F1 = fftpack.fftn(<span class="built_in">input</span>.get_array())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将零频率分量移至频谱中心</span></span><br><span class="line">F2 = fftpack.fftshift(F1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取所有系数的幅值</span></span><br><span class="line">F3 = numpy.<span class="built_in">abs</span>(F2)</span><br></pre></td></tr></table></figure>
<p>10、计算完成后，将结果数组分配给您之前创建的 result 变量：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result.set_array(F3)</span><br></pre></td></tr></table></figure>
<p>11、输出 FFT 的总执行时间：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;--- %s seconds ---&quot;</span> % (time.time() - start_time))</span><br></pre></td></tr></table></figure>
<p>12、整个 compute 函数应如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">compute</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="comment"># 检查是否已触碰模块的应用按钮</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self.do_it.was_hit:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 检查输入数据是否连接到有效对象</span></span><br><span class="line">    <span class="keyword">if</span> self.data.source() <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 导入用于执行 FFT 的 scipy 包</span></span><br><span class="line">    <span class="keyword">from</span> scipy <span class="keyword">import</span> fftpack</span><br><span class="line">    <span class="keyword">import</span> numpy</span><br><span class="line">    <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建输出字段</span></span><br><span class="line">    result = hx_project.create(<span class="string">&#x27;HxUniformScalarField3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    start_time = time.time()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 检索输入数据</span></span><br><span class="line">    <span class="built_in">input</span> = self.data.source()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算离散傅里叶变换</span></span><br><span class="line">    F1 = fftpack.fftn(<span class="built_in">input</span>.get_array())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将零频率分量移至频谱中心</span></span><br><span class="line">    F2 = fftpack.fftshift(F1)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取所有系数的幅值</span></span><br><span class="line">    F3 = numpy.<span class="built_in">abs</span>(F2)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将结果 numpy 数组赋值给输出标量场</span></span><br><span class="line">    result.set_array(F3)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在控制台显示计算时间</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;--- %s seconds ---&quot;</span> % (time.time() - start_time))</span><br></pre></td></tr></table></figure>
<p>13、为了让此模块在 Avizo 的图形用户界面中可用，您还需要编写一个资源文件。用文本编辑器创建一个新文件，并将其保存为 ScipyFFT.rc。资源文件通常以注释行开头：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#############################################################</span></span><br><span class="line"><span class="comment"># .rc for pyscro Scipy FFT</span></span><br><span class="line"><span class="comment">#############################################################</span></span><br></pre></td></tr></table></figure>
<p>14、为模块命名：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module -name <span class="string">&quot;Scipy FFT&quot;</span> \</span><br></pre></td></tr></table></figure>
<p>15、指定希望将其附加到的数据类型：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-primary <span class="string">&quot;HxUniformScalarField3&quot;</span> \</span><br></pre></td></tr></table></figure>
<p>16、将其声明为 Python 脚本对象：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-package <span class="string">&quot;py_core&quot;</span> \</span><br></pre></td></tr></table></figure>
<p>17、下一行定义了它将出现在 Avizo 对象弹出菜单中的位置：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-category <span class="string">&quot;&#123;Python Scripts&#125;&quot;</span> \</span><br></pre></td></tr></table></figure>
<p>18、运行几个 TCL 命令以在 Avizo 的图形用户界面中初始化模块。第一个命令将创建脚本对象并为模块设置标签：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-proc &#123;</span><br><span class="line">	<span class="built_in">set</span> this [[create HxPythonScriptObject] setLabel <span class="string">&quot;Python FFT&quot;</span>]</span><br></pre></td></tr></table></figure>
<p>19、设置文件名以找到该模块的 Python 脚本位置，其中 <code>&lt;PRODUCT_PATH&gt;</code> 是 <code>$AVIZO_ROOT</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;$this&quot;</span> startStop hideMaskIncrease</span><br><span class="line"><span class="string">&quot;$this&quot;</span> filename hideMaskIncrease</span><br><span class="line"><span class="string">&quot;$this&quot;</span> filename setValue \</span><br><span class="line">&lt;PRODUCT_PATH&gt;/share/python_script_objects/ScipyFFT.pyscro</span><br></pre></td></tr></table></figure>
<p>20、脚本将运行以使更改生效：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;$this&quot;</span> startStop hit <span class="number">0</span></span><br><span class="line"><span class="string">&quot;$this&quot;</span> fire</span><br></pre></td></tr></table></figure>
<p>21、将数据集连接到您右键单击以创建模块的默认输入数据端口：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> &#123; [exists $PRIMARY] &#125; &#123;</span><br><span class="line">    $this data connect $PRIMARY</span><br><span class="line">    $this fire</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>22、完整的资源文件应如下所示，其中 <code>&lt;PRODUCT_PATH&gt;</code> 是 <code>$AVIZO_ROOT</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#############################################################</span></span><br><span class="line"><span class="comment"># .rc for pyscro Scipy FFT</span></span><br><span class="line"><span class="comment">#############################################################</span></span><br><span class="line">module -name <span class="string">&quot;Scipy FFT&quot;</span> \</span><br><span class="line">-primary <span class="string">&quot;HxUniformScalarField3&quot;</span> \</span><br><span class="line">-package <span class="string">&quot;py_core&quot;</span> \</span><br><span class="line">-category <span class="string">&quot;&#123;Python Scripts&#125;&quot;</span> \</span><br><span class="line">-proc &#123;</span><br><span class="line">    <span class="built_in">set</span> this [[create HxPythonScriptObject] setLabel <span class="string">&quot;Python FFT&quot;</span>]</span><br><span class="line">    <span class="string">&quot;$this&quot;</span> startStop hideMaskIncrease</span><br><span class="line">    <span class="string">&quot;$this&quot;</span> filename hideMaskIncrease</span><br><span class="line">    <span class="string">&quot;$this&quot;</span> filename setValue \</span><br><span class="line">    &lt;PRODUCT_PATH&gt;/share/python_script_objects/ScipyFFT.pyscro</span><br><span class="line">    <span class="string">&quot;$this&quot;</span> startStop hit <span class="number">0</span></span><br><span class="line">    <span class="string">&quot;$this&quot;</span> fire</span><br><span class="line">    <span class="keyword">if</span> &#123; [exists $PRIMARY] &#125; &#123;</span><br><span class="line">        $this data connect $PRIMARY</span><br><span class="line">        $this fire</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>23、要使此 Python 脚本对象在 Avizo 中可用，需要将这两个文件（覆盖现有文件）复制到 <code>$AVIZO_ROOT/share/python_script_objects/</code>，并在修改资源文件后重新启动 Avizo。 如果要重复使用内嵌的 Python FFT 示例，请编辑 <code>$AVIZO_ROOT/share/python_script_objects/ScipyFFT.rc</code> 文件，并将 -category 值从 “None” 改为 “{Python Scripts}”。</p>
<p>24、要测试此模块，请执行以下操作：</p>
<p>（1）启动 Avizo。</p>
<p>（2）加载 <code>$AVIZO_ROOT/data/tutorials/chocolate-bar.am</code>。</p>
<p>（3）右键单击数据对象，并从对象弹出菜单中选择 <code>Python Scripts/Scipy</code> FFT。</p>
<p>（4）单击<code>Apply</code>，并且具有结果 FFT 的新数据对象将在项目视图中显示。</p>
<p>11.7 使用 MATLAB 与 Avizo</p>
<p>本节描述了如何在 Avizo 中使用 MATLAB 脚本。</p>
<h3 id="11-7-1-使用-MATLAB-脚本"><a href="#11-7-1-使用-MATLAB-脚本" class="headerlink" title="11.7.1 使用 MATLAB 脚本"></a>11.7.1 使用 MATLAB 脚本</h3><p>在本教程中，您将学习如何通过 Calculus MATLAB 模块在 Avizo 中使用 MATLAB（The MathWorks, Inc.）进行复杂计算。</p>
<p>为了使用 Calculus MATLAB 模块，必须在您的计算机上正确安装 MATLAB。此外，为了允许此模块与 MATLAB 计算引擎建立连接，您可能需要注册 MATLAB 引擎（在 Windows 上），并根据您的系统设置环境变量以包括 MATLAB 库或程序的搜索路径。请参阅 Calculus MATLAB 模块的文档以了解安装详情和限制。</p>
<p>本教程在在线文档中提供，通过各种示例涵盖以下主题：</p>
<ul>
<li>加载和执行 MATLAB 脚本。</li>
<li>将各种数据类型从 Avizo 传递给 MATLAB 并导出它们。</li>
<li>使用字段结构。</li>
<li>使用时间滑块控制脚本变量。</li>
<li>从脚本调用用户自定义的 MATLAB 函数。</li>
</ul>
<h1 id="Thermo-Fisher-Python-API-documentation"><a href="#Thermo-Fisher-Python-API-documentation" class="headerlink" title="Thermo Fisher Python API documentation"></a>Thermo Fisher Python API documentation</h1><h2 id="Object-handling-classes"><a href="#Object-handling-classes" class="headerlink" title="Object handling classes"></a>Object handling classes</h2><h3 id="hx-core-HxObjectFactory"><a href="#hx-core-HxObjectFactory" class="headerlink" title="hx.core.HxObjectFactory"></a>hx.core.HxObjectFactory</h3><p>这是一个类，用于在Python中实例化所有模块并加载所有数据。该类的所有实例是可互换的，已经实例化的一个实例被命名为 <code>hx_object_factory</code>。</p>
<h4 id="create-classname"><a href="#create-classname" class="headerlink" title="create(classname)"></a>create(classname)</h4><p>此函数用于创建一个模块。</p>
<h5 id="参数"><a href="#参数" class="headerlink" title="参数:"></a>参数:</h5><ul>
<li><code>classname</code> : str<br>字符串，表示要实例化的类名。</li>
</ul>
<h5 id="返回"><a href="#返回" class="headerlink" title="返回:"></a>返回:</h5><ul>
<li><code>HxBase</code><br>返回最接近派生自 <code>HxBase</code> 的实例。</li>
</ul>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_var = hx_object_factory.create(<span class="string">&#x27;HxOrthoSlice&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="get-obj-name"><a href="#get-obj-name" class="headerlink" title="get(obj_name)"></a>get(obj_name)</h4><p>此函数尝试通过名称找到一个模块或数据。</p>
<h5 id="参数-1"><a href="#参数-1" class="headerlink" title="参数:"></a>参数:</h5><ul>
<li><code>obj_name</code> : str<br>表示要查找的模块或数据的名称属性（它对应于 <code>HxBase.name</code> 属性）。</li>
</ul>
<h5 id="返回-1"><a href="#返回-1" class="headerlink" title="返回:"></a>返回:</h5><ul>
<li><code>HxBase</code><br>返回与名称匹配的 <code>HxBase</code> 派生实例。</li>
</ul>
<h5 id="Raises"><a href="#Raises" class="headerlink" title="Raises:"></a>Raises:</h5><ul>
<li><code>KeyError</code><br>如果找不到名为 <code>obj_name</code> 的模块，则引发此异常。</li>
</ul>
<h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例:"></a>示例:</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_var = hx_object_factory.get(<span class="string">&#x27;Ortho Slice&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="load-filename"><a href="#load-filename" class="headerlink" title="load(filename)"></a>load(filename)</h4><p>此函数用于加载数据。</p>
<h5 id="参数-2"><a href="#参数-2" class="headerlink" title="参数:"></a>参数:</h5><ul>
<li><code>filename</code> : str<br>表示要加载的文件。</li>
</ul>
<h5 id="返回-2"><a href="#返回-2" class="headerlink" title="返回:"></a>返回:</h5><ul>
<li><code>HxBase 或 list[HxBase]</code><br>如果文件名对应的模块为一个，返回 <code>HxData</code> 的派生实例；如果文件名对应多个模块，返回一个 <code>HxBase</code> 的列表。</li>
</ul>
<h5 id="Raises-1"><a href="#Raises-1" class="headerlink" title="Raises:"></a>Raises:</h5><ul>
<li><code>KeyError</code></li>
<li><code>RuntimeError</code></li>
</ul>
<h5 id="示例-2"><a href="#示例-2" class="headerlink" title="示例:"></a>示例:</h5><p>此示例说明如何加载文件。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_var = hx_object_factory.load(hx_paths.tutorials_dir + <span class="string">&#x27;/chocolate-bar.am&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="hx-core-HxProject"><a href="#hx-core-HxProject" class="headerlink" title="hx.core.HxProject"></a>hx.core.HxProject</h3><p>这是一个类，用于通过添加或删除对象与项目视图（也称为对象池）进行交互。该类的所有实例是可互换的，实例之一被称为 <code>hx_project</code>。</p>
<h4 id="add-obj"><a href="#add-obj" class="headerlink" title="add(obj)"></a>add(obj)</h4><p>将 <code>obj</code> 添加到项目视图中。</p>
<h5 id="参数-3"><a href="#参数-3" class="headerlink" title="参数:"></a>参数:</h5><ul>
<li><code>obj</code> : HxObject<br>必须添加到项目视图的对象。</li>
</ul>
<h5 id="示例-3"><a href="#示例-3" class="headerlink" title="示例:"></a>示例:</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ortho = hx_object_factory.create(<span class="string">&#x27;HxOrthoSlice&#x27;</span>)  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hx_project.add(ortho)<span class="string">&#x27;</span></span><br></pre></td></tr></table></figure>
<h4 id="create-classname-1"><a href="#create-classname-1" class="headerlink" title="create(classname)"></a>create(classname)</h4><p>创建一个 <code>classname</code> 类型的对象并将其添加到项目视图中。</p>
<h5 id="参数-4"><a href="#参数-4" class="headerlink" title="参数:"></a>参数:</h5><ul>
<li><code>classname</code> : str<br>表示要实例化的类的字符串。</li>
</ul>
<h5 id="返回-3"><a href="#返回-3" class="headerlink" title="返回:"></a>返回:</h5><ul>
<li><code>HxBase</code><br>返回最接近派生自 <code>HxBase</code> 的实例。</li>
</ul>
<h5 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h5><p>The following code:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>some_obj = hx_project.create(<span class="string">&#x27;HxOrthoSlice&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>is equivalent to:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>some_obj = hx_object_factory.create(<span class="string">&#x27;HxOrthoSlice&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hx_project.add(some_obj)</span><br></pre></td></tr></table></figure>
<h5 id="示例-4"><a href="#示例-4" class="headerlink" title="示例:"></a>示例:</h5><p>创建正交切片并将其添加到项目视图：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>some_obj = hx_project.create(<span class="string">&#x27;HxOrthoSlice&#x27;</span>)<span class="string">&#x27;</span></span><br></pre></td></tr></table></figure>
<h4 id="get-obj-name-1"><a href="#get-obj-name-1" class="headerlink" title="get(obj_name)"></a>get(obj_name)</h4><p>根据名称从项目视图中检索对象。</p>
<h5 id="参数-5"><a href="#参数-5" class="headerlink" title="参数:"></a>参数:</h5><ul>
<li><code>obj_name</code> : str<br>要检索的对象名称。</li>
</ul>
<h5 id="Raises-2"><a href="#Raises-2" class="headerlink" title="Raises:"></a>Raises:</h5><ul>
<li><code>KeyError</code><br>如果在项目视图中找不到名为 <code>obj_name</code> 的对象，则引发此异常。</li>
</ul>
<h5 id="示例-5"><a href="#示例-5" class="headerlink" title="示例:"></a>示例:</h5><p>我们创建一个 Ortho Slice，给它命名，将它添加到项目视图并通过其名称进行查询：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ortho = hx_object_factory.create(<span class="string">&#x27;HxOrthoSlice&#x27;</span>)  </span><br><span class="line">ortho.name = <span class="string">&quot;MyNewName&quot;</span>  </span><br><span class="line">hx_project.add(ortho)  </span><br><span class="line">ortho2 = hx_project.get(<span class="string">&quot;MyNewName&quot;</span>)<span class="string">&#x27;</span></span><br></pre></td></tr></table></figure>
<p>请注意，在这种情况下，ortho 和 ortho2 代表应用程序中的同一个对象：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(ortho.is_same_object(ortho2))</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h4 id="load-filename-1"><a href="#load-filename-1" class="headerlink" title="load(filename)"></a>load(filename)</h4><p>加载指定文件并将其添加到项目视图中。</p>
<h5 id="参数-6"><a href="#参数-6" class="headerlink" title="参数:"></a>参数:</h5><ul>
<li><code>filename</code> : str<br>表示要加载的文件。</li>
</ul>
<h5 id="返回-4"><a href="#返回-4" class="headerlink" title="返回:"></a>返回:</h5><ul>
<li><code>HxBase</code><br>返回最接近派生自 <code>HxData</code> 的实例。</li>
</ul>
<h5 id="Notes-1"><a href="#Notes-1" class="headerlink" title="Notes"></a>Notes</h5><p>The following code:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>some_obj = hx_project.load(hx_paths.tutorials_dir + <span class="string">&#x27;/chocolate-bar.am&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>is equivalent to:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>some_obj = hx_object_factory.load(hx_paths.tutorials_dir + <span class="string">&#x27;/chocolate-bar.am&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hx_project.add(some_obj)</span><br></pre></td></tr></table></figure>
<h5 id="示例-6"><a href="#示例-6" class="headerlink" title="示例:"></a>示例:</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>some_obj = hx_project.load(hx_paths.tutorials_dir + <span class="string">&#x27;/chocolate-bar.am&#x27;</span>)<span class="string">&#x27;</span></span><br></pre></td></tr></table></figure>
<h4 id="remove-obj"><a href="#remove-obj" class="headerlink" title="remove(obj)"></a>remove(obj)</h4><p>从项目视图中移除 <code>obj</code>。</p>
<h5 id="参数-7"><a href="#参数-7" class="headerlink" title="参数:"></a>参数:</h5><ul>
<li><code>obj</code> : HxObject<br>要从项目视图中删除的对象。</li>
</ul>
<h5 id="Raises-3"><a href="#Raises-3" class="headerlink" title="Raises:"></a>Raises:</h5><ul>
<li><code>KeyError</code><br>如果 <code>obj</code> 不在项目视图中，则引发此异常。</li>
</ul>
<h5 id="示例-7"><a href="#示例-7" class="headerlink" title="示例:"></a>示例:</h5><p>我们使用object_factory创建一个正交切片，将其添加到项目视图，然后将其从项目视图中删除：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ortho = hx_object_factory.create(<span class="string">&#x27;HxOrthoSlice&#x27;</span>)  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hx_project.add(ortho)  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hx_project.remove(ortho)<span class="string">&#x27;</span></span><br></pre></td></tr></table></figure>
<h4 id="remove-all"><a href="#remove-all" class="headerlink" title="remove_all()"></a>remove_all()</h4><p>从项目视图中移除所有对象（仅移除可移除的对象）。</p>
<h5 id="示例-8"><a href="#示例-8" class="headerlink" title="示例:"></a>示例:</h5><p>从项目视图中删除所有对象。（只有可移动的对象才会被删除。）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>hx_project.remove_all()<span class="string">&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="Path-management"><a href="#Path-management" class="headerlink" title="Path management"></a>Path management</h2><h3 id="hx-core-HxPaths"><a href="#hx-core-HxPaths" class="headerlink" title="hx.core.HxPaths"></a>hx.core.HxPaths</h3><p>这是一个类，用于检索与产品路径相关的信息。该类的一个实例称为 <code>hx_paths</code>。</p>
<h4 id="appdata-dir"><a href="#appdata-dir" class="headerlink" title="appdata_dir"></a>appdata_dir</h4><p>与产品的 <code>appdata</code> 目录绑定的只读属性。</p>
<h4 id="executable-dir"><a href="#executable-dir" class="headerlink" title="executable_dir"></a>executable_dir</h4><p>与产品的可执行目录绑定的只读属性。</p>
<h4 id="home-dir"><a href="#home-dir" class="headerlink" title="home_dir"></a>home_dir</h4><p>与产品的主目录绑定的只读属性。</p>
<h4 id="install-data-dir"><a href="#install-data-dir" class="headerlink" title="install_data_dir"></a>install_data_dir</h4><p>与产品的数据目录绑定的只读属性。</p>
<h4 id="install-dir"><a href="#install-dir" class="headerlink" title="install_dir"></a>install_dir</h4><p>与产品的安装目录绑定的只读属性。</p>
<h4 id="python-modules-dir"><a href="#python-modules-dir" class="headerlink" title="python_modules_dir"></a>python_modules_dir</h4><p>与产品的 Python 模块目录绑定的只读属性。</p>
<h4 id="python-script-objects-dir"><a href="#python-script-objects-dir" class="headerlink" title="python_script_objects_dir"></a>python_script_objects_dir</h4><p>与产品的 Python 脚本对象目录绑定的只读属性。</p>
<h4 id="python-share-dir"><a href="#python-share-dir" class="headerlink" title="python_share_dir"></a>python_share_dir</h4><p>与产品的 <code>share</code> 目录绑定的只读属性。</p>
<h4 id="tutorials-dir"><a href="#tutorials-dir" class="headerlink" title="tutorials_dir"></a>tutorials_dir</h4><p>与产品的教程目录绑定的只读属性。</p>
<h2 id="Messaging-utilities"><a href="#Messaging-utilities" class="headerlink" title="Messaging utilities"></a>Messaging utilities</h2><h3 id="hx-core-HxMessage"><a href="#hx-core-HxMessage" class="headerlink" title="hx.core.HxMessage"></a>hx.core.HxMessage</h3><p>此界面用于弹出模式对话框。（例如错误、警告、信息、文件覆盖、问题）。</p>
<p>这些简单对话框（消息框）已实现“不再显示此消息”功能。使用此功能，用户可以禁用显示某些消息。此外，用户还可以通过“首选项”面板恢复已禁用的消息框。在消息框中使用此功能时，将创建消息框的唯一密钥，并将该密钥与用户单击的按钮索引一起保存到设置中。默认情况下，所有消息框均禁用此功能，如果我们想启用此功能，则必须传递其他参数。</p>
<p>该类的一个实例称为 <code>hx_message</code>。</p>
<h4 id="confirmations-message-button0-text-button1-text"><a href="#confirmations-message-button0-text-button1-text" class="headerlink" title="confirmations(message, button0_text, button1_text)"></a>confirmations(message, button0_text, button1_text)</h4><p>确认对话框，使用方法与 <code>question()</code> 相同。</p>
<h5 id="参数-8"><a href="#参数-8" class="headerlink" title="参数:"></a>参数:</h5><ul>
<li><code>message</code> : str<br>要在消息框中显示的消息。</li>
<li><code>button0_text</code> : str<br>按钮0的标签。</li>
<li><code>button1_text</code> : str<br>按钮1的标签。</li>
<li><code>do_not_show_again_key</code> : str, optional<br>如果此参数不为空，将添加“不要再显示此消息”的复选框，用户勾选后可防止再次显示该消息。该字符串值将作为识别消息的键。</li>
</ul>
<h5 id="返回-5"><a href="#返回-5" class="headerlink" title="返回:"></a>返回:</h5><ul>
<li><code>int</code><br>返回值指示用户按下了哪个按钮。</li>
</ul>
<h5 id="示例-9"><a href="#示例-9" class="headerlink" title="示例:"></a>示例:</h5><p>显示一个简单的确认消息框：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;ret = hx_message.confirmations(&quot;Computation may be very long. Do you want to continue ?&quot;, &quot;Yes&quot;, &quot;No&quot;)  </span></span><br><span class="line"><span class="string">&gt;&gt;&gt; if ret == 0:  </span></span><br><span class="line"><span class="string">&gt;&gt;&gt;     print(&quot;Execute your computation code.&quot;)&#x27;</span></span><br></pre></td></tr></table></figure>
<h4 id="error-message-button0-text-””-button1-text-””-button2-text-””-default-button-index-1-escape-button-index-1"><a href="#error-message-button0-text-””-button1-text-””-button2-text-””-default-button-index-1-escape-button-index-1" class="headerlink" title="error(message, button0_text=””, button1_text=””, button2_text=””, default_button_index=-1, escape_button_index=-1)"></a>error(message, button0_text=””, button1_text=””, button2_text=””, default_button_index=-1, escape_button_index=-1)</h4><p>弹出一个模态对话框，显示用户定义的错误消息。</p>
<h5 id="参数-9"><a href="#参数-9" class="headerlink" title="参数:"></a>参数:</h5><ul>
<li><code>message</code> : str<br>要在消息框中显示的消息。</li>
<li><code>button0_text</code> : str, optional<br>按钮0的标签。如果为空，则显示“关闭”。</li>
<li><code>button1_text</code> : str, optional<br>按钮1的标签。</li>
<li><code>button2_text</code> : str, optional<br>按钮2的标签。</li>
<li><code>default_button_index</code> : int, optional<br>默认按钮的索引（0-2）。</li>
<li><code>escape_button_index</code> : int, optional<br>逃生按钮的索引。</li>
</ul>
<h5 id="返回-6"><a href="#返回-6" class="headerlink" title="返回:"></a>返回:</h5><ul>
<li><code>int</code><br>返回值指示用户按下了哪个按钮。</li>
</ul>
<h5 id="示例-10"><a href="#示例-10" class="headerlink" title="示例:"></a>示例:</h5><p>显示一个简单的消息框错误：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>hx_message.error(<span class="string">&quot;Could not locate specified file.&quot;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="info-message-do-not-show-again-key-””"><a href="#info-message-do-not-show-again-key-””" class="headerlink" title="info(message, do_not_show_again_key=””)"></a>info(message, do_not_show_again_key=””)</h4><p>与错误、警告和问题对话框不同，信息对话框始终只有一个按钮，标有“关闭”。</p>
<h5 id="参数-10"><a href="#参数-10" class="headerlink" title="参数:"></a>参数:</h5><ul>
<li><code>message</code> : str<br>要在消息框中显示的消息。</li>
<li><code>do_not_show_again_key</code> : str, optional<br>如果此参数不为空，将添加“不要再显示此消息”的复选框。</li>
</ul>
<h5 id="返回-7"><a href="#返回-7" class="headerlink" title="返回:"></a>返回:</h5><ul>
<li><code>int</code><br>返回0。</li>
</ul>
<h5 id="示例-11"><a href="#示例-11" class="headerlink" title="示例:"></a>示例:</h5><p>显示一个简单的信息消息框：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>hx_message.info(<span class="string">&quot;Computation was a success!&quot;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="overwrite-filename"><a href="#overwrite-filename" class="headerlink" title="overwrite(filename)"></a>overwrite(filename)</h4><p>将会弹出一个模式对话框，提示指定的文件已经存在。用户可以选择覆盖或取消。如果选择覆盖，该方法将返回 True。否则，该方法将返回 False。不会检查指定的文件是否确实已经存在。</p>
<h5 id="参数-11"><a href="#参数-11" class="headerlink" title="参数:"></a>参数:</h5><ul>
<li><code>filename</code> : str<br>已存在的文件名。</li>
</ul>
<h5 id="返回-8"><a href="#返回-8" class="headerlink" title="返回:"></a>返回:</h5><ul>
<li><code>bool</code><br>如果用户选择覆盖返回 <code>True</code>，否则返回 <code>False</code>。</li>
</ul>
<h4 id="question-message-button0-text-button1-text-button2-text-””-default-button-index-1-escape-button-index-1-do-not-show-again-key-””"><a href="#question-message-button0-text-button1-text-button2-text-””-default-button-index-1-escape-button-index-1-do-not-show-again-key-””" class="headerlink" title="question(message, button0_text, button1_text, button2_text=””, default_button_index=-1, escape_button_index=-1, do_not_show_again_key=””)"></a>question(message, button0_text, button1_text, button2_text=””, default_button_index=-1, escape_button_index=-1, do_not_show_again_key=””)</h4><p>问题对话框，使用方法与 <code>error()</code> 相同。</p>
<h5 id="参数-12"><a href="#参数-12" class="headerlink" title="参数:"></a>参数:</h5><ul>
<li><code>message</code> : str<br>要在消息框中显示的问题。</li>
<li><code>button0_text</code> : str<br>按钮0的标签。</li>
<li><code>button1_text</code> : str<br>按钮1的标签。</li>
<li><code>button2_text</code> : str, optional<br>按钮2的标签。</li>
<li><code>default_button_index</code> : int, optional<br>默认按钮的索引（0-2）。</li>
<li><code>escape_button_index</code> : int, optional<br>逃生按钮的索引。</li>
<li><code>do_not_show_again_key</code> : str, optional<br>如果此参数不为空，将添加“不要再显示此消息”的复选框。</li>
</ul>
<h5 id="返回-9"><a href="#返回-9" class="headerlink" title="返回:"></a>返回:</h5><ul>
<li><code>int</code><br>返回值指示用户按下了哪个按钮。</li>
</ul>
<h5 id="示例-12"><a href="#示例-12" class="headerlink" title="示例:"></a>示例:</h5><p>显示一个简单的消息框问题：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ret = hx_message.question(<span class="string">&quot;Specified file seems corrupted. Do you want to load the data anyway ?&quot;</span>, <span class="string">&quot;Yes&quot;</span>, <span class="string">&quot;No&quot;</span>)  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> ret == <span class="number">0</span>:  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>    <span class="built_in">print</span>(<span class="string">&quot;Abort image loading...&quot;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="warning-message-button0-text-””-button1-text-””-button2-text-””-default-button-index-1-escape-button-index-1-do-not-show-again-key-””"><a href="#warning-message-button0-text-””-button1-text-””-button2-text-””-default-button-index-1-escape-button-index-1-do-not-show-again-key-””" class="headerlink" title="warning(message, button0_text=””, button1_text=””, button2_text=””, default_button_index=-1, escape_button_index=-1, do_not_show_again_key=””)"></a>warning(message, button0_text=””, button1_text=””, button2_text=””, default_button_index=-1, escape_button_index=-1, do_not_show_again_key=””)</h4><p>警告对话框，使用方法与 <code>error()</code> 相同。</p>
<h5 id="参数-13"><a href="#参数-13" class="headerlink" title="参数:"></a>参数:</h5><ul>
<li><code>message</code> : str<br>要在消息框中显示的警告消息。</li>
<li><code>button0_text</code> : str, optional<br>按钮0的标签。</li>
<li><code>button1_text</code> : str, optional<br>按钮1的标签。</li>
<li><code>button2_text</code> : str, optional<br>按钮2的标签。</li>
<li><code>default_button_index</code> : int, optional<br>默认按钮的索引（0-2）。</li>
<li><code>escape_button_index</code> : int, optional<br>逃生按钮的索引。</li>
<li><code>do_not_show_again_key</code> : str, optional<br>如果此参数不为空，将添加“不要再显示此消息”的复选框。</li>
</ul>
<h5 id="返回-10"><a href="#返回-10" class="headerlink" title="返回:"></a>返回:</h5><ul>
<li><code>int</code><br>返回值指示用户按下了哪个按钮。</li>
</ul>
<h5 id="示例-13"><a href="#示例-13" class="headerlink" title="示例:"></a>示例:</h5><p>显示一个简单的消息框警告：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>hx_message.warning(<span class="string">&quot;Imported file does not have the expected size.&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="Hierarchy-of-objects"><a href="#Hierarchy-of-objects" class="headerlink" title="Hierarchy of objects"></a>Hierarchy of objects</h2><h3 id="hx-core-McInterface"><a href="#hx-core-McInterface" class="headerlink" title="hx.core.McInterface"></a>hx.core.McInterface</h3><p>McInterface 是所有接口的基类，包括 HxBase 层次结构。此类是抽象基类。</p>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><h5 id="all-interfaces"><a href="#all-interfaces" class="headerlink" title="all_interfaces"></a>all_interfaces</h5><p>包含所有允许的接口作为子成员的属性。</p>
<h5 id="示例-14"><a href="#示例-14" class="headerlink" title="示例"></a>示例</h5><p>检索正交切片 (HxOrthoSlice) 的 HxBase 接口：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ortho = hx_project.create(<span class="string">&#x27;HxOrthoSlice&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>base = ortho.all_interfaces.HxBase</span><br></pre></td></tr></table></figure></p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><h5 id="get-all-interface-names"><a href="#get-all-interface-names" class="headerlink" title="get_all_interface_names()"></a>get_all_interface_names()</h5><p>返回支持的所有接口名称的列表。</p>
<h5 id="返回-11"><a href="#返回-11" class="headerlink" title="返回:"></a>返回:</h5><ul>
<li>list of strings<br>返回对象支持的所有接口名称的列表。</li>
</ul>
<h5 id="示例-15"><a href="#示例-15" class="headerlink" title="示例"></a>示例</h5><p>打印正交切片支持的所有接口：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ortho = hx_project.create(<span class="string">&#x27;HxOrthoSlice&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(ortho.get_all_interface_names())</span><br><span class="line">[<span class="string">&#x27;HxPlanarModBase&#x27;</span>, <span class="string">&#x27;HxModule&#x27;</span>, <span class="string">&#x27;HxObject&#x27;</span>, <span class="string">&#x27;HxBase&#x27;</span>]</span><br></pre></td></tr></table></figure></p>
<h3 id="hx-core-HxBase"><a href="#hx-core-HxBase" class="headerlink" title="hx.core.HxBase"></a>hx.core.HxBase</h3><p>文档太长，暂不翻译</p>
<h1 id="python-avizo代码测试"><a href="#python-avizo代码测试" class="headerlink" title="python+avizo代码测试"></a>python+avizo代码测试</h1><h2 id="代码创建方法"><a href="#代码创建方法" class="headerlink" title="代码创建方法"></a>代码创建方法</h2><p>在python控制台中调用 <code>Segmentation Editor</code> 很难实现，对于pyhon接口，只可以在project中实现的算法，可以采用API去调用。</p>
<p>对于某个具体的方法，可以鼠标放在方法栏上，然后悬停后显示方法名。</p>
<img src="/2024/09/19/AVIZO%E8%87%AA%E5%8A%A8%E5%8C%96/%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2-1.png" class="" title="阈值分割-1">
<p>例如<code>Image Curvature</code>方法，在API中对应的接口就是<code>curvature2d/curvature3d</code></p>
<p>对于<code>curvature</code>方法不熟悉，可以在控制台直接输出。</p>
<ul>
<li>curvature3d</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hx_object_factory.create(<span class="string">&#x27;curvature3d&#x27;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Python handle of type: &#x27;HxCompModule&#x27;</span><br><span class="line">Kernel item name     : &#x27;Image Curvature 3D&#x27;</span><br><span class="line">Kernel item type     : &#x27;HxQuant2GenericModule&#x27;</span><br><span class="line">All ports            :</span><br><span class="line">    &#x27;interpretation&#x27;: &#x27;HxPortRadioBox&#x27;</span><br><span class="line">    &#x27;outputLocation&#x27;: &#x27;HxPortMultiMenu&#x27;</span><br><span class="line">    &#x27;doIt&#x27;: &#x27;HxPortDoIt&#x27;</span><br><span class="line">    &#x27;inputImage&#x27;: &#x27;HxConnection&#x27;</span><br><span class="line">    &#x27;inputImageMask&#x27;: &#x27;HxConnection&#x27;</span><br><span class="line">    &#x27;standardDeviation&#x27;: &#x27;HxPortFloatTextN&#x27;</span><br></pre></td></tr></table></figure>
<ul>
<li>curvature2d</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hx_object_factory.create(<span class="string">&#x27;curvature2d&#x27;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Python handle of type: &#x27;HxCompModule&#x27;</span><br><span class="line">Kernel item name     : &#x27;Image Curvature 2&#x27;</span><br><span class="line">Kernel item type     : &#x27;HxQuant2GenericModule&#x27;</span><br><span class="line">All ports            :</span><br><span class="line">    &#x27;interpretation&#x27;: &#x27;HxPortRadioBox&#x27;</span><br><span class="line">    &#x27;outputLocation&#x27;: &#x27;HxPortMultiMenu&#x27;</span><br><span class="line">    &#x27;doIt&#x27;: &#x27;HxPortDoIt&#x27;</span><br><span class="line">    &#x27;inputImage&#x27;: &#x27;HxConnection&#x27;</span><br><span class="line">    &#x27;inputImageMask&#x27;: &#x27;HxConnection&#x27;</span><br><span class="line">    &#x27;standardDeviation&#x27;: &#x27;HxPortFloatTextN&#x27;</span><br></pre></td></tr></table></figure>
<ul>
<li>图形化界面可以看到，使用以下创建方式</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hx_project.create(<span class="string">&#x27;curvature3d&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="helloworld"><a href="#helloworld" class="headerlink" title="helloworld"></a>helloworld</h2><p>在Avizo的Main Python Console调用并执行脚本</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span>(<span class="built_in">open</span>(<span class="string">&#x27;F://PYCharmWorkSpace//DigitalCoreFeatureExtraction//avizo//avizo_helloworld.py&#x27;</span>).read())</span><br></pre></td></tr></table></figure>
<h2 id="读取文件并进行切片显示"><a href="#读取文件并进行切片显示" class="headerlink" title="读取文件并进行切片显示"></a>读取文件并进行切片显示</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dataLoaded = hx_project.load(<span class="string">&#x27;E:/digitalrock/eleven_sandstones_dataset/1_Berea/Berea_2d25um_binary_1-0_test.tif&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ortho_slice = hx_project.create(<span class="string">&#x27;HxOrthoSlice&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ortho_slice.ports.data.connect(dataLoaded)</span><br><span class="line"></span><br><span class="line">ortho_slice.fire()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span>(<span class="built_in">open</span>(<span class="string">&#x27;F://PYCharmWorkSpace//DigitalCoreFeatureExtraction//avizo//avizo_read_test.py&#x27;</span>).read())</span><br></pre></td></tr></table></figure>
<h2 id="阈值分割"><a href="#阈值分割" class="headerlink" title="阈值分割"></a>阈值分割</h2><h3 id="avizo中Image-Segmentation方法"><a href="#avizo中Image-Segmentation方法" class="headerlink" title="avizo中Image Segmentation方法"></a>avizo中Image Segmentation方法</h3><img src="/2024/09/19/AVIZO%E8%87%AA%E5%8A%A8%E5%8C%96/ImageSegmentation-1.png" class="" title="ImageSegmentation-1">
<ul>
<li>2D-Histogram Segmentation</li>
</ul>
<p>使用2D直方图分割脚本模块，您可以以半自动的方式对由两个或多个阶段组成的CT或MR灰度图像数据进行分割。</p>
<p>考虑多相材料，如教程数据 chocolate-bar.am，即气缸盖样品的 CT 扫描。有许多离散相，但直方图显示不同相的峰值重叠。在这种情况下，基于强度对图像进行阈值处理将失败，因为任何阈值都会导致某些像素被错误分配。<br>这里使用的方法称为 2D 直方图分割，依赖于梯度幅度与图像强度直方图。<br>此分割过程包括两个主要步骤：将一些体素初步分类为两个或多个相，然后是扩展步骤，在该步骤中扩展该分类，以便所有体素都被标记。<br>分类：对于此例程，体素的初始分类是基于这些体素的强度及其梯度幅度执行的。此例程的输入是 3D 体积的强度图。从该输入计算梯度幅度。计算梯度幅度后，将向用户显示显示梯度幅度与图像强度的 2D 散点图。用户将使用此图来确定初始分类（这在使用直方图初始化分类中进行了描述）。<br>扩展：扩展由标记种子分水岭变换计算（参见分水岭算法原理）。分水岭变换需要两个输入，一组种子标记和一个景观函数。种子标记将由分类确定（参见解释直方图），梯度幅度将用于景观函数。<br>2D 直方图分割的 6 个步骤：<br>步骤 1 - 计算梯度幅度以开始 - 请参阅计算梯度幅度中的详细信息：<br>选择精确计算梯度幅度或更快近似梯度幅度。<br>点击下一步：计算梯度幅度以继续。<br>步骤 2 - 绘制直方图，请参阅解释直方图中的详细信息：<br>点击下一步：绘制直方图以继续。<br>步骤 3 - 绘制窗口 - 请参阅使用直方图初始化分类中的详细信息：<br>如果您使用鼠标拖动绘图窗口，并且希望将其重置为原始大小和位置，则只需拖动属性面板上的伽马校正滑块即可。<br>使用伽马校正在 2D 直方图上可视化峰值。使用绘图窗口顶部的绘图工具直接在绘图上绘制窗口。通常，您需要选择梯度幅度非常低的区域（峰值靠近 x 轴）。<br>点击下一步：计算种子以继续下一步。<br>步骤 4 - 查看种子标签：<br>使用权重因子更新视图以显示灰度数据、种子标签图像或两个数据集的加权融合。<br>使用隐藏/显示直方图按钮切换直方图的显示，以便更轻松地在查看器中查看结果。使用切片编号调整正在显示的切片索引平面。如果您对从所选窗口计算出的种子不满意，请点击“删除最后一个窗口”以逐个删除窗口（按添加时的相反顺序）。然后您可以绘制新窗口。绘制新窗口后，请点击“重新计算种子”。您可以反复进行，直到对种子满意为止。<br>点击“下一步：应用分水岭”继续（请参阅“使用分水岭扩展”中的详细信息）<br>步骤 5 - 确认分水岭结果：<br>如果结果不令人满意，请绘制新区域，然后点击“上一步：重新计算种子”重新应用分水岭。<br>点击“下一步”继续执行最后一步，这是可选的。<br>步骤 6 - [可选] 删除通道：<br>如果分配的标签之一对应于空白空间，您可以选择从标签图像中删除该标签。<br>完成后，您应该删除此模块。</p>
<ul>
<li>Watershed Segmentation</li>
</ul>
<p>此模块通过对高梯度幅值应用分水岭来对不同相进行精确分割。<br>指定要分割的相数后，单击“跳过”按钮并按照说明进行操作。<br>要执行的操作包括：<br>指定相数。如果仅指定一个相，则将从指定相的侵蚀负片内部计算假标签。因此，分水岭计算期间指定相的扩散受到侵蚀的限制。<br>计算 3D 梯度幅值。内部使用 Avizo gradient_canny3d。或者，可以通过将梯度幅值标量场连接到 portGradient 来设置梯度幅值。<br>阈值梯度蒙版。使用滑块对梯度蒙版进行阈值设置，即定义无法设置标记的区域。<br>为相指定每个标记。可以使用最小和最大阈值滑块设置每个标记，也可以通过 portPhase 将相标记指定为二进制图像来设置每个标记。<br>应用分水岭计算。Avizo 分水岭算法根据先前设置的标记执行，以梯度幅度作为高度图像。<br>可视化最终阶段。颜色清洗模块连接到切片，同时提供阶段分割和原始数据可视化。</p>
<ul>
<li>Adaptive Thresholding</li>
</ul>
<p>该模块通过应用相对于滑动窗口的平均强度自动适应的阈值来执行二值化。<br>对于每个像素，根据其局部平均强度计算局部阈值。然后使用可以乘法或加法的模型应用此阈值。<br>保留的像素是那些根据比较标准“大于或等于”或“小于或等于”阈值的像素。</p>
<ul>
<li>Auto Thresholding</li>
</ul>
<p>自动阈值高是模块自动阈值的配置之一。有关其他配置，请参阅端口类型。<br>此模块计算灰度图像上的自动阈值，即将图像分成 2 个像素类。有四种分类方法：熵、因式分解、矩和 IsoData。计算出的阈值显示在表格面板中。</p>
<ul>
<li>Feature Adaptive Thresholding</li>
</ul>
<p>二值化将灰度图像转换为二进制图像。当灰度图像中的相关信息对应于特定的灰度间隔时，使用此方法。在二进制图像中，感兴趣的像素设置为 1，其他所有像素（背景）设置为 0。<br>此模块计算灰度图像的阈值，给定与原始图像的预分割相对应的标签图像。用户不是为阈值提供两个固定值，而是选择两个代表性度量（例如，直方图的第 10 和第 90 个百分位数）。每个标签的最小和最大阈值都是动态计算的，并对它们进行单独的阈值处理。</p>
<ul>
<li>Hysteresis Thresholding</li>
</ul>
<p>二值化将灰度图像转换为二进制图像。当灰度图像中的相关信息对应于特定的灰度间隔时，使用此方法。在二进制图像中，感兴趣的像素设置为 1，其他所有像素（背景）设置为 0。<br>滞后阈值使用滞后环来提供更连接的阈值结果。</p>
<ul>
<li>Interactive Thresholding</li>
</ul>
<p>此工具允许以交互方式选择阈值。当前选择显示为所连接正交视图的每个视图上的叠加层。<br>按“应用”按钮创建二进制图像。将创建一个新字段，该字段对于阈值间隔内的每个值均为 1，对于所有其他字段值均为 0。</p>
<ul>
<li>Interactive Top-Hat</li>
</ul>
<p>Top-Hat 分割从给定图像中提取小元素和细节。它检测对应于谷值或窄峰的暗区或白区。</p>
<p>有两种类型的 Top-Hat 变换：</p>
<p>黑色 Top-Hat：它被定义为使用给定大小的内核闭合的立方体与输入图像之间的差异。内核越小，Top-Hat 图像中的元素越小。阈值允许选择 Top-Hat 结果中较暗的元素，即所选谷值的深度。参见图 1。</p>
<p>白色 Top-Hat：它被定义为输入图像与其开口立方体之间的差异（使用给定大小的内核）。阈值允许选择 Top-Hat 结果中较亮的元素。</p>
<ul>
<li>Local Thresholding</li>
</ul>
<p>该模块提供算法，将图像堆栈二分分割为前景和背景对象。模块的输出是标签图像。如果需要在缓慢变化的背景之前分割多个小对象，则该算法效果最佳。<br>一些阈值算法需要大量主内存才能运行（Niblack、Oberlaender、Mardia-Hainsworth）。浮点分辨率缓冲区将根据输入图像大小进行分配。</p>
<ul>
<li>Threshold by Criterion</li>
</ul>
<p>按标准阈值对图像进行阈值处理。如果计算结果为真，则输出像素将设置为 1，否则设置为 0。</p>
<h3 id="是否需要阈值分割"><a href="#是否需要阈值分割" class="headerlink" title="是否需要阈值分割"></a>是否需要阈值分割</h3><img src="/2024/09/19/AVIZO%E8%87%AA%E5%8A%A8%E5%8C%96/ImageSegmentation-2.png" class="" title="ImageSegmentation-2">
<p>相同的数据体，计算曲率的过程相同<br>上面执行材料划分<br>下面不执行材料划分<br>数据执行结果相同<br>因为孔隙为1，骨架为0。</p>
<h2 id="曲率计算及分析"><a href="#曲率计算及分析" class="headerlink" title="曲率计算及分析"></a>曲率计算及分析</h2><h3 id="Image-Curvature"><a href="#Image-Curvature" class="headerlink" title="Image Curvature"></a>Image Curvature</h3><p>从本地加载一张tif图片，然后调用curvature方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">data = hx_project.load(<span class="string">&#x27;E:/digitalrock/eleven_sandstones_dataset/1_Berea/Berea_2d25um_binary_1-0_test.tif&#x27;</span>)</span><br><span class="line"></span><br><span class="line">curvature3d = hx_project.create(<span class="string">&#x27;curvature3d&#x27;</span>)</span><br><span class="line"></span><br><span class="line">curvature3d.ports.inputImage.connect(data)</span><br><span class="line"></span><br><span class="line">curvature3d.ports.doIt.was_hit = <span class="literal">True</span></span><br><span class="line">curvature3d.compute()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(curvature3d.results[<span class="number">0</span>].name)</span><br></pre></td></tr></table></figure>
<p><code>fire()</code> → 如果这是一个计算模块并且其端口 doIt 已被触碰或者自动刷新已被激活，则此方法将触发对对象上的 update() 的调用，并最终触发 compute() 的调用。<br><code>execute()</code> → 此方法将模拟点击此对象的属性区域下的绿色应用按钮，并对此对象执行<code>fire()</code>。<br><code>compute()</code> → 执行计算。</p>
<p>现在我们通过触发端口doIt来调用计算：<code>curvature3d.ports.doIt.was_hit = True</code></p>
<p>执行</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span>(<span class="built_in">open</span>(<span class="string">&#x27;F://PYCharmWorkSpace//DigitalCoreFeatureExtraction//avizo//avizo_test.py&#x27;</span>).read())</span><br></pre></td></tr></table></figure>
<h3 id="Image-Statistics"><a href="#Image-Statistics" class="headerlink" title="Image Statistics"></a>Image Statistics</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hx_project.create(<span class="string">&#x27;statistics&#x27;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Python handle of type: &#x27;HxCompModule&#x27;</span><br><span class="line">Kernel item name     : &#x27;Image Statistics&#x27;</span><br><span class="line">Kernel item type     : &#x27;HxQuant2GenericModule&#x27;</span><br><span class="line">All ports            :</span><br><span class="line">    &#x27;Type&#x27;: &#x27;HxPortModuleSwitch&#x27;</span><br><span class="line">    &#x27;interpretation&#x27;: &#x27;HxPortRadioBox&#x27;</span><br><span class="line">    &#x27;outputLocation&#x27;: &#x27;HxPortMultiMenu&#x27;</span><br><span class="line">    &#x27;doIt&#x27;: &#x27;HxPortDoIt&#x27;</span><br><span class="line">    &#x27;inputImage&#x27;: &#x27;HxConnection&#x27;</span><br><span class="line">    &#x27;rangeMode&#x27;: &#x27;HxPortMultiMenu&#x27;</span><br><span class="line">    &#x27;inputRange&#x27;: &#x27;HxPortIntTextN&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="Image-Curvature-Image-Statistics"><a href="#Image-Curvature-Image-Statistics" class="headerlink" title="Image Curvature + Image Statistics"></a>Image Curvature + Image Statistics</h3><ul>
<li>接收到处理结果</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">result1 = curvature3d.results[<span class="number">0</span>]</span><br><span class="line">result2 = curvature3d.results[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(result1.portnames)</span><br><span class="line"><span class="built_in">print</span>(result2.portnames)</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&#x27;master&#x27;, &#x27;histogramInfo&#x27;, &#x27;sharedColormap&#x27;, &#x27;preview&#x27;]</span><br><span class="line">[&#x27;master&#x27;, &#x27;histogramInfo&#x27;, &#x27;sharedColormap&#x27;, &#x27;preview&#x27;]</span><br></pre></td></tr></table></figure>
<ul>
<li>处理结果运行分析</li>
</ul>
<p>对两个曲率进行统计</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">imagestatic1 = hx_project.create(<span class="string">&#x27;statistics&#x27;</span>)</span><br><span class="line">imagestatic2 = hx_project.create(<span class="string">&#x27;statistics&#x27;</span>)</span><br><span class="line"></span><br><span class="line">imagestatic1.ports.inputImage.connect(result1)</span><br><span class="line">imagestatic2.ports.inputImage.connect(result2)</span><br><span class="line"></span><br><span class="line">imagestatic1.ports.doIt.was_hit = <span class="literal">True</span></span><br><span class="line">imagestatic2.ports.doIt.was_hit = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">imagestatic1.compute()</span><br><span class="line">imagestatic2.compute()</span><br></pre></td></tr></table></figure>
<ul>
<li>接收到统计结果</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">staticresult1 = imagestatic1.results[<span class="number">0</span>]</span><br><span class="line">staticresult12 = imagestatic2.results[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(staticresult1.portnames)</span><br><span class="line"><span class="built_in">print</span>(staticresult12.portnames)</span><br><span class="line"></span><br><span class="line">staticresult1.method</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&#x27;master&#x27;, &#x27;table&#x27;, &#x27;DataClass&#x27;]</span><br><span class="line">[&#x27;master&#x27;, &#x27;table&#x27;, &#x27;DataClass&#x27;]</span><br></pre></td></tr></table></figure>
<h3 id="读取表格"><a href="#读取表格" class="headerlink" title="读取表格"></a>读取表格</h3><p>参看API中<code>hx.core.HxSpreadSheetInterface</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ssi = staticresult1.all_interfaces.HxSpreadSheetInterface</span><br><span class="line"><span class="built_in">print</span>(ssi.tables[<span class="number">0</span>].columns[<span class="number">1</span>].name)	<span class="comment"># NbPixels</span></span><br><span class="line"><span class="built_in">print</span>(ssi.tables[<span class="number">0</span>].columns[<span class="number">5</span>].name)	<span class="comment"># Mean</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(ssi.tables[<span class="number">0</span>].items[<span class="number">0</span>,<span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(ssi.tables[<span class="number">0</span>].row[<span class="number">0</span>].items[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<h2 id="阈值分割计算曲率案例"><a href="#阈值分割计算曲率案例" class="headerlink" title="阈值分割计算曲率案例"></a>阈值分割计算曲率案例</h2><h3 id="2D"><a href="#2D" class="headerlink" title="2D"></a>2D</h3><p>1、加载图像<br>2、计算曲率<br>3、曲率结果处理</p>
<ul>
<li>2D图片加载弹窗问题</li>
</ul>
<p>暂时无法解决，获取不到对话框，只可以认为用鼠标连点器点击</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage.io <span class="keyword">import</span> imread_collection</span><br><span class="line"></span><br><span class="line">hx_project.remove_all()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">imgfloder_src = [<span class="string">&#x27;E:/digitalrock/eleven_sandstones_dataset/1_Berea/Berea_2d25um_binary_tif_1-0_test/&#x27;</span>]</span><br><span class="line"></span><br><span class="line">img_suffix = <span class="string">&#x27;*.tif&#x27;</span></span><br><span class="line"></span><br><span class="line">pixel_size = <span class="number">2.25e-6</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> imgfloder_src:</span><br><span class="line">    imgfloder_seq = imread_collection(i + img_suffix)</span><br><span class="line">    <span class="comment">#print(imgfloder_seq)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> imgfloder_seq.files:</span><br><span class="line">        img_name = j.split(<span class="string">&#x27;\\&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">        filepath = i + img_name</span><br><span class="line">        <span class="comment">#print(filepath)</span></span><br><span class="line">        data = hx_project.load(filepath)</span><br><span class="line">        curvaturemodel = hx_project.create(<span class="string">&#x27;curvature2d&#x27;</span>)</span><br><span class="line">        curvaturemodel.ports.inputImage.connect(data)</span><br><span class="line">        curvaturemodel.ports.doIt.was_hit = <span class="literal">True</span></span><br><span class="line">        curvaturemodel.compute()</span><br><span class="line"></span><br><span class="line">        gasscurvature = curvaturemodel.results[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        gasscurvaturestatistics = hx_project.create(<span class="string">&#x27;statistics&#x27;</span>)</span><br><span class="line">        gasscurvaturestatistics.ports.inputImage.connect(gasscurvature)</span><br><span class="line">        gasscurvaturestatistics.ports.doIt.was_hit = <span class="literal">True</span></span><br><span class="line">        gasscurvaturestatistics.execute()</span><br><span class="line">        gasscurvaturestatisticsresult = gasscurvaturestatistics.results[<span class="number">0</span>]</span><br><span class="line">        ssi1 = gasscurvaturestatisticsresult.all_interfaces.HxSpreadSheetInterface</span><br><span class="line">        <span class="built_in">print</span>(img_name + <span class="string">&quot;  &quot;</span> + <span class="string">&quot;&#123;:.4e&#125;&quot;</span>.<span class="built_in">format</span>((ssi1.tables[<span class="number">0</span>].items[<span class="number">0</span>, <span class="number">5</span>]) / pixel_size))  <span class="comment"># m-1</span></span><br><span class="line">        hx_project.remove_all()</span><br></pre></td></tr></table></figure>
<h3 id="3D-单个"><a href="#3D-单个" class="headerlink" title="3D-单个"></a>3D-单个</h3><p>1、加载图像<br>2、计算曲率<br>3、曲率结果处理</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加载数据</span></span><br><span class="line">data = hx_project.load(<span class="string">&#x27;E:/digitalrock/eleven_sandstones_dataset/1_Berea/Berea_2d25um_binary_1-0_test.tif&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建3维曲率计算模块</span></span><br><span class="line">curvaturemodel = hx_project.create(<span class="string">&#x27;curvature3d&#x27;</span>)</span><br><span class="line"><span class="comment"># 设置曲率计算模块输入</span></span><br><span class="line">curvaturemodel.ports.inputImage.connect(data)</span><br><span class="line"><span class="comment"># 设置曲率计算方法打开doIt</span></span><br><span class="line">curvaturemodel.ports.doIt.was_hit = <span class="literal">True</span></span><br><span class="line"><span class="comment"># 执行计算</span></span><br><span class="line">curvaturemodel.compute()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 高斯曲率计算结果</span></span><br><span class="line">gasscurvature = curvaturemodel.results[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 平均曲率计算结果</span></span><br><span class="line">avgcurvature = curvaturemodel.results[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建高斯曲率统计模块</span></span><br><span class="line">gasscurvaturestatistics = hx_project.create(<span class="string">&#x27;statistics&#x27;</span>)</span><br><span class="line"><span class="comment"># 设置高斯曲率计算模块输入</span></span><br><span class="line">gasscurvaturestatistics.ports.inputImage.connect(gasscurvature)</span><br><span class="line"><span class="comment"># 设置高斯曲率统计模块打开doIt</span></span><br><span class="line">gasscurvaturestatistics.ports.doIt.was_hit = <span class="literal">True</span></span><br><span class="line"><span class="comment"># 执行高斯曲率统计计算</span></span><br><span class="line">gasscurvaturestatistics.execute()</span><br><span class="line"><span class="comment"># 高斯曲率统计结果</span></span><br><span class="line">gasscurvaturestatisticsresult = gasscurvaturestatistics.results[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 查看高斯曲率整体均值</span></span><br><span class="line">ssi1 = gasscurvaturestatisticsresult.all_interfaces.HxSpreadSheetInterface</span><br><span class="line"><span class="built_in">print</span>(ssi1.tables[<span class="number">0</span>].items[<span class="number">0</span>, <span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建平均曲率统计模块</span></span><br><span class="line">avgcurvaturestatistics = hx_project.create(<span class="string">&#x27;statistics&#x27;</span>)</span><br><span class="line"><span class="comment"># 设置平均曲率计算模块输入</span></span><br><span class="line">avgcurvaturestatistics.ports.inputImage.connect(avgcurvature)</span><br><span class="line"><span class="comment"># 设置平均曲率统计模块打开doIt</span></span><br><span class="line">avgcurvaturestatistics.ports.doIt.was_hit = <span class="literal">True</span></span><br><span class="line"><span class="comment"># 执行平均曲率统计计算</span></span><br><span class="line">avgcurvaturestatistics.execute()</span><br><span class="line"><span class="comment"># 平均曲率统计结果</span></span><br><span class="line">avgcurvaturestatisticsresult = avgcurvaturestatistics.results[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 查看平均曲率整体均值</span></span><br><span class="line">ssi2 = avgcurvaturestatisticsresult.all_interfaces.HxSpreadSheetInterface</span><br><span class="line"><span class="built_in">print</span>(ssi2.tables[<span class="number">0</span>].items[<span class="number">0</span>,<span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># exec(open(&#x27;F://PYCharmWorkSpace//DigitalCoreFeatureExtraction//curvature//curvature_avizo_3d_test1.py&#x27;).read())</span></span><br></pre></td></tr></table></figure>
<p>执行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span>(<span class="built_in">open</span>(<span class="string">&#x27;F://PYCharmWorkSpace//DigitalCoreFeatureExtraction//curvature//curvature_avizo_3d_test1.py&#x27;</span>).read())</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0.04535578936338425</span><br><span class="line">-0.028369586914777756</span><br></pre></td></tr></table></figure>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">HibisciDai</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://hibiscidai.com/2024/09/19/AVIZO自动化/">http://hibiscidai.com/2024/09/19/AVIZO自动化/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://hibiscidai.com">HibisciDai</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Avizo/">Avizo</a><a class="post-meta__tags" href="/tags/%E7%9F%B3%E6%B2%B9%E5%9C%B0%E8%B4%A8/">石油地质</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E5%AD%97%E5%B2%A9%E5%BF%83/">数字岩心</a></div><div class="social-share pull-right" data-disabled="linkedin,diandian"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2025/02/28/Python%E7%A7%91%E5%AD%A6%E7%BB%98%E5%9B%BE/"><i class="fa fa-chevron-left">  </i><span>Python科学绘图</span></a></div><div class="next-post pull-right"><a href="/2024/09/03/AVIZO%E6%9B%B2%E7%8E%87%E8%AE%A1%E7%AE%97/"><span>AVIZO曲率计算</span><i class="fa fa-chevron-right"></i></a></div></nav><div class="post-adv"><a target="_blank" rel="noopener" href="https://www.paofu.cloud/auth/register?code=j4I7">好用、实惠、稳定的梯子,点击这里<img src="https://pic.imgdb.cn/item/65572abac458853aefef30cd.png" width="1000" height="124" object-fit="cover" ></a></div><div id="lv-container" data-id="city" data-uid="MTAyMC8zNTQ2NC8xMjAwMA=="><script>(function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
})(document, 'script');</script></div></div></div><footer class="footer-bg" style="background-image: url(/img/banner2.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2017 - 2025 By HibisciDai</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/js/katex.js"></script><script src="/js/search/local-search.js"></script><script id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" data-click="false"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>